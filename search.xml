<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AQS的Condition</title>
      <link href="2022/05/17/AQS%E7%9A%84Condition/"/>
      <url>2022/05/17/AQS%E7%9A%84Condition/</url>
      
        <content type="html"><![CDATA[<p>定义了等待/通知两种类型的方法，当线程调用这些方法的时候，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法创建出来的）。</p><table><thead><tr><th>void await()</th><th>当前线程进入等待状态直到被通知（signal）或中断，当前线程将进入运行状态且从await()方法返回。</th></tr></thead><tbody><tr><td>void awaitUninterruptibly()</td><td>当前线程进入等待状态直到被通知，从方法名称上可以看出该方法对中断不敏感</td></tr><tr><td>long awaitNanos(long nanosTimeout)</td><td>当前线程进入等待状态直到被通知、中断或者超时。返回值表示剩余的时间，如果在规定的时间返回，那么返回值就是nanosTimeout-实际耗时，如果返回值是0或者负数，那么就可以认定已经超时了</td></tr><tr><td>boolean awaitUntil(Date deadline)</td><td>当前线程进入等待状态直到被通知、中断或者到某个时间。如果没有到指定时间被通知，方法返回true，否则，表示到了指定时间，返回false</td></tr><tr><td>void signal()</td><td>唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关的锁</td></tr><tr><td>void singalAll()</td><td>唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关的锁</td></tr></tbody></table><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>主要是两个Condition，notFull和notEmpty,记住：返回false的时候await，返回true的时候signal</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>cycle<span class="token punctuation">.</span>thread</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Condition</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span><span class="token punctuation">;</span><span class="token comment">/** * 阻塞队列 * * @author qianxin * @date 2022/4/24 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BoundedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token comment">// 当前要添加到位置</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> addIndex<span class="token punctuation">;</span>    <span class="token comment">// 当前要移除的位置</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> removeIndex<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">BoundedQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 队列已满 当前线程在notFull等待(not Full 返回false 所以await)</span>                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 赋值成功</span>            items<span class="token punctuation">[</span>addIndex<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment">// 如果队列已经满了 下一个跳转到队列头</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>addIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                addIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 元素个数+1</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 唤起notEmpty等待线程（not Empty 返回true 所以signal）</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果个数为0 则当前线程在notEmpty等待(not Empty返回false 所以await)</span>                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 移除元素（先进先出）</span>            <span class="token class-name">Object</span> x <span class="token operator">=</span> items<span class="token punctuation">[</span>removeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>removeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果移除位置位于做后一个位置 那么下一个位置则跳转到队列头</span>                removeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 元素个数-1</span>            <span class="token operator">--</span>count<span class="token punctuation">;</span>            <span class="token comment">// 唤醒等待在notFull上的线程 （not Full返回true 所以signal）</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>主要是有三个元素：ConditionObject（Condition）、等待队列、等待和通知</p><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，<strong>如果一个线程调用了await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态</strong>。</p><p>一个Condition包含了一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。如下图所示：</p><p><img src="/2022/05/17/AQS%E7%9A%84Condition/image.png"></p><p>新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。引用更新并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p><p>一个同步队列和多个等待队列。</p><p><img src="/2022/05/17/AQS%E7%9A%84Condition/image2.png"></p><p>Condition的实现是同步器的内部类，因此每个Condition实例都是能够访问同步器提供的方法。</p><h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>调用Condition的await()方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p><p>如果从同步队列和等待队列的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到了Condition的等待队列中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当前线程加入等待队列</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放同步状态，也就是释放锁</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入到等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p><p>当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会跑出InterruptedException。</p><p>同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>调用Condition的sign()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会讲节点移动到同步队列。</p><p>sign方法源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>唤醒前进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/**    * Transfers a node from a condition queue onto sync queue.    * Returns true if successful.    * @param node the node    * @return true if successfully transferred (else the node was    * cancelled before signal)    */</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*        * If cannot change waitStatus, the node has been cancelled.        */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">/*        * Splice onto queue and try to set waitStatus of predecessor to        * indicate that thread is (probably) waiting. If cancelled or        * attempt to set waitStatus fails, wake up to resync (in which        * case the waitStatus can be transiently and harmlessly wrong).        */</span>    <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>被唤醒后的线程，将从await()方法中的while循环退出(isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中)，进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p><p>成功过获取同步状态之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功第获取了锁。</p><p>Condition的signAll()方法，相当于对等待队列中的每一个节点均执行一次sign()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><h2 id="每个线程一次打印数字"><a href="#每个线程一次打印数字" class="headerlink" title="每个线程一次打印数字"></a>每个线程一次打印数字</h2><p>比如三个线程一次打印1-100的数字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPrintHundredTwo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> reentrantLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Condition</span> c1 <span class="token operator">=</span> reentrantLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ThreadGroup</span> threadGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadGroup</span><span class="token punctuation">(</span><span class="token string">"交替打印数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>threadGroup<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TestPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>threadGroup<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TestPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>threadGroup<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TestPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestPrint</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            reentrantLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"===>"</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    c1<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    c1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 必需要唤起其他阻塞的线程 否则会有线程一直在阻塞 程序将不会结束</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    c1<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                reentrantLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 效果：</p><p><img src="/2022/05/17/AQS%E7%9A%84Condition/image3.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS解析</title>
      <link href="2022/05/02/AQS%E8%A7%A3%E6%9E%90/"/>
      <url>2022/05/02/AQS%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>是构建锁或者其他同步组件的基础框架，可以解决大部分的同步需求。</p><p>核心思想：<strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制</strong> <code>AQS</code> <strong>是用</strong> <code>CLH</code> <strong>队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。</p><p>简单原理：AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><p>同步队列展示图：</p><p><img src="/2022/05/02/AQS%E8%A7%A3%E6%9E%90/image1.png"></p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tryAcquire就是独占式获取状态，需要用户自己实现逻辑，成功返回true，失败返回false。</p><p>下面是addWaiter()和acquireQueued(),这两个函数都是在tryAcquire返回false才回去执行的，首先是addWaiter，很简单就是获取状态失败，需要将改线程封装成Node节点放入到双向队列中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */</span><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建新节点</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Try the fast path of enq; backup to full enq on failure</span>    <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 新节点的前置节点指向就的尾节点</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token comment">// 将新节点设置为新的尾节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 通过死循环来确保新节点已经作为了尾节点</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回该节点</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return &#123;@code true&#125; if interrupted while waiting */</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 死循环来获取状态</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 只有当前置节点为首节点时才会去获取状态</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取成功之后设置该节点为头节点</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 首节点的next指向null</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 如果获取失败则先判断是否要挂起当前线程 如果是 则挂起</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops.  Requires that pred == node.prev. * * @param pred node's predecessor holding status * @param node the node * @return &#123;@code true&#125; if thread should block */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token comment">/*         * This node has already set status asking a release         * to signal it, so it can safely park.         */</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*         * Predecessor was cancelled. Skip over predecessors and         * indicate retry.         */</span>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*         * waitStatus must be 0 or PROPAGATE.  Indicate that we         * need a signal, but don't park yet.  Caller will need to         * retry to make sure it cannot acquire before parking.         */</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Convenience method to park and then check if interrupted * * @return &#123;@code true&#125; if interrupted */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>acquireQueued中可以看作是一个自旋过程，自旋过程中如果判断出需要进行挂起，则会挂起当前线程。</p><h2 id="重入锁的公平"><a href="#重入锁的公平" class="headerlink" title="重入锁的公平"></a>重入锁的公平</h2><p>重入锁的公平与非公平最主要的是体现在，如果是当前线程的话，会直接获取锁，这时就是非公平的，举例：A线程lock了两次，之后，B线程，C线程也lock了，不过此时锁还在A线程中，B、C都进入了等待队列中。然后，A线程运行两次unlock，接着又lock了一次，按照公平的定义，A线程再lock也要排在B、C之后了，但是实际上A线程是非常有可能再次获取到锁的，这时候就不公平了。</p><p><a href="https://www.cnblogs.com/cg-ww/p/15422013.html">ReentrantLock可重入锁、公平锁非公平锁区别与实现原理 - 炒焖煎糖板栗 - 博客园</a></p><p>公平锁和非公平锁的tryAcquire基本一模一样，只多了这样一行代码</p><p><img src="/2022/05/02/AQS%E8%A7%A3%E6%9E%90/image2.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Queries whether any threads have been waiting to acquire longer * than the current thread. * * &lt;p>An invocation of this method is equivalent to (but may be * more efficient than): *  &lt;pre> &#123;@code * getFirstQueuedThread() != Thread.currentThread() &amp;&amp; * hasQueuedThreads()&#125;&lt;/pre> * * &lt;p>Note that because cancellations due to interrupts and * timeouts may occur at any time, a &#123;@code true&#125; return does not * guarantee that some other thread will acquire before the current * thread.  Likewise, it is possible for another thread to win a * race to enqueue after this method has returned &#123;@code false&#125;, * due to the queue being empty. * * &lt;p>This method is designed to be used by a fair synchronizer to * avoid &lt;a href="AbstractQueuedSynchronizer#barging">barging&lt;/a>. * Such a synchronizer's &#123;@link #tryAcquire&#125; method should return * &#123;@code false&#125;, and its &#123;@link #tryAcquireShared&#125; method should * return a negative value, if this method returns &#123;@code true&#125; * (unless this is a reentrant acquire).  For example, the &#123;@code * tryAcquire&#125; method for a fair, reentrant, exclusive mode * synchronizer might look like this: * *  &lt;pre> &#123;@code * protected boolean tryAcquire(int arg) &#123; *   if (isHeldExclusively()) &#123; *     // A reentrant acquire; increment hold count *     return true; *   &#125; else if (hasQueuedPredecessors()) &#123; *     return false; *   &#125; else &#123; *     // try to acquire normally *   &#125; * &#125;&#125;&lt;/pre> * * @return &#123;@code true&#125; if there is a queued thread preceding the *         current thread, and &#123;@code false&#125; if the current thread *         is at the head of the queue or the queue is empty * @since 1.7 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// The correctness of this depends on head being initialized</span>    <span class="token comment">// before tail and on head.next being accurate if the current</span>    <span class="token comment">// thread is first in queue.</span>    <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// Read fields in reverse initialization order</span>    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token class-name">Node</span> s<span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法的主要目的就是校验是否有线程比当前线程等待还要久，如果是，则返回true。</p><p>所以当这里整体的if返回false时</p><p><img src="/2022/05/02/AQS%E8%A7%A3%E6%9E%90/image3.png"></p><p>此时当前线程的tryAcquire就会返回false，也就是获取状态失败了。<strong>公平性就体现在这里。</strong></p><p>当前的线程不应该再获取到状态，而是有其他的线程来获取！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>相关类图</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image.png"></p><p>最常见的就是ThreadPoolExecutor类，他的构造方法最多能有七个参数</p><ol><li><p>corePoolSize：表示常驻核心线程数，如果等于0，则任务执行完成之后，没有任何请求进入时销毁线程池的线程；如果大于0，即使本地任务执行完毕，核心线程也不会被销毁。这个值的设置非常关键，设置过大会浪费资源，设置过小会导致线程频繁</p></li><li><p>maximumPoolSize：表示线程池能够容纳同时执行的最大线程数。如果maximumPoolSize与corePoolSize相等，即固定大小线程池。</p></li><li><p>keepAliveTime：表示线程池中的线程空闲时间，当空闲时间达到keepAliveTime值时，线程就会被销毁，直到只剩下corePoolSize个线程为止，避免浪费内存和句柄资源。默认情况下，当线程池的线程树大于corePoolSize时，keepAliveTime才会起作用。但是当ThreadPoolExecutor的allowCoreThreadTimeOut变量设置为true时，核心线程超时后才会被回收</p></li><li><p>TimeUnit：表示时间单位，通常是TimeUnit.SECONDS</p></li><li><p>workQueue:表示缓存队列。当请求的线程数大于corePoolSize时，线程进入BlockingQueue阻塞队列，BlockingQueue队列缓存达到上限后，如果还有新任务需要处理，那么线程池会创建新的线程，最大线程数为maximumPoolSize。</p></li><li><p>threadFactory：表示线程工厂。他用来生产一组相同任务的线程。线程池的命名是通过这个factory增加组名前缀来实现的。在虚拟机栈分析时，就可以知道线程任务是由哪个线程工厂产生的。</p></li><li><p>handler：表示拒绝策略，当workQueue的任务缓存区到达上限后，并且活动线程数大雨maximumPoolSize的时候，线程池通过该拒绝策略处理请求，这是一种简单的保护机制。友好的拒绝策略可以是如下三种。</p></li></ol><ul><li><p>保存到数据库进行削峰填谷，在空闲时在提取出来执行</p></li><li><p>转向某个提示页面</p></li><li><p>打印日志</p></li></ul><p>ThreadPoolExecutor中提供了四个公开的静态内部类</p><ul><li><p>AbortPolicy（默认）：丢弃任务并抛出RejectedExecutionException异常</p></li><li><p>DiscardPolicy：丢弃任务，但是不抛出异常，这是不推荐的做法</p></li><li><p>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中</p></li><li><p>CallerRunsPolicy：调用任务的run()方法绕过线程池直接执行。</p></li></ul><h2 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;. * * @param command the task to execute * @throws RejectedExecutionException at discretion of *         &#123;@code RejectedExecutionHandler&#125;, if the task *         cannot be accepted for execution * @throws NullPointerException if &#123;@code command&#125; is null */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn't, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 工作线程少于核心线程 添加一个worker</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 只有线程池处于running状态 才会将线程放入线程池的队列中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果线程池不是running状态，则将刚加入队列的任务移除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果之前的线程已被消费完，新建一个线程</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 队列已满 则创建一个新线程</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">// 创建失败 拒绝掉</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Worker对象"><a href="#Worker对象" class="headerlink" title="Worker对象"></a>Worker对象</h2><p>源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Class Worker mainly maintains interrupt control state for * threads running tasks, along with other minor bookkeeping. * This class opportunistically extends AbstractQueuedSynchronizer * to simplify acquiring and releasing a lock surrounding each * task execution.  This protects against interrupts that are * intended to wake up a worker thread waiting for a task from * instead interrupting a task being run.  We implement a simple * non-reentrant mutual exclusion lock rather than use * ReentrantLock because we do not want worker tasks to be able to * reacquire the lock when they invoke pool control methods like * setCorePoolSize.  Additionally, to suppress interrupts until * the thread actually starts running tasks, we initialize lock * state to a negative value, and clear it upon start (in * runWorker). */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token comment">/**     * This class will never be serialized, but we provide a     * serialVersionUID to suppress a javac warning.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6138294804551838833L</span><span class="token punctuation">;</span>    <span class="token comment">/** Thread this worker is running in.  Null if factory fails. */</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>    <span class="token comment">/** Initial task to run.  Possibly null. */</span>    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>    <span class="token comment">/** Per-thread task counter */</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token comment">/**     * Creates with given first task and thread from ThreadFactory.     * @param firstTask the first task (null if none)     */</span>    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/** Delegates main run loop to outer runWorker  */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Lock methods</span>    <span class="token comment">//</span>    <span class="token comment">// The value 0 represents the unlocked state.</span>    <span class="token comment">// The value 1 represents the locked state.</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> t<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到继承了AQS，实现了Runnable接口。先说Runnable接口，可以得知，这个worker对象是可以传给Thread来创建线程执行任务的，实际上也是这么做的。</p><p>有两个重要的属性</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image1.png"></p><p>在构造函数中就赋值了，</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image2.png"></p><p>firstTask就是传入进来的Runnbale对象，也就是execute方法的参数，thread这是通过线程工厂创建出来的线程，只不过是通过这个worker对象（worker也是一个Runnable）</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image3.png"></p><p>作为runnable对象最重要的run方法</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image4.png"></p><p>觉得是比较核心的地方了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>        w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>        <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// If pool is stopping, ensure thread is interrupted;</span>                <span class="token comment">// if not, ensure thread is not interrupted.  This</span>                <span class="token comment">// requires a recheck in second case to deal with</span>                <span class="token comment">// shutdownNow race while clearing interrupt</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                     <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                      <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用了runnable对象的run方法</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                        <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里拿到了worker对象中的firstTask对象，然后调用他的run对象，（<strong>这里特殊的就是其实我们很少去直接调用runnable对象的run方法，一般都是交给Thread对象执行start方法来走run方法里面的逻辑</strong>）</p><p>关于这个问题，我们看一下addWorker方法就知道了，从方法名中就可以猜出是添加一个worker对象的。方法就不全部展示了，只看关键的地方：</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image5.png"></p><p>拿到woker对象的thread，然后执行thread.start()方法，我们知道，这个地方就会去启动一个线程了，还记得worker对象中的thread是怎么来的吗？</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image6.png"></p><p>是当前worker对象（实现了Runnable接口）作为runnable参数生成的thread，所以这个时候调用thread.start()方法，其实运行的就是worker对象的run方法了，run方法里面调用了runWorker方法，参数也是当前的worker对象，最终调用worker对象中的fisrtTask的run方法，firstTask则是execute方法的我们添加的runnable。</p><p>整体流程：</p><ol><li><p>向线程池中添加了一个Runnable对象R1。</p></li><li><p>如果可以顺利执行到addWorker方法，则通过R1创建一个Worker对象W1,其中W1中的firstTask就是R1，thread则是通过当前W1对象new出来的Thread对象T1.</p></li><li><p>之后会调用T1.start()方法，启动一个线程去运行W1对象的run方法</p></li><li><p>（此时的线程已经是创建出来的新的线程了）run方法调用runWorker方法，这个方法中会拿到R1，新线程执行R1.run方法，就像调用普通方法一样。</p></li><li><p>总体感觉就是启动了一个线程执行了我们丢到线程池中Runnable对象的run方法。</p></li></ol><p>worker对象会保存到woerks（HashSet）属性中</p><h2 id="如何实现的线程等待任务"><a href="#如何实现的线程等待任务" class="headerlink" title="如何实现的线程等待任务"></a>如何实现的线程等待任务</h2><ol><li><p>线程池中如果没有任务，线程都会waiting，一旦添加了一个任务，就会被执行。</p></li><li><p>非核心线程会到了规定的时间会被销毁。</p></li></ol><p>线程池是如何实现上面特征的？阻塞队列</p><p>先了解阻塞队列的两个简单属性：</p><ul><li><p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p></li><li><p>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p></li></ul><p>第一个特征其实是通过阻塞的移除方法来实现的，也就是说当workQueue为是空的时候，会阻塞尝试从这队列获取数据的线程的。</p><p>在runWorker方法中，我们可以看到创建出来的线程是循环获取task的</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image7.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Did the last poll() time out?</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Check if queue empty only if necessary.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Are workers subject to culling?</span>            <span class="token comment">// 如果允许核心线程销毁或者worker数大于核心线程数</span>            <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 如果一直获取不到元素 则会在这里返回null</span>                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 通过timed来判断使用哪个方法</span>                <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span>                    workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>                    workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，如果timed为true，则调用poll方法，如果没有，则调用take方法，那这两个方法有什么不一样的吗？</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image8.png"></p><p><strong>poll只会等待规定的时间，如果时间到了就会返回null。</strong></p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image9.png"></p><p><strong>take则会一直等待，实现方式差不多，看一下LinkedBlockingQueue的</strong></p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image10.png"></p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image11.png"></p><p>最主要通过两个重入锁和他们的Condition来实现的，就是阻塞队列的核心部分。</p><p>这样一直获取不到的task的核心线程就会在这里等待，而非核心线程（或者需要销毁的线程），则会调用poll方法返回null，到runWorker方法中退出while循环</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image12.png"></p><p>之后就是调用processWorkerExit来移除worker对象等操作，最后执行完所有的方法后，线程就会自动销毁了。</p><h2 id="线程异常后"><a href="#线程异常后" class="headerlink" title="线程异常后"></a>线程异常后</h2><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image13.png"></p><p>可以看出，错误catch后还会被抛出，此时就会退出循环，之后该线程就会自动结束，如果队列中还有任务的话，会在processWorkerExit方法中再添加一个worker</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image14.png"></p><p>所以需要注意线程中错误的处理，不要被吞掉。</p><h2 id="核心线程与非核心线程"><a href="#核心线程与非核心线程" class="headerlink" title="核心线程与非核心线程"></a>核心线程与非核心线程</h2><p>其实线程并没有核心、非核心这个性质或者属性，在线程池中，仅仅作为计数，并不是队列满了之后开启的线程都会被作为非核心线程被销毁。</p><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 核心线程数1 最大线程数2 存活时间3s 阻塞队列 1</span>        <span class="token class-name">ThreadPoolExecutor</span> executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 执行这个11任务 此时创建的线程可以认为是核心线程 pool-1-thread-1</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"11=====,&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 睡眠两秒 防止抢占其他任务</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 该任务会存放在等待队列中 因为11任务还没有被执行完</span>            <span class="token comment">// 但线程执行该任务的时候会睡眠6秒 比存活时间要长</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"22=====,&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 该任务会开启一个线程 可以看做是非核心线程 pool-1-thread-2来执行</span>            <span class="token comment">// 注意的是 这个任务执行完后 会到等待队列中获取任务 也就是22任务 pool-1-thread-1线程还在睡眠</span>            <span class="token comment">// 所以在pool-1-thread-2线程执行22任务的时候 pool-1-thread-1线程执行完空闲了</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"33=====,&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 主线程睡眠足够的时间 让线程池回收非核心线程</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 此时存活的线程为pool-1-thread-2 由此可见，并非后面创建的线程就会被</span>        <span class="token comment">// 一定当作非核心线程而回收</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"44=====,&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image15.png"></p><p>哪个线程会被回收取决于在getTask方法中哪个线程调用poll方法</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image16.png"></p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image17.png"></p><h2 id="线程池如何关闭"><a href="#线程池如何关闭" class="headerlink" title="线程池如何关闭"></a>线程池如何关闭</h2><p><a href="https://www.yht7.com/news/184773">详解Java如何关闭线程以及线程池-云海天教程</a></p><p>shutdown：开始有序关闭线程池，与此同时，已提交的任务将继续执行，但不再接收新的任务，如果线程池已关闭，此方法调用不会产生额外影响。此方法不会等待已提交的任务执行完毕，要等待已提交任务执行完毕可以使用 awaitTermination() 方法。</p><p>shutdownNow：尝试终止所有正在执行的任务，并停止处理等待队列中的的任务，最后将所有未执行的任务列表的形式返回，此方法会将任务队列中的任务移除并以列表形式返回。此方法不会等待正在执行的任务执行完毕，要等待任务执行完毕可以使用awaitTermination()方法。此方法会尽最大努力终止正在执行的任务，除此之外不做其他保证，因为此方法底层实现是通过 Thread 类的interrupt()方法终止任务的，所以interrupt()未能终止的任务可能无法结束。</p><p>最主要的是靠中断interrupt()方法，分两种情况</p><p><strong>线程处于阻塞：立马退出阻塞，抛出InterruptedException异常。通过捕获这个异常，来让线程退出</strong></p><p><strong>线程处于非阻塞：处于运行状态不受影响，仅仅标记了线程的中断为true。在适当的位置中调用isInterrupted方法查看是否被中断并且退出</strong></p><p>所以对于处于等待过程的线程，会抛出异常，之后方法结束，线程自动销毁。对于还在处理任务的线程，在处理完任务后，再去获取任务时，如果是shutdownNow，所有线程都会被中断，还会移除等待队列中的所有任务，如果是shutdown，则是空闲线程被中断，线程池已经被置为不可用状态（shutdown：SHUTDOWN，shutdownNow：STOP，STOP&gt;SHUTDOWN），会直接返回null（shutdown会在等待队列isEmpty返回null，shutdownNow会直接返回)，此时方法结束，线程自动销毁。</p><h2 id="worker对象继承AQS"><a href="#worker对象继承AQS" class="headerlink" title="worker对象继承AQS"></a>worker对象继承AQS</h2><p>为什么要继承AQS？</p><p><strong>使用AQS为了保证独占性,当线程正在执行的时候则加锁,保证独占性,如果是空闲则表明这个Worker空闲,可以执行其他的任务.这里使用AQS不使用ReentrantLock是为了保证独占,不需要可重入性.</strong></p><p>还有就是为了能在线程池shutDown的时候，获取到空闲线程，对他们进行中断，因为非空闲线程都会被lock</p><p><img src="/2022/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image18.png"></p><p>空闲线程会阻塞在等待队列那里。</p><p>达到的效果就是：在空闲时可以响应中断，在执行任务时不可被中断。就是在中断之前首先尝试获得锁，trylock，由于不可重入特性，执行任务中的worker已经获得了lock，trylock失败，无法再中断woker对象的thread。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理导致循环依赖</title>
      <link href="2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>项目启动报错：</p><pre class="line-numbers language-debug" data-language="debug"><code class="language-debug">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;test1&#39;: Bean with name &#39;test1&#39; has been injected into other beans [test2] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:631) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) ~[spring-beans-5.3.7.jar:5.3.7]    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:657) ~[spring-beans-5.3.7.jar:5.3.7]    ... 20 common frames omitted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网上找一下，也会找到类似错误的代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">Test2</span> test2<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Async</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">Test1</span> test1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释也很清楚 Async 导致 test1 对象代理，在 Spring 中属性注入完成之后会有个校验，校验得到的 Bean 和二级缓存的 Bean 是否是同一个,错误就是在这里抛出来的。<br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image.png"><br>因为<br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image2.png"><br>走过这一步我们就会发现对象被代理了<br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image3.png"><br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image4.png"><br>这一步会给 test1 对象设置代理，返回代理对象，而二级缓存中的对象则是在 test2 对象设置属性的时候将三级缓存中的 test1 放到二级缓存的(<strong>此时放进去的是未代理的对象</strong>)。<br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image5.png"></p><p><a href="https://blog.csdn.net/liangbo7/article/details/122005608">参考文章</a></p><p><strong>但是有个小疑问就是 @Transactional 注解也是会产生代理对象的，但是此时并没有错误报出，这是怎么回事呢？</strong></p><p>最主要的原因就是因为这两个注解生成代理的地方是不一样的，通过调试可以知道，@Transaction 是在三级缓存放入二级缓存的时候生成的代理对象（<strong>此时放进去的是代理对象</strong>）如下图，三级缓存生成出来的对象就是代理过的<br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image6.png"><br>而在 initializeBean 这一步的时候并没有产生代理对象<br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image7.png"><br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image8.png"><br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image9.png"></p><p>所以在这个时候等式成立，代理对象也被赋值给 exposedObject。</p><p>那么为什么这两个生成代理的地方不一样呢？</p><p><strong>生成事务代理类 InfrastructureAdvisorAutoProxyCreator 实现了 SmartInstantiationAwareBeanPostProcessor，刚好代理逻辑在 getEarlyBeanReference 方法中（三级缓存返回对象给二级缓存的时候），所以 bean2 的属性 bean1 已经是代理后的对象；而生成异步代理类 AsyncAnnotationBeanPostProcessor 只是实现 BeanPostProcessor，代理逻辑在 postProcessAfterInitialization 方法</strong><br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image10.png"><br><img src="/2022/04/23/%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image11.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三级缓存以及循环依赖</title>
      <link href="2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>一级缓存：存放的是已经实例化并且初始化完成的 Bean，可以被用户使用的 Bean。<br><img src="/2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image.png"><br>二级缓存：存储提前暴露的 bean，也即是实例化，但是并没有初始化的 Bean<br><img src="/2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image2.png"><br>三级缓存：存储 bean 和其要加强的 aop 处理，如果需要 aop 增强的 bean 遇到了循环依赖，则使用该缓存中的 aop 处理代理增强 bean<br><img src="/2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image3.png"><br>三级缓存与其他不同的是，里面存放的是一个 ObjectFactory</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Return an instance (possibly shared or independent)     * of the object managed by this factory.     * @return the resulting instance     * @throws BeansException in case of creation errors     */</span>    <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个函数式类，只有一个接口来返回一个 Object。</p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>因为在实例化时这个 bean 的时候（通过参数构造创建对象），你需要一个对象，而这个对象在实例化的时候又不得不需要你（通过参数构造创建对象），这样一来你们都无法创建对象，所以就形成了循环依赖，那为什么官方要推荐使用这种容易形成循环依赖的方式，因为 spring 认为循环依赖的出现就是你的程序设计不合理，提示你要修改。</p><p>为什么@Autowired 可以解决循环依赖就浮出了表面：先创建对象再注入属性。因为调用的是无参的构造函数，而构造器方法的调用的是有参的构造函数！<br><img src="/2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image4.png"><br>构造器注入为什么会循环依赖报错，属性注入却不会？</p><p>构造器注入使用的是有参的构造函数，这是如果出现相互依赖，就会出现死循环的结果，构造出来的实例也无法放入缓存中。<br><img src="/2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image5.png"><br>属性注入使用的是无参的构造函数，先实例化，并且将实例化的 ObjectFactory 对象放入三级缓存中。<br><img src="/2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image6.png"><br><img src="/2022/04/21/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image7.png"><br>加入三级缓存。</p><blockquote><p>用构造器注入会循环核心问题是：构造器发生在对象实例化过程中，是不放入缓存的，所以每次都去实例化，导致死循环。而可以通过 set 注入方式，是把对象分成实例化和初始化，实例化后就放入到对应的 3 级缓存，后面初始化就可用缓存，不必再重新实例化</p></blockquote><h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>二级缓存是为了解决循环依赖问题的（A 依赖 B，B 依赖 C，C 依赖 A），三级缓存则是解决循环依赖过程中处理对象代理的问题，防止注入的对象不是代理对象。</p><p>A 依赖 B，B 依赖 A，假设 A 会有代理，B 设置 A 属性的时候从三级缓存取 A 对象的时候，如果此时三级缓存不做代理，取出来的则是 A 源对象（这里还有一个操作就是会将三级缓存取出来的 A 源对象放入二级缓存中），B 设置完 A 属性之后，A 设置好 B 属性，此时会对 A 对象做一个代理，产生代理对象 A1，并且 A1 才是最后我们需要的对象。注意，<strong>A1 依赖了 B，但是 B 依赖了 A 对象，此时就有问题了，B 里面的 A 对象不是代理对象 A1.</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boot多数据源调用mapper</title>
      <link href="2022/04/11/boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E8%B0%83%E7%94%A8mapper/"/>
      <url>2022/04/11/boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E8%B0%83%E7%94%A8mapper/</url>
      
        <content type="html"><![CDATA[<p>场景：查询数据库的表信息，也就是表结构的数据，字段属性等等，写了一个 mapper 来查询 information_schema.tables 的数据，就可以查询本项目中数据库的表信息。现在需要查询别的数据库中的表信息，很明显，这个 mapper 是能够通用的，主要是换一个数据源，数据源的信息来自数据库中，也就是用户在项目中配置的。</p><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>可以用过 dataSource 对象来获取到 sqlSessionTemplate 对象，再通过这个对象来获取到这个数据源的 mapper，代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DruidDataSource</span> datasource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置数据源 </span>datasource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://10.211.22.193:3306?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>datasource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"hfins"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>datasource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"hfins"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>datasource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SqlSessionFactory</span> object<span class="token punctuation">;</span><span class="token comment">// 通过SqlSessionFactoryBean来获取到sqlSessionFactory</span><span class="token class-name">SqlSessionFactoryBean</span> bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bean<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>datasource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 配置mybatis运行时参数</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span></span>Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span></span>Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自动将数据库中的下划线转换为驼峰格式</span>configuration<span class="token punctuation">.</span><span class="token function">setMapUnderscoreToCamelCase</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bean<span class="token punctuation">.</span><span class="token function">setConfiguration</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//添加xml目录</span><span class="token class-name">ResourcePatternResolver</span> resolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PathMatchingResourcePatternResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 解析Mapper文件bean.setMapperLocations(resolver.getResources("classpath*:/com/hscs/datastructure/infra/mapper/*Mapper.xml"));</span>     object <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过SqlsessionFacotryu构造出SqlSessionTemplate</span><span class="token class-name">SqlSessionTemplate</span> sqlSessionTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// SqlSessionTemplate获取Mapper对象</span><span class="token class-name">SysColumnsMapper</span> mapper <span class="token operator">=</span> sqlSessionTemplate<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">SysColumnsMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用结果：<br><img src="/2022/04/11/boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E8%B0%83%E7%94%A8mapper/image.png"></p><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>对每一个数据源都是用一个单独的 Spring 容器，通过 Spring 容器来家在 Mapper 对象，看起来确实绕路了，但是可以试试。</p><p>配置类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 这里不需要添加Bean的注解了 因为register就是为了注册Bean </span><span class="token comment">// 内容差不多 都是设置数据源和SqlSessionFactory</span><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.hscs.datastructure.infra.mapper"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSourceConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;test.url&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> url<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;test.username&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;test.password&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"roleDataSource"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DataSource</span> <span class="token function">roleDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">DruidDataSource</span> datasource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        datasource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        datasource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        datasource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        datasource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> datasource<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">SqlSessionFactory</span> <span class="token function">roleSqlSessionFactory</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"roleDataSource"</span><span class="token punctuation">)</span> <span class="token class-name">DataSource</span> dataSource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SqlSessionFactoryBean</span> bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 配置mybatis运行时参数</span>        <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span></span>Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span></span>Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 自动将数据库中的下划线转换为驼峰格式</span>        configuration<span class="token punctuation">.</span><span class="token function">setMapUnderscoreToCamelCase</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setConfiguration</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//添加xml目录</span>        <span class="token class-name">ResourcePatternResolver</span> resolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PathMatchingResourcePatternResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            bean<span class="token punctuation">.</span><span class="token function">setMapperLocations</span><span class="token punctuation">(</span>resolver<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token string">"classpath*:/com/hscs/datastructure/infra/mapper/*Mapper.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> bean<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token comment">//    @Bean</span><span class="token comment">//    public SqlSessionTemplate baiduSqlSessionTemplate(@Qualifier("roleSqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><span class="token comment">//        //使用上面配置的Factory</span><span class="token comment">//        SqlSessionTemplate sqlSessionTemplate = new SqlSessionTemplate(sqlSessionFactory);</span><span class="token comment">//        SysColumnsMapper mapper = sqlSessionTemplate.getMapper(SysColumnsMapper.class);</span><span class="token comment">//        return new SqlSessionTemplate(sqlSessionFactory);</span><span class="token comment">//    &#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何使用这个配置了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">AnnotationConfigApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置参数properties</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"test.username"</span><span class="token punctuation">,</span> <span class="token string">"hfins"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"test.password"</span><span class="token punctuation">,</span> <span class="token string">"hfins"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"test.url"</span><span class="token punctuation">,</span> <span class="token string">"jdbc:mysql://10.211.22.193:3306?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这个设置一定要在设置数据源配置之前</span>context<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MapPropertySource</span><span class="token punctuation">(</span><span class="token string">"datasource"</span><span class="token punctuation">,</span>        map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">DataSourceConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动容器</span>context<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从容器中获取mapper调用方法</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">SysColumnsMapper</span><span class="token punctuation">)</span>context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"sysColumnsMapper"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTableListForMysql</span><span class="token punctuation">(</span><span class="token string">"hscs_hsae"</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果<br><img src="/2022/04/11/boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E8%B0%83%E7%94%A8mapper/image2.png"><br>这种则是典型的显示创建 spring 容器。一般情况也会把这个容器存储起来，比如放到 HashMap 中，防止重复创建。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conditional相关注解</title>
      <link href="2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
      <url>2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h2><p><strong>它的作用是按照一定的条件进行判断，满足条件给容器注册 bean</strong>。条件就是注解中 Condition 的实现类的实现方法 matches 的返回值（true 或者 false），可以有多个条件，必须同时为 true 才会注册 bean，<strong>该注解也可以用在配置类上，来决定了一批 bean 是否注入</strong>。</p><p>代码演示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//配置类</span><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span><span class="token string">"beanConfig2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span><span class="token class-name">WindowsCondition</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"bill"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">person1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"bill gate"</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"linus"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span><span class="token class-name">LinuxCondition</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">person2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"linus"</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//WindowsCondition</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WindowsCondition</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">ConditionContext</span> context<span class="token punctuation">,</span> <span class="token class-name">AnnotatedTypeMetadata</span> metadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"windows"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//LinuxCondition</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinuxCondition</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">ConditionContext</span> context<span class="token punctuation">,</span> <span class="token class-name">AnnotatedTypeMetadata</span> metadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Mac OS X"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image.png"><br><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image2.png"><br>可以看到只注入了 linus 的 Bean，bill 的 Bean 并没有注入。</p><h2 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="ConditionalOnBean"></a>ConditionalOnBean</h2><p>要求额外的 bean 存在时，才会创建这个 bean；</p><p>如我提供了一个 bean 名为 <code>RedisOperBean</code>，用于封装 redis 相关的操作；但是我这个 bean 需要依赖 <code>restTemplate</code> 这个 bean，只有当应用引入了 redis 的相关依赖，并存在 <code>RestTemplate</code>bean 的时候，<code>RedisOperBean</code>bean 才会生效。<br>代码举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfiguration1</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Bean1</span> <span class="token function">bean1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bean1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfiguration2</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span><span class="token class-name">Bean1</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Bean2</span> <span class="token function">bean2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bean2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有 Bean1 初始化了，Bean2 才能进行初始化<br><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image3.png"><br>如果换一下位置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfiguration1</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span><span class="token class-name">Bean2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Bean1</span> <span class="token function">bean1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bean1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfiguration2</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Bean2</span> <span class="token function">bean2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bean2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image4.png"></p><p>可以发现 Bean1 的初始化失败了。主要是因为 BeanConfiguration1 比 BeanConfiguration2 的配置类要更先加载，初始化 Bean1 的时候发现容器中没有 Bean2，所以 Bean1 就没有初始化。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>通过 ConditionalOnClass(@ConditionalOnClass 通常与@Configuration 结合使用，意思是当 classpath 中存在某类时满足条件)。</li><li>通过 AutoConfigureBefore 或者 AutoConfigureAfter 注解，但是请注意：**@AutoConfigureBefore 和@AutoConfigureAfter 这两个注解是针对使用 spring.factories 加载的配置(也就是说注解中的 Bean 是必须通过 spring.factories 来加载)。如果是自定义的实现类是在项目中被自动扫描后进行配置的，注解不会生效。**</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//注意两个类都没有配置@Configuration注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfiguration1</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span><span class="token class-name">Bean2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Bean1</span> <span class="token function">bean1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bean1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@AutoConfigureBefore</span><span class="token punctuation">(</span><span class="token class-name">BeanConfiguration1</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfiguration2</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Bean2</span> <span class="token function">bean2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bean2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image5.png"></p><p>运行结果：</p><p><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image6.png"></p><h2 id="ConditionalOnMissingBean"><a href="#ConditionalOnMissingBean" class="headerlink" title="ConditionalOnMissingBean"></a>ConditionalOnMissingBean</h2><p>@ConditionalOnMissingBean，它是修饰 bean 的一个注解，主要实现的是，<strong>如果当前没有这个类型的 Bean（注解的值），就会使用这个注解使用的 Bean。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">Computer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Computer</span> <span class="token function">c1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Computer</span> <span class="token function">c2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image7.png"><br>打印这两个 Bean：<br><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image8.png"><br>因为 c1 的时候还并没有 Computer 的 Bean 注入，所以 c1 也注入成功了。<br>如果换一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Computer</span> <span class="token function">c1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">Computer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Computer</span> <span class="token function">c2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image9.png"><br>因为 c2 注入的时候发现已经有了 Computer 的 Bean 了，所以 c2 这个 Bean 是不会注入的。</p><h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="ConditionalOnProperty"></a>ConditionalOnProperty</h2><p>场景：项目中自带 mongodb，但是 mongodb 并不是项目中所必须要有的中间件，所以 mongodb 的配置需要根据实际需要来生效或不生效的。</p><p>使用 ConditionalOnProperty 就可以通过 yml 中配置的属性来达到这个效果。<br><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image10.png"></p><ul><li>value:获取对应 property 名称的值，与 name 不可同时使用</li><li>prefix：属性名称的前缀</li><li>name：数组，配置属性完整名称或部分名称，可与 prefix 组合使用，组成完整的配置属性名称，与 value 不可同时使用</li><li>havingValue：比较获取到的属性值与 havingValue 给定的值是否相同，相同才加载配置</li><li>matchIfMissing：缺少该配置属性时是否可以加载。如果为 true，没有该配置属性时也会正常加载；反之则不会生效</li></ul><p>配置类使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @author qianxin * @date 2022/2/18 * ConditionalOnProperty *     检查hscs.mongodb.enable-flag属性是否为false，如果为false，则加载当前的Bean，matchIfMissing默认为false 未进行属性配置，则自动配置不生效 */</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token class-name">MongoAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">MongoDataAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"hscs.mongodb"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"enable-flag"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"false"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExcludeMongoConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="ConditionalOnExpression"></a>ConditionalOnExpression</h2><p>其他conditional</p><p><a href="https://blog.csdn.net/yusimiao/article/details/99301346">https://blog.csdn.net/yusimiao/article/details/99301346</a></p><p>多个配置属性一起判断，那么我们就可以用这个表达式<br><img src="/2022/04/02/Conditional%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/image11.png"><br>只有当两个属性都为 true 的时候才加载 MyModule.再比如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//当是oracle数据库时，才会加载Bean</span><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">OracleDialectHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnExpression</span><span class="token punctuation">(</span><span class="token string">"'$&#123;spring.datasource.url:&#125;'.contains('oracle')"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">QueryHandler</span> <span class="token function">oracleDialectHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OracleDialectHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvcc</title>
      <link href="2022/03/22/mvcc/"/>
      <url>2022/03/22/mvcc/</url>
      
        <content type="html"><![CDATA[<p><code>MVCC</code>，全称 <code>Multi-Version Concurrency Control</code>，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，<strong>只有写写之间相互阻塞，其他三种操作都可以并行</strong>，这样大幅度提高了 InnoDB 的并发度。在内部实现中，与 Postgres 在数据行上实现多版本不同，InnoDB 是在 undolog 中实现的，通过 undolog 可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在 InnoDB 内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。  MVCC 是一种多版本并发控制机制。</p><h2 id="当前读、快照读"><a href="#当前读、快照读" class="headerlink" title="当前读、快照读"></a>当前读、快照读</h2><p><a href="https://www.cnblogs.com/xuwc/p/13873611.html">参考资料</a></p><ul><li><p>当前读:像select lock in share mode(<code>共享锁</code>), select for update ; update, insert ,delete(<code>排他锁</code>)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</p></li><li><p>快照读:像<code>不加锁</code>的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p></li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>主要依赖记录中的3个隐式字段，undo日志，Read View来实现的。</p><h2 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h2><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段。</p><ul><li><p>DB_TRX_ID：6byte，最近修改（修改/插入）事务ID：记录创建这条记录/最后一次修改改记录的事务ID</p></li><li><p>DB_POLL_PTR:7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p></li><li><p>DB_ROW_ID：6byte，隐含的自增id（隐藏主键），如果数据表没有主键，innodb会自动已DB_ROW_ID产生一个聚簇索引</p></li><li><p>实际上还有一个删除flag隐藏字段，即记录被更新或删除并不代表真的删除，而是删除flag变了</p></li></ul><p><img src="/2022/03/22/mvcc/image.png"></p><p>DB_ROW_ID是数据库默认认为该记录生成的唯一隐式主键，DB_TRX_ID是当前记录的事务ID，而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本。</p><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p><a href="https://leviathan.vip/2019/02/14/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-Undo-Log/#:"><strong>https://leviathan.vip/2019/02/14/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-Undo-Log/#:</strong></a></p><p>一条 Undo Log 对应一个事务中的一条读写语句，Undo Log 记录了被修改的 Record 的旧版本数据，当其他的事务需要读取该记录的旧版本时，通过 Undo Log 可以回溯到对应的版本的数据. 另外当事务需要回滚时，也可以根据 Undo Log 进行数据的回滚.</p><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_11"><strong>https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_11</strong></a></p><p>分两种</p><ul><li><p>insert undo log 代表事务在insert新纪录时产生的undo log，只在事务提交后可以被立即丢弃。</p></li><li><p>update undo log 事务在进行update或delete时产生的undo log；不仅在事务回滚时需要，在快照读时也需要，所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除。</p></li></ul><blockquote><p>purge<br>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。<br>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</p></blockquote><p>执行流程如下：</p><p>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，<code>name</code>为Jerry, <code>age</code>为24岁，<code>隐式主键</code>是1，<code>事务ID</code>和<code>回滚指针</code>，我们假设为NULL</p><p><img src="/2022/03/22/mvcc/image2.png"></p><p>二、 现在来了一个<code>事务1</code>对该记录的<code>name</code>做出了修改，改为Tom</p><ul><li><p>在<code>事务1</code>修改该行(记录)数据时，数据库会先对该行加<code>排他锁</code></p></li><li><p>然后把该行数据拷贝到<code>undo log</code>中，作为旧记录，既在<code>undo log</code>中有当前行的拷贝副本</p></li><li><p>拷贝完毕后，修改该行<code>name</code>为Tom，并且修改隐藏字段的事务ID为当前<code>事务1</code>的ID, 我们默认从<code>1</code>开始，之后递增，回滚指针指向拷贝到<code>undo log</code>的副本记录，既表示我的上一个版本就是它</p></li><li><p>事务提交后，释放锁</p></li></ul><p><img src="/2022/03/22/mvcc/image3.png"></p><p>三、 又来了个<code>事务2</code>修改<code>person表</code>的同一个记录，将<code>age</code>修改为30岁</p><ul><li><p>在<code>事务2</code>修改该行数据时，数据库也先为该行加锁</p></li><li><p>然后把该行数据拷贝到<code>undo log</code>中，作为旧记录，发现该行记录已经有<code>undo log</code>了，那么最新的旧数据作为链表的表头，插在该行记录的<code>undo log</code>最前面</p></li><li><p>修改该行<code>age</code>为30岁，并且修改隐藏字段的事务ID为当前<code>事务2</code>的ID, 那就是<code>2</code>，回滚指针指向刚刚拷贝到<code>undo log</code>的副本记录</p></li><li><p>事务提交，释放锁</p></li></ul><p><img src="/2022/03/22/mvcc/image4.png"></p><p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的<code>undo log</code>成为一条记录版本线性表，既链表，<code>undo log</code>的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p><h2 id="Read-View（读视图）"><a href="#Read-View（读视图）" class="headerlink" title="Read View（读视图）"></a>Read View（读视图）</h2><p>Read View就是事务进行<code>快照读</code>操作的时候生产的<code>读视图</code>(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>所以我们知道 <code>Read View</code>主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code>读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p><p><code>Read View</code>遵循一个可见性算法，主要是将<code>要被修改的数据</code>的最新记录中的<code>DB_TRX_ID</code>（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果<code>DB_TRX_ID</code>跟Read View的属性做了某些比较，不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出<code>Undo Log</code>中的<code>DB_TRX_ID</code>再比较，即遍历链表的<code>DB_TRX_ID</code>（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的<code>DB_TRX_ID</code>, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新<code>老版本</code></p><p><img src="/2022/03/22/mvcc/image5.png"></p><p>在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p><blockquote><p><code>trx_list</code>（名字我随便取的）一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID</p><p><code>up_limit_id</code>记录trx_list列表中事务ID最小的ID</p><p><code>low_limit_id</code>ReadView生成时刻系统尚未分配的下一个事务ID，也就是<code>目前已出现过的事务ID的最大值+1</code></p></blockquote><ul><li><p>首先比较<code>DB_TRX_ID &lt; up_limit_id</code>, 如果小于，则当前事务能看到<code>DB_TRX_ID</code> 所在的记录，如果大于等于进入下一个判断</p></li><li><p>接下来判断 <code>DB_TRX_ID 大于等于 low_limit_id</code> , 如果大于等于则代表<code>DB_TRX_ID</code> 所在的记录在<code>Read View</code>生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</p></li><li><p>判断<code>DB_TRX_ID</code> 是否在活跃事务之中，<code>trx_list.contains(DB_TRX_ID)</code>，如果在，则代表我<code>Read View</code>生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在<code>Read View</code>生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</p></li></ul><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><ul><li>当<code>事务2</code>对某行数据执行了<code>快照读</code>，数据库为该行数据生成一个<code>Read View</code>读视图，假设当前事务ID为<code>2</code>，此时还有<code>事务1</code>和<code>事务3</code>在活跃中，<code>事务4</code>在<code>事务2</code>快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为<code>trx_list</code></li></ul><table><thead><tr><th>事务1</th><th>事务2</th><th>事务3</th><th>事务4</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td><td>事务开始</td><td>事务开始</td></tr><tr><td>…</td><td>…</td><td>…</td><td>修改且已提交</td></tr><tr><td>进行中</td><td>快照读</td><td>进行中</td><td></td></tr><tr><td>…</td><td>…</td><td>…</td><td></td></tr></tbody></table><ul><li>Read View不仅仅会通过一个列表<code>trx_list</code>来维护<code>事务2</code>执行<code>快照读</code>那刻系统正活跃的事务ID，还会有两个属性<code>up_limit_id</code>（记录trx_list列表中事务ID最小的ID），<code>low_limit_id</code>(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是<code>目前已出现过的事务ID的最大值+1</code>，我更倾向于后者 <a href="https://www.zhihu.com/question/66320138/answer/241418502">&gt;&gt;&gt;资料传送门 | 呵呵一笑百媚生的回答</a>) ；所以在这里例子中<code>up_limit_id</code>就是1，<code>low_limit_id</code>就是4 + 1 = 5，trx_list集合的值是1,3，<code>Read View</code>如下图</li></ul><p><img src="/2022/03/22/mvcc/image6.png"></p><ul><li>我们的例子中，只有<code>事务4</code>修改过该行记录，并在<code>事务2</code>执行<code>快照读</code>前，就提交了事务，所以当前该行当前数据的<code>undo log</code>如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的<code>DB_TRX_ID</code>去跟<code>up_limit_id</code>,<code>low_limit_id</code>和<code>活跃事务ID列表(trx_list)</code>进行比较，判断当前<code>事务2</code>能看到该记录的版本是哪个。</li></ul><p><img src="/2022/03/22/mvcc/image7.png"></p><ul><li>所以先拿该记录<code>DB_TRX_ID</code>字段记录的事务ID <code>4</code>去跟<code>Read View</code>的的<code>up_limit_id</code>比较，看<code>4</code>是否小于<code>up_limit_id</code>(1)，所以不符合条件，继续判断 <code>4</code> 是否大于等于 <code>low_limit_id</code>(5)，也不符合条件，最后判断<code>4</code>是否处于<code>trx_list</code>中的活跃事务, 最后发现事务ID为<code>4</code>的事务不在当前活跃事务列表中, 符合可见性条件，所以<code>事务4</code>修改后提交的最新结果对<code>事务2</code>快照读时是可见的，所以<code>事务2</code>能读到的最新数据记录是<code>事务4</code>所提交的版本，而事务4提交的版本也是全局角度上最新的版本</li></ul><p><img src="/2022/03/22/mvcc/image8.png"></p><ul><li>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</li></ul><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>RR是如何在RC级的基础上解决不可重复读的？</p><p>当前读和快照读在RR级别下的区别：</p><p>表1 </p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>快照读(无影响)查询金额为500</td><td>快照读查询金额为500</td></tr><tr><td>更新金额为400</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>select 快照读金额为500</td></tr><tr><td></td><td>select lock in share mode当前读金额为400</td></tr></tbody></table><p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据40</p><p>表2</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>快照读（无影响）查询金额为500</td><td></td></tr><tr><td>更新金额为400</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>select 快照读金额为400</td></tr><tr><td></td><td>select lock in share mode当前读金额为400</td></tr></tbody></table><p>而在<code>表2</code>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p><ul><li>这里与上表的唯一区别仅仅是<code>表1</code>的事务B在事务A修改金额前<code>快照读</code>过一次金额数据，而<code>表2</code>的事务B在事务A修改金额前没有进行过快照读。</li></ul><p>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</p><p>我们这里测试的是<code>更新</code>，同时<code>删除</code>和<code>更新</code>也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p><p>RC,RR级别下的InnoDB快照读有什么不同？</p><p>正是<code>Read View</code>生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p><ul><li><p>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</p></li><li><p>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</p></li><li><p>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</p></li></ul><p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>大概流程和上面一样：<br>四个概念</p><ul><li>m_ids:表示在生成 readview 时，当前系统中活跃的读写事务 id 列表</li><li>min_trx_id:表示在生成 readview 时，当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中最小的值</li><li>max_trx_id:表示在生成 readview 时，系统中应该分配给下一个事务的 id 值(<strong>readView 和事务没有绑定关系</strong>)</li><li>creator_trx_id:表示生成该 review 的事务的事务 id</li></ul><p>在访问某条记录时，按照一下步骤判断记录的某个版本是否可见，trx_id 表示当前这个记录的事务 id</p><ol><li>如果 trx_id=creator_id，表明当前事务在访问自己修改过的记录，该版本可以被当前事务访问；</li><li>trx_id&lt;min_trx_id，表明生成该版本的事务在当前事务生成 readveiw 之前就已经提交了，该版本可以被当前事务访问</li><li>trx_id&gt;=max_trx_id，表明生成该版本的事务在当前事务生成 readview 后才开启，该版本不可以被当前事务访问。</li><li>min_trx_id=&lt;trx_id&lt;max_trx_id,需要判断 trx_id 是不是在 m_ids 列表中</li></ol><ul><li>如果在，说明创建 readview 时生成该版本的事务还是活跃的，该版本不可访问</li><li>如果不在，说明创建 readview 时生成该版本的时候已经提交了，该版本可以被访问</li></ul><p><strong>生成 readview 时机</strong></p><ul><li>RC 隔离级别：每次读取数据前，都生成一个 readview；</li><li>RR 隔离级别：在第一次读取数据前，生成一个 readview；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql基本常用原则</title>
      <link href="2022/03/02/sql%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8E%9F%E5%88%99/"/>
      <url>2022/03/02/sql%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p><strong>设计主键时一定要是自增的，非常不建议使用 UUID</strong></p><p>mysql 在维护聚簇索引的时候是按照主键的顺序排序的，也就是说数据页的数据一定是按照主键从小到大排序的<br><img src="/2022/03/02/sql%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8E%9F%E5%88%99/image.png"><br>如果主键是自增的，那么根据主键目录能够很快的定位到新增记录的插入，如果不是自增的话，那么就需要从头开始比较，比较影响效率</p><p>唯一索引和主键索引类似，但是唯一索引不一定是自增的，所以维护唯一索引的成本肯定大于主键索引。</p><h3 id="为频繁查询到字段建立索引"><a href="#为频繁查询到字段建立索引" class="headerlink" title="为频繁查询到字段建立索引"></a>为频繁查询到字段建立索引</h3><h3 id="避免为大字段建立索引"><a href="#避免为大字段建立索引" class="headerlink" title="避免为大字段建立索引"></a>避免为大字段建立索引</h3><p>因为 mysql 在维护索引的时候是会把字段值也维护进去，大字段就意味着占用更多的空间，排序花费更多的时间</p><h3 id="区分度大的列作为索引"><a href="#区分度大的列作为索引" class="headerlink" title="区分度大的列作为索引"></a>区分度大的列作为索引</h3><p>比如是/否字段就不能作为索引，mysql 存在一个查询优化器，如果发现某个值出现在表的数据行中的百分比很高的时候，会忽略索引，进行全表扫描。惯用的百分比界线是”30%”。（匹配的数据量超过一定限制的时候查询器会放弃使用索引（<strong>这也是索引失效的场景之一</strong>）。</p><blockquote><p>索引基数</p></blockquote><h3 id="为-groupBy-和-orderBy-后面的字段创建索引"><a href="#为-groupBy-和-orderBy-后面的字段创建索引" class="headerlink" title="为 groupBy 和 orderBy 后面的字段创建索引"></a>为 groupBy 和 orderBy 后面的字段创建索引</h3><h3 id="不要在条件中使用函数"><a href="#不要在条件中使用函数" class="headerlink" title="不要在条件中使用函数"></a>不要在条件中使用函数</h3><p>如果非要使用函数的业务场景的话，建议创建索引的时候连着函数一起创建</p><h3 id="不要建立太多的索引"><a href="#不要建立太多的索引" class="headerlink" title="不要建立太多的索引"></a>不要建立太多的索引</h3><h3 id="频繁增删改的字段不要建立索引"><a href="#频繁增删改的字段不要建立索引" class="headerlink" title="频繁增删改的字段不要建立索引"></a>频繁增删改的字段不要建立索引</h3><p>因为索引的变化 mysql 是需要重新去维护索引的。</p><h3 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h3><ul><li>or 关键字</li><li>不遵循最左前缀原则</li><li>模糊查询以% 开头</li><li>使用了隐式转换</li></ul><h2 id="查询原则"><a href="#查询原则" class="headerlink" title="查询原则"></a>查询原则</h2><h3 id="等值匹配原则"><a href="#等值匹配原则" class="headerlink" title="等值匹配原则"></a>等值匹配原则</h3><p>比如有 name+age 的联合索引，现在有这样的一条 sql</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'wx'</span> <span class="token operator">and</span> age<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>像这种 where 后面的条件是联合索引的并且是联合索引中的字段的顺序排列的，且全是是用等于号条件，称之为<strong>等值匹配原则。</strong></p><h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>比如有（classId,name,age）联合索引，那他们在数据页的存在方式如下：</p><p>首先按照 classId 字段值排序，如果 classId 一样，那么就根据第二个 name 字段排序，如果 name 字段值也一样的话，那么就根据 age 字段排序，如果 age 也一样，那么就根据主键字段值排序。</p><p>如果按照 classId 和 name 作为条件，所以 mysql 可以通过 classId 很快可以定位到一批数据的，因为这个条件是 mysql 维护 B+树的第一条件，然后同理，name 也是如此，所以即使没有 age 条件，使用索引 classId 和 name 的索引一定是没问题的。但是如果这样查</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from student where age<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果跳过了左边的字段，这样子和全表扫描是没有区别的，因为 mysql 此时无法确认 age 在哪里，只能全表扫描。</p><p>这个规则就是最左前缀匹配原则。</p><h3 id="范围查找规则"><a href="#范围查找规则" class="headerlink" title="范围查找规则"></a>范围查找规则</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> classId<span class="token operator">></span><span class="token number">1</span> <span class="token operator">and</span> classId<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时由联合索引（classId，name，age）构建出来的 B+树的数据是根据 classId，name,age 去排序的。所以此时是能根据 classId 查询到一个范围中的数据的，<strong>虽然他们可能不在同一个数据页中，但是，数据页与数据页之间是通过双向链表进行连接的，所以此时依旧是能走索引的。</strong><br>但是如果是这样的：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> classId <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">AND</span> classId <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">and</span> name <span class="token operator">></span><span class="token string">'a'</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">'x'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般的感觉是 classId 是符合范围查找的，然后查询出来的结果继续范围查找 name.</p><p>但实际结果不是这样的，最后只会使用到索引中的 classId 字段。因为这时候按照最左匹配原则，确定了 classId 的范围之后，在这个范围中 name 是无序的。</p><p><img src="/2022/03/02/sql%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8E%9F%E5%88%99/image2.png"></p><p>比如 classId&gt;=2 and classId&lt;=4 ，在这个范围内可以看到 name 是无序的<br>针对范围查找只要联合索引的最左侧列有效，其他的都无法使用索引。</p><h3 id="等值匹配-范围查找"><a href="#等值匹配-范围查找" class="headerlink" title="等值匹配+范围查找"></a>等值匹配+范围查找</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> classId <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> name <span class="token operator">></span> <span class="token string">'a'</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">'x'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际结果就是 classId 是做索引的，name 也是走索引的。</p><p>因为第一个字段 classId 是等值匹配，在等值匹配的范围中，name 是有序的,所以这个时候 name 的范围查询走索引是没有问题的</p><p><img src="/2022/03/02/sql%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8E%9F%E5%88%99/image3.png"></p><p>这就是为什么等值后面可以范围的原因，<strong>必须满足最左匹配原则，也就是前面的记录必须是确定的，这样才能继续对后面的数据判断。</strong></p><h3 id="order-by-limit-优化"><a href="#order-by-limit-优化" class="headerlink" title="order by+limit 优化"></a>order by+limit 优化</h3><p>假设对 name、age、address 三个字段创建联合索引，查询的时候 sql 语句是这样的</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>address <span class="token keyword">from</span> student <span class="token keyword">order</span> <span class="token keyword">by</span> name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>address <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的 order by 是最好的，取得记录字段在维护联合索引的 B+树中都是存在的，也不需要回表到聚簇索引中查询了。</p><p>order by 后面的字段要么全是升序，要么全是降序。</p><h3 id="分组查询优化"><a href="#分组查询优化" class="headerlink" title="分组查询优化"></a>分组查询优化</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> student <span class="token keyword">group</span> <span class="token keyword">by</span> name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不对 name 建立索引，那么就是将所有的数据查询出来，放在一个临时文件中，然后按照分组的字段一组一组的分好。</p><p>因为此时的 name 并没有索引，所以按照 name 去分组首先需要得到一个根据 name 排序的数据，此时就需要一个临时表来记录并统计结果。</p><p>所以如果存在一个排好序的数据，就不需要临时表了。那就是直接对 name 建立索引，此时 B+树中的 name 就是排好序的，不需要临时表，也不需要额外排序。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于主键索引，mysq 就是根据主键字段进行排序，一般主键字段都设置为自增的，假设不是自增的，还会导致分裂的发生，降低性能。</p><p>对于非主键索引（联合索引），mysql 会维护一个 B+树，叶子结点上（数据页）上面保存的数据仅仅是索引字段数据和主键数据。</p><p>主键数据主要是为了当联合索引的字段值如果都一样的时候，可以进行排序。</p><p>聚簇索引中已经有全部记录的值，通过主键能够快速定位到一条完全的记录了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚集索引与非聚集索引</title>
      <link href="2022/02/20/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/"/>
      <url>2022/02/20/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>聚集索引表记录的排列顺序和索引的排列顺序一致（以 InnoDB 聚集索引的主键索引来说，<strong>叶子节点中存储的就是行数据，行数据在物理储器中的真实地址就是按照主键索引树形成的顺序进行排列的</strong>），所以<strong>查询效率快</strong>，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是<strong>修改慢</strong>，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序（因为在真实物理存储器的存储顺序只能有一种，而插入新数据必然会导致主键索引树的变化，主键索引树的顺序发生了改变，叶子节点中存储的行数据也要随之进行改变，就会发生大量的数据移动操作，所以效率会慢）。<strong>因为在物理内存中的顺序只能有一种，所以聚集索引在一个表中只能有一个</strong>。</p><h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p>非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致（在逻辑上数据是按顺序排存放的，但是物理上在真实的存储器中是散列存放的），两种索引都采用 B+树结构，<strong>非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式</strong>。非聚集索引层次多，不会造成数据重排。所以如果表的读操作远远多于写操作，那么就可以使用非聚集索引。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中B+树的应用</title>
      <link href="2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>特点：</p><ul><li><p>B+树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子结点上，而非叶子结点只存储 key 的信息，<strong>这样可以大大减小每个节点的存储 key 的数量，降低 B+树的高度（磁盘页就能存放更多的 key 节点，减少了磁盘 IO</strong>）</p></li><li><p>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针</p></li><li><p>B+树的层级更少：非叶子结点存储的关键字数跟多，树的层级更少查询更快</p></li><li><p>B+树数据都存放在节点，所以每次查询查找的次数都相同，所以查找速度比 B 树会更加稳定</p></li><li><p><strong>B+树天然具备排序功能，B+树所有的叶子结点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密度高，缓存的命中率也会比 B 树高。</strong></p></li><li><p>B+树全节点遍历更快，因为数据都存放在叶子结点上，只需要遍历所有的叶子结点，而 B 树还需要遍历每个节点，因为非叶子结点上也会存储数据。</p></li></ul><p><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image.png"></p><h2 id="主键目录"><a href="#主键目录" class="headerlink" title="主键目录"></a>主键目录</h2><p><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image2.png"><br>mysql在存储数据的时候是以数据页为最小单位的，且数据在数据页中的存储是连续的，数据页中的数据是按照主键排序的（没有主键是由mysql自己维护的ROW_ID来排序），数据页和数据页之前是通过双向链表来关联的，数据与数据之间是通过单向链表维护的。</p><p>数据页的页号和数据页的最小主键会组成一个主键目录，这样主键查找时通过二分法会很快的定位到数据页。</p><h2 id="索引页"><a href="#索引页" class="headerlink" title="索引页"></a>索引页</h2><p>但是当数据量非常大时，二分查找的效率依旧是很低，所以设计了新的存储结构–索引页。</p><p>比如主键目录中存储了很多的主键信息，结构如下<br><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image3.png"></p><p>mysql会将其拆分成下面这样<br><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image4.png"><br>主键和数据页不单纯在主键目录中维护了，演变成了索引页，一张不够就分裂至下一张。</p><p>但是这样从外围是无法确定到哪个主键位于哪个索引页上，所以这个时候就需要一个东西来维护索引页，比如这样：<br><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image5.png"><br>如果要找id=20的数据，那么就会在索引页8上去找最小主键来确定下一页索引页（通过二分）</p><h2 id="索引分层"><a href="#索引分层" class="headerlink" title="索引分层"></a>索引分层</h2><p>数据量非常大的时候，索引页的数据就非常多，这个时候就要向上分层<br><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image6.png"><br>所以mysql整个数据结构就如下图所示<br><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image7.png"><br>这时就非常像一颗二叉树，也是数据在磁盘中真正存储的物理结构。索引页+数据页组成的B+树就是聚簇索引。</p><blockquote><p>聚簇索引是mysql基于主键索引结构创建的</p></blockquote><h2 id="非主键索引"><a href="#非主键索引" class="headerlink" title="非主键索引"></a>非主键索引</h2><p>也就是所说的联合索引。现在对name+age维护索引，原理是一样的，都是创建一颗B+树（所以索引不是越多越好，因为会占用空间）。</p><p>数据依旧是存放在数据页中，只不过每条记录存放的是 name=xx,age=xx,id=xx,不管怎么样，主键肯定会存的</p><p><img src="/2022/02/12/mysql%E4%B8%ADB-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/image8.png"></p><p>插入数据的时候，会按照name排序，如果name一样就按照age排序，如果还是一样就按照id排序。此时数据页中存放的是索引字段和主键，其他的字段是不会存的，会浪费空间。</p><p>对于非主键索引（一般都是联合索引），在维护 B+ 树的时候，会根据联合索引的字段依次去判断，假设联合索引为：<strong>name + address + age，那么 MySQL 在维护该索引的 B+ 树的时候，首先会根据 name 进行排序，name 相同的话会根据第二个 address 排序，如果 address 也一样，那么就会根据 age 去排序，如果 age 也一样，那么就会根据主键字段值去排序，且对于非主键索引，MySQL 在维护 B+ 树的时候，仅仅是维护索引字段和主键字段。</strong><br>查找的过程和聚簇索引是一样的。</p><p>下面这个sql:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name<span class="token punctuation">,</span>age <span class="token keyword">from</span> student <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'xx'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的sql是会直接全部走索引的，不会进行回表。</p><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>联合索引中存储了name，age，id三个字段，所以如果查找的是这三个，那么就会直接从联合索引中返回了。但如果还有其他字段要查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'xx'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，联合索引并不会存储其他字段的值，这个时候就需要回表了。会根据id到聚簇索引的B+树中查询，因为聚簇索引中的数据页存储的是一条完整的记录，这个过程叫做回表。</p><h2 id="为什么不使用-B-树"><a href="#为什么不使用-B-树" class="headerlink" title="为什么不使用 B 树"></a>为什么不使用 B 树</h2><p>当数据量过大的时候，会导致每个节点的 key 存储的较少，B 树会很深，增加了磁盘的 IO 次数影响查询效率.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树</title>
      <link href="2022/02/11/B-%E6%A0%91/"/>
      <url>2022/02/11/B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>操作系统从磁盘读取数据到内存是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k）。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>有 k 个子树的中间节点包含有 k 个元素（B 树中是 k-1 个元素），<strong>每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</strong></li><li><strong>所有叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</strong></li><li><strong>所有叶子结点元素都同时存在于子节点，在子节点元素中是最大或最小元素。</strong></li></ul><p><img src="/2022/02/11/B-%E6%A0%91/image.png"><br>描述：</p><ul><li>每一个父节点的元素都出现在子节点中，是子节点的最大或最小元素</li><li>根结点的最大元素等同于整个 B+树的最大元素，以后无论插入删除多少元素，<strong>始终要保持最大元素在根结点中。</strong></li><li>父节点的元素都出现在了子节点中，因此所有叶子结点包含了全量元素信息。</li><li><strong>每一个叶子结点都带有指向下一个结点的指针，形成了一个有序链表。</strong><br><img src="/2022/02/11/B-%E6%A0%91/image2.png"><br>卫星数据：索引元素指向的数据记录，比如数据库中的某一行。在 B 树中无论中间节点还是叶子结点都带有卫星数据.<br><img src="/2022/02/11/B-%E6%A0%91/image3.png"><br>在数据库的聚集索引中，叶子结点直接包含卫星数据。在非聚集索引中，叶子节点带有指向卫星数据的指针。（只有叶子结点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联）<br><img src="/2022/02/11/B-%E6%A0%91/image4.png"><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2>B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的结点元素，也就意味着数据量相同的情况下，B+树比B树更加矮胖，因此查询时IO次数也更少。</li></ul><p>B+树的查询必须最终找到叶子结点，而B树只要找到匹配元素即可，无论匹配元素位于中间节点还是叶子结点。因此B树的查询性能并不稳定，B+树的每一次查询都是稳定的。</p><p>范围查询更简便，只要找到最小的元素，然后进行链表顺序查询即可。</p><p>总结：</p><ol><li>单一结点存储更多的元素，使得查询的 IO 次数更少</li><li>所有查询都要找到叶子结点，查询性能稳定</li><li>所有叶子结点形成有序链表，便于范围查询</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hzero 异常处理</title>
      <link href="2022/01/23/hzero%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2022/01/23/hzero%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="异常统一处理"><a href="#异常统一处理" class="headerlink" title="异常统一处理"></a>异常统一处理</h2><p>通过@ExceptionHandler来指定异常的获取</p><p><img src="/2022/01/23/hzero%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1.png"></p><p>并返回错误的Response。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HlsExceptionHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> LOGGER <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">HlsExceptionHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> PROFILE_DEV <span class="token operator">=</span> <span class="token string">"dev"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> PROFILE_DEFAULT <span class="token operator">=</span> <span class="token string">"default"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;spring.profiles.active:dev&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> env<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">FeignException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">processFeignException</span><span class="token punctuation">(</span><span class="token class-name">FeignException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"FeignException info: &#123;&#125;"</span><span class="token punctuation">,</span> exception<span class="token punctuation">.</span><span class="token function">getTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token class-name">MessageAccessor</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name"><span class="token namespace">feign<span class="token punctuation">.</span></span>FeignException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">processFeignException</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">feign<span class="token punctuation">.</span></span>FeignException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"FeignException info: &#123;&#125;"</span><span class="token punctuation">,</span> exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token class-name">ExceptionResponseUtils</span><span class="token punctuation">.</span><span class="token function">resolveFeignException</span><span class="token punctuation">(</span>exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">CommonException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">CommonException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"common exception info: "</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token class-name">MessageAccessor</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">NotFoundException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">NotFoundException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"NotFoundException info"</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.resource.notExist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">MethodArgumentNotValidException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">MethodArgumentNotValidException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"MethodArgumentNotValidException process "</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> defaultMessage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ObjectError</span><span class="token punctuation">)</span> exception<span class="token punctuation">.</span><span class="token function">getBindingResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAllErrors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDefaultMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token class-name">MessageAccessor</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token string">"error.methodArgument.notValid"</span><span class="token punctuation">,</span> defaultMessage<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">DuplicateKeyException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">DuplicateKeyException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"DuplicateKeyException process "</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.db.duplicateKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">MultipartException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">MultipartException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"MultipartException process "</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.upload.multipartSize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">BadSqlGrammarException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">BadSqlGrammarException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"BadSqlGrammarException process"</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.db.badSql"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">MessageException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">MessageException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageAccessor</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">HystrixRuntimeException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">HystrixRuntimeException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.network"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">IllegalArgumentException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">HttpMessageNotReadableException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">OptimisticLockException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">OptimisticLockException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.optimistic_lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">NotLoginException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">NotLoginException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.not_login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RuntimeException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">CheckedException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">CheckedException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token class-name">MessageAccessor</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">SQLException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ExceptionResponse</span><span class="token punctuation">></span></span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">SQLException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExceptionResponse</span> er <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionResponse</span><span class="token punctuation">(</span><span class="token string">"error.sql_exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDevException</span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>er<span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setDevException</span><span class="token punctuation">(</span><span class="token class-name">ExceptionResponse</span> er<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>PROFILE_DEV<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>env<span class="token punctuation">)</span> <span class="token operator">||</span> PROFILE_DEFAULT<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>env<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            er<span class="token punctuation">.</span><span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            er<span class="token punctuation">.</span><span class="token function">setTrace</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Throwable</span> cause <span class="token operator">=</span> ex<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cause <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                er<span class="token punctuation">.</span><span class="token function">setThrowable</span><span class="token punctuation">(</span>cause<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cause<span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                er<span class="token punctuation">.</span><span class="token function">setThrowable</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以返回错误堆栈给前台，方便错误的排查</p><p><img src="/2022/01/23/hzero%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/2.png"></p><p>但是这样的返回结果只在开发环境具备，如果是是正式环境，那么则禁止将具体的错误堆栈在前台展示，此时就需要关闭这个Exception的展示，比如下面</p><p><img src="/2022/01/23/hzero%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/3.png"></p><p>所以要动态的去处理Exception</p><p><img src="/2022/01/23/hzero%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/5.png"></p><p><img src="/2022/01/23/hzero%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/4.png"></p><p>通过spring的profile来判断当前是否是开发环境，如果是开发环境，那么则将Exception也返回，否则不会返回Exception错误堆栈</p>]]></content>
      
      
      
        <tags>
            
            <tag> hzero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hzero 实体注册</title>
      <link href="2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/"/>
      <url>2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，一张业务表会对应代码中的一个entity，hzero会讲这些表的信息存储到redis中，以后面使用。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/1.png"></p><p>首先这张表的数据也是会存入到数据库中的</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/2.png"></p><p>之后会在某个时间点存入到redis中</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/3.png"></p><h2 id="EntityRegistInitializer"><a href="#EntityRegistInitializer" class="headerlink" title="EntityRegistInitializer"></a>EntityRegistInitializer</h2><p>首先会有一个实体注册初始化器</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/4.png"></p><p>实现了ApplicationRunner。<strong>（该接口是在spring Boot启动之后做的一些初始化操作）</strong></p><p>需要通过配置文件来开启实体注册的功能，并且被注册的实体上必须要有@Table注解，用来表示是哪一张表</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/5.png"></p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/6.png"></p><p>通过找到的entityClass组装参数发送feign请求来注册实体</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/7.png"></p><p>整体流程还是比较简单的，就是在应用启动的时候，去扫描代码中的实体，下面看看如何扫描的</p><h2 id="EntityRegistScannerRegistrar"><a href="#EntityRegistScannerRegistrar" class="headerlink" title="EntityRegistScannerRegistrar"></a>EntityRegistScannerRegistrar</h2><p>除了配置文件打开实体注册的功能外 ，还需要在启动类上配置扫描实体的包路径来告诉初始化器去注册哪些实体。</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/8.png"></p><p>这个@EntityRegistScan注解通过@Import注解引入了EntityRegistScannerRegistrar类</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/9.png"></p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/12.png"></p><p>该类实现了<strong>ImportBeanDefinitionRegistrar</strong>接口,然而在该实现中，虽然自定义了实体注册的Scanner，但是并没有像平常的registrar去注册bean，仅仅是扫描出这些实体类，然后存放到EntityRegisterHelper中的静态变量中，以便之后组装数据进行实体注册！</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/10.png"></p><p>自定义了一个Scanner，然后在doScan中去扫描那些被@Table所标注的实体</p><p><img src="/2022/01/11/hzero%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%86%8C/11.png"></p><p>注意 这种方式并没有将实体注册为Bean，因为扫描的时候使用的是doscan方法而不是scan方法，这样是为什么要实现自己的Sacnner的原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hzero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据页</title>
      <link href="2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/"/>
      <url>2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>innodb 从磁盘中读取数据的最小单位是数据页，而 id=XXX 的数据时，就是这个数据页众多行中的一行。<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image.png"><br>同一个表空间内的一组连续的数据页为一个extent(区),默认区的大小为1MB，页的大小为16KB。16*64=1024，也就是一个区里面会有64个连续的数据页，连续的256个数据区为一组数据区<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image2.png"></p><p>windmills schema中有一个名为wmills的表。在数据目录中（通常是/var/lib/mysql/）您会看到它包含有：</p><pre class="line-numbers language-none"><code class="language-none">data&#x2F;  windmills&#x2F;      wmills.ibd      wmills.frm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为参数innodb_file_per_table从MySQL5.6开始已经设置为1。这样设置，schema中每个表都是一个文件（如果是分区表，则有多个文件）。</p><p>这里重要的是名为wmills.ibd的文件。这个文件被分为N个段。每个段都与一个索引相关联。</p><p>尽管文件不会因删除数据而收缩，段本身会增长或收缩，下一级为区。一个区仅存在一个段中，并且固定尺寸为1MB（在默认页大小的情况下）。页是区的下一级，默认大小为16KB。</p><p>因此，一个区最多可包含64页。一个页可以包含2到N行。一个页可以容纳的行数与行大小有关，这是表结构设计时定义的。InnoDB中有一个规则，至少要在一个页中容纳两行。因此，行大小限制为8000字节。<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image3.png"></p><h2 id="页内部"><a href="#页内部" class="headerlink" title="页内部"></a>页内部</h2><p>页可以是空，也可以是被填充满（100%）。行记录由主键组织。例如，如果您的表使用自增值，您将有序列ID=1，2，3，4等。<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image4.png"></p><p>页还有另一个重要属性：MERGE_THRESHOLD。这个参数的默认值是页的50%，它在InnoDB页合并活动中起着非常重要的作用：</p><p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image5.png"></p><p>在插入数据时，如果插入的记录可以容纳在该页内，则按顺序填充该页。</p><p>当页已经满时，下一条记录将插入到下一页：<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image6.png"></p><p>鉴于B+树的特点，该结构不仅可以自上而下沿着子树查找，还可以水平跨叶节点查找。这是因为每个叶节点页都有一个指向包含序列中下一个记录的页的指针。</p><p>例如，第5页指向下一页第6页。第6页指向前一页（第5页），并指向下一页（第7页）。</p><p>链表的这种机制允许快速、有序的扫描（例如，范围扫描）。如之前所述，这是在插入基于自增主键的表发生的情况。但是如果我开始删除值时会发生什么呢？</p><h2 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h2><p>当您删除一条记录时，不会实际删除该记录，而是将记录标记为已删除，并且该记录使用的空间可回收。<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image7.png"><br>当一个页删除足够多的数据，达到合并阈值（默认是页大小的50%），InnoDB开始找相邻的页（之前和之后的）查看它们是否有机会合并两个页，优化空间使用率。<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image8.png"><br>在这个例子中，第6页占用空间不足一半。第5页删除了很多记录，也使用了不足50%。从InnoDB的角度看，它们是可以合并的：<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image9.png"><br>合并操作的结果是：第5页包含了之前的数据和第6页的数据。第6页变成了空页，可用于新数据。<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image10.png"></p><p>当我们更新一条记录，新记录的大小使页面低于阈值时，也会发生相同的过程。</p><p>规则是：<strong>如果在相邻页有更新和删除操作</strong>，将产生合并。如果合并成功，在 <code>INFORMATION_SCHEMA.INNODB_METRICS</code> 表中的 <code>index_page_merge_successful</code> 指标将会增加。</p><h2 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h2><p>如上所述，一个页最多可以填充 100%。发生这种情况时，下一页将获取新记录。</p><p>但是如果我们遇到以下情况呢？<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image11.png"><br>第10页没有足够的空间容纳新的记录（或者更新的记录）。遵循下一页的逻辑，这个记录应该在第11页上。然而：<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image12.png"><br>第11页也已满，数据不能乱序插入。那该怎么办呢？</p><p>还记得我们说过的链表吗？此时第10页之前的页为第9页，之后的页为第11页。</p><p>InnoDB将做的是（简化版）：</p><ol><li> <strong>创建一个新页。</strong></li><li> <strong>确定原始页（第 10 页）可以在哪里拆分（在记录级别）</strong></li><li> <strong>移动记录</strong></li><li> <strong>重新定义页之间关系</strong><br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image13.png"><br>新的第12页被创建：<br><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E9%A1%B5/image14.png"><br>第11页保持原样。改变的是页之间的关系：</li></ol><ul><li>第 10 页之前的页为第 9 页，之后的页为第 12 页</li><li>第 12 页之前的页为第 10 页，之后的页是第 11 页</li><li>再往后的页数不做变化，不过整体需要进行页的调整</li></ul><p>通常，我们可以说：<strong>页分裂发生在插入或者更新，并导致页错位（在许多情况下，程度不同）。</strong><br>InnoDB 在 <code>INFORMATION_SCHEMA.INNODB_METRICS</code> 表中记录了页分裂的次数。查看 <code>index_page_splits</code> 和 <code>index_page_reorg_attempts/successful</code> 指标。</p><p>一旦分裂的页创建，将其回收的唯一方法是将创建的页降至合并阈值下。当这发生时，InnoDB 通过合并操作将数据从分裂页迁移走。</p><p>另外一个组织数据的方法是 <code>OPTIMIZE TABlE</code>。这是一个代价比较大和长的过程，但通常是处理太多页比较稀疏的唯一方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hzero 开发者路由</title>
      <link href="2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/"/>
      <url>2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>微服务的开发环境下，自己本地的开发实例会注册到开发环境的eureka上，所以eureka上会始终有一个开发环境的服务实例，和若干个开发人员的开发实例。</p><p>那么开发过程中，前端的请求如何能准确的打到开发人员的开发实例上，从而方便开发与调试呢？</p><p>开发者路由就是来解决这个问题的</p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>在springcloud中，使用的是ribbon来解决负载均衡的问题，而常见的负载均衡策略包括有</p><p>  1）轮询</p><p>  2）随机</p><p>  3）一致性哈希</p><p>  4）哈希</p><p>  5）加权</p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/1.png"></p><h3 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h3><p>这是所有负载均衡策略的父接口，里边的核心方法就是choose方法，用来选择一个服务实例。</p><h3 id="AbstractLoadBalancerRule"><a href="#AbstractLoadBalancerRule" class="headerlink" title="AbstractLoadBalancerRule"></a>AbstractLoadBalancerRule</h3><p>AbstractLoadBalancerRule是一个抽象类，里边主要定义了一个ILoadBalancer，就是负载均衡器，这里就不再赘述，这里定义它的目的主要是辅助负责均衡策略选取合适的服务端实例。</p><h3 id="RandomRule"><a href="#RandomRule" class="headerlink" title="RandomRule"></a><strong>RandomRule</strong></h3><p>看名字就知道，这种负载均衡策略就是随机选择一个服务实例，看源码我们知道，在RandomRule的无参构造方法中初始化了一个Random对象，然后在它重写的choose方法又调用了choose(ILoadBalancer lb, Object key)这个重载的choose方法，在这个重载的choose方法中，每次利用random对象生成一个不大于服务实例总数的随机数，并将该数作为下标所以获取一个服务实例。</p><h3 id="RoundRobinRule"><a href="#RoundRobinRule" class="headerlink" title="RoundRobinRule"></a><strong>RoundRobinRule</strong></h3><p>RoundRobinRule这种负载均衡策略叫做轮询负载均衡策略，也就是我们在上文所说的BaseLoadBalancer负载均衡器中默认采用的负载均衡策略。这个类的choose(ILoadBalancer lb, Object key)函数整体逻辑是这样的：开启一个计数器count，在while循环中遍历服务清单，获取清单之前先通过incrementAndGetModulo方法获取一个下标，这个下标是一个不断自增长的数先加1然后和服务清单总数取模之后获取到的（所以这个下标从来不会越界），拿着下标再去服务清单列表中取服务，每次循环计数器都会加1，如果连续10次都没有取到服务，则会报一个警告No available alive servers after 10 tries from load balancer: XXXX。</p><h3 id="RetryRule"><a href="#RetryRule" class="headerlink" title="RetryRule"></a><strong>RetryRule</strong></h3><p>看名字就知道这种负载均衡策略带有重试功能。首先RetryRule中又定义了一个subRule，它的实现类是RoundRobinRule，然后在RetryRule的choose(ILoadBalancer lb, Object key)方法中，每次还是采用RoundRobinRule中的choose规则来选择一个服务实例，如果选到的实例正常就返回，如果选择的服务实例为null或者已经失效，则在失效时间deadline之前不断的进行重试（重试时获取服务的策略还是RoundRobinRule中定义的策略），如果超过了deadline还是没取到则会返回一个null。</p><h3 id="WeightedResponseTimeRule"><a href="#WeightedResponseTimeRule" class="headerlink" title="WeightedResponseTimeRule"></a><strong>WeightedResponseTimeRule</strong></h3><p>WeightedResponseTimeRule是RoundRobinRule的一个子类，在WeightedResponseTimeRule中对RoundRobinRule的功能进行了扩展，WeightedResponseTimeRule中会根据每一个实例的运行情况来给计算出该实例的一个权重，然后在挑选实例的时候则根据权重进行挑选，这样能够实现更优的实例调用。WeightedResponseTimeRule中有一个名叫DynamicServerWeightTask的定时任务，默认情况下每隔30秒会计算一次各个服务实例的权重，权重的计算规则也很简单，如果一个服务的平均响应时间越短则权重越大，那么该服务实例被选中执行任务的概率也就越大。</p><h3 id="ClientConfigEnabledRoundRobinRule"><a href="#ClientConfigEnabledRoundRobinRule" class="headerlink" title="ClientConfigEnabledRoundRobinRule"></a><strong>ClientConfigEnabledRoundRobinRule</strong></h3><p>ClientConfigEnabledRoundRobinRule选择策略的实现很简单，内部定义了RoundRobinRule，choose方法还是采用了RoundRobinRule的choose方法，所以它的选择策略和RoundRobinRule的选择策略一致，不赘述。</p><h3 id="BestAvailableRule"><a href="#BestAvailableRule" class="headerlink" title="BestAvailableRule"></a><strong>BestAvailableRule</strong></h3><p>BestAvailableRule继承自ClientConfigEnabledRoundRobinRule，它在ClientConfigEnabledRoundRobinRule的基础上主要增加了根据loadBalancerStats中保存的服务实例的状态信息来过滤掉失效的服务实例的功能，然后顺便找出并发请求最小的服务实例来使用。然而loadBalancerStats有可能为null，如果loadBalancerStats为null，则BestAvailableRule将采用它的父类即ClientConfigEnabledRoundRobinRule的服务选取策略（线性轮询）。</p><h3 id="PredicateBasedRule"><a href="#PredicateBasedRule" class="headerlink" title="PredicateBasedRule"></a><strong>PredicateBasedRule</strong></h3><p>PredicateBasedRule是ClientConfigEnabledRoundRobinRule的一个子类，它先通过内部定义的一个过滤器过滤出一部分服务实例清单，然后再采用线性轮询的方式从过滤出来的结果中选取一个服务实例。</p><h3 id="ZoneAvoidanceRule-Finchley-SR1版本中默认均衡策略"><a href="#ZoneAvoidanceRule-Finchley-SR1版本中默认均衡策略" class="headerlink" title="ZoneAvoidanceRule(Finchley.SR1版本中默认均衡策略)"></a><strong>ZoneAvoidanceRule(Finchley.SR1版本中默认均衡策略)</strong></h3><p>ZoneAvoidanceRule是PredicateBasedRule的一个实现类，只不过这里多一个过滤条件，<strong>ZoneAvoidanceRule中的过滤条件是以ZoneAvoidancePredicate为主过滤条件和以AvailabilityPredicate为次过滤条件组成的一个叫做CompositePredicate的组合过滤条件，过滤成功之后，继续采用线性轮询的方式从过滤结果中选择一个出来</strong>。</p><h3 id="AvailabilityFilteringRule"><a href="#AvailabilityFilteringRule" class="headerlink" title="AvailabilityFilteringRule"></a>AvailabilityFilteringRule</h3><p>过滤掉那些一直连接失败的且被标记为 circuit tripped 的后端 Server，并过滤掉那些高并发的后端 Server 或者使用一个 AvailabilityPredicate 来包含过滤 Server 的逻辑。其实就是检查 Status 里记录的各个 Server 的运行状态。</p><h2 id="开发者路由"><a href="#开发者路由" class="headerlink" title="开发者路由"></a>开发者路由</h2><p>实际上开发者路由就是自定义的一个均衡策略，先看看如何使用：</p><p>首先在项目启动的过程中，添加一个参数：</p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/2.png"></p><p>并且需要在系统中创建一个22410_的用户，在用这个用户操作的过程中，在系统中所有通向这类服务的接口都会优先走开发者启动的这个服务，方便与开发这开发与调试。</p><p>我们可以在eureka上查看实例的状态</p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/3.png"></p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/4.png"></p><p>接下来看看如何实现的。</p><p>首先自定义了<strong>CustomMetadataRule</strong>，他是继承了zoneAvoidanceRule，这个的用处待会再说，再由DeveloperRule去继承CustomMetadataRule类，<strong>DeveloperRule</strong>则是使用的开发者路由的负载均衡策略。</p><p>通过spring.factory注入这个自定义的IRule</p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/5.png"></p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/6.png"></p><p>核心代码：</p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/7.png"></p><p><strong>主要流程就是通过</strong>ZoneAvoidanceRule的<strong>compositePredicate的默认规则来获取可达的服务，然后在这些服务中根据元数据来找和用户匹配的服务，之后随机挑选一个服务返回。</strong></p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>如果没有开发者服务注册，然后使用开发者的用户请求接口，会发生什么呢？比如A、B两用户，A用户没有注册自己的开发者用户，B用户注册了，现在使用A用户的账号来访问的话，该怎么办呢？</p><p>首先一个理想的状态是，最好是走线上的服务，如果走到了B用户的服务上去，其实是非常不合理的，也就是<strong>如果没有自己的开发者服务，就使用线上的服务。</strong>实际上开发者路由也是这么实现的，具体代码<strong>：</strong></p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/8.png"></p><p>首先自定义了一个AbstractServerPredicate的filter，这个filter可以帮助我们过滤一些服务，true保留，false过滤，可以看到，元数据中带有”developer”的服务会被过滤掉，</p><p>这个过滤器还会被构造成一个CompositePredicate对象，作为一个组合条件来过滤服务，所以如果没有找到对应的开发者路由服务，会执行这个过滤</p><p><img src="/2021/12/19/hzero%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%94%B1/9.png"></p><p>将过滤之后的服务再进行轮询。</p><p>如果还是没有可用的服务呢？比如说线上的服务挂掉了，现在注册中心只有一些开发者的服务，当前登录系统的用户也不在这些开发者中。</p><p><strong>为了应对这种情况出现，从代码可以看出，</strong></p><p><code>return optional.isPresent() ? (Server)optional.get() : super.choose(key); </code>在这个情况下，会去执行父类的choose方法，就是开头提到的<strong>CustomMetadataRule类的choose(),此时估计就是按照权重来选取服务了</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> hzero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hzero 网关鉴权</title>
      <link href="2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/"/>
      <url>2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>官方文档：</p><p><a href="https://open.hand-china.com/document-center/doc/component/159/16194?doc_id=30958996068&_back=/document-center/search?s=%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1&doc_code=40392">https://open.hand-china.com/document-center/doc/component/159/16194?doc_id=30958996068&amp;_back=%2Fdocument-center%2Fsearch%3Fs%3D%25E5%258A%25A8%25E6%2580%2581%25E8%25B7%25AF%25E7%2594%25B1&amp;doc_code=40392</a></p><h2 id="调用基本链路"><a href="#调用基本链路" class="headerlink" title="调用基本链路"></a>调用基本链路</h2><p>hzero基础服务调用链路：</p><p><a href="https://open.hand-china.com/hzero-docs/v1.3/zh/docs/installation-configuration/service-config/service-chain/">https://open.hand-china.com/hzero-docs/v1.3/zh/docs/installation-configuration/service-config/service-chain/</a></p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/hzero-chain.jpeg" alt="调用链路"></p><p>① API调用</p><p>所有API调用都是进入网关，通过网关路由到正确的服务上。对外暴露端口时，只需暴露网关服务的端口即可。</p><p>② API鉴权</p><p>在网关服务内，所有API请求都会经过 GateWayHelperFilter 过滤器，在过滤器中，会调用 hzero-gateway-helper 鉴权组件对API及用户鉴权。</p><p>根过滤器 HelperChain 包含了一系列过滤器来对请求进行鉴权，将按图中的顺序进行校验。认证通过或不通过都会返回相应的状态码，红色部分表示认证失败，绿色部分表示认证通过，具体状态码的含义可参考最后 鉴权常见状态码。</p><p>一般服务出现 403、500 等问题时，可先查看返回错误码，或检查 hzero-gateway-helper 的日志，看是哪一步校验不通过，对症下药。</p><p>③ 获取登录用户</p><p><strong>GetUserDetailsFilter</strong> <strong>会带着</strong> <strong>access_token</strong> <strong>访问 hzero-oauth 认证服务的</strong> <strong>/api/user</strong> <strong>接口获取用户信息。</strong></p><p>④ 返回用户 Principal</p><p>用户登录后，oauth 服务将 access_token 和用户认证实体（Authentication）关系存储在 redis session 中，在调用 /api/user 时，将通过 access_token 获取 Authentication，并在接口中返回用户信息 Principal。</p><p>得到 Principal 后，转换成 CustomUserDetails。之后，在AddJwtFilter里将 UserDetails 转成 JwtToken。</p><p>⑤ 返回状态码及JwtToken</p><p>如果认证失败，将返回状态码，并在网关直接返回前端，不会再调用业务服务。</p><p>如果API要求用户登录，将返回用户的 JwtToken 信息</p><p>⑥ 路由到业务服务</p><p>鉴权通过后，网关将带着 JwtToken，根据路由信息，转发到对应的业务服务上。</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%819.png"></p><p>在业务服务内部，首先 JwtTokenFilter 会将 JwtToken 转换成 UserDetails，并设置到 SecurityContextHolder 上下文中，相当于用户在此服务中已登录。之后的程序中就可以通过 DetailsHelper.getUserDetails() 得到当前登录用户信息。</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8110.png"></p><p>若要开启此过滤器，需在启动类上配置 @EnableChoerodonResourceServer 注解开启此功能。</p><p>⑦ 返回数据</p><p>之后返回数据，经过网关，再返回到前端。如果服务响应比较慢，就需要调整网关的超时时间。</p><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p>如果想要在本地运行认证环境，需要启动四个服务hzero-register、hzero-gateway、hzero-admin、hzero-ouath</p><p>最主要的是GateWayHelperFilter这个类，继承了org.springframework.web.server.WebFilter,并且在里面自定义了鉴权组件</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%811.png"></p><p>自定义顶级认证接口</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%812.png"></p><p>实现类，通过过滤链来执行认证过程</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%813.png"></p><p>调用了HelperChain的doFilter方法</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%814.png"></p><p>也就是把所有HelperFilter的实现Bean全都拿过来放到一个List中执行，达到一个过滤连的执行效果。当filter.run 返回false的时候，过滤链结束，并将responseContext返回出去</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%815.png"></p><p>看一下HleperFilter接口，这个接口是下面认证filter的顶级接口，定义了认证的行为，下面会对每一个filter进行分析。</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%816.png"></p><p>还有两个类需要注意下，RequestContex和ResponseContext。</p><p>RequestContext  作为过滤链执行过程中的上下文，可以在里面设置各种参数</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%817.png"></p><p>ResponseContext 过滤链执行的返回结果</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%818.png"></p><h3 id="PermissionDisableOrSkipFilter"><a href="#PermissionDisableOrSkipFilter" class="headerlink" title="PermissionDisableOrSkipFilter"></a>PermissionDisableOrSkipFilter</h3><p>先看一个简单的HelperFilter：主要是用来跳过一些url的鉴权，对于一些url，并不需要进行权限的限制</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8111.png"></p><p>在代码中也可以看到一些默认的内部uri和可以跳过鉴权的uri，</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8112.png"></p><p>也可以配置文件中去配置这些路径</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8113.png"></p><h3 id="GetPermissionFilter"><a href="#GetPermissionFilter" class="headerlink" title="GetPermissionFilter"></a>GetPermissionFilter</h3><p>代码中所有controller中的大部分接口会落库，才能被hzero访问，会被封装成一个Permission对象</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8114.png"></p><p>这个Filter 可能会抛出一个最常见的错误 PERMISSION_MISMATCH 接口403，也就是</p><p><code>PermissionDO permission = this.permissionService.selectPermissionByRequest(key);</code></p><p>查询出来为空，则会403，详细看一下这个方法：</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8115.png"></p><p>有一个参数requestKey，根据代码可以推测出这个requestKey的组成：uri:::method:::serviceName，会使用 serviceName和method去查询permission，把查询出来的permission根据uri过滤、匹配等等，找到最优匹配的permission，如果没有找到，则返回null。</p><p>那么可以再看看这个selectPermissions：</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8116.png"></p><p>查询sql：</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8117.png"></p><p>redis里面的数据结构，可以看到将  gateway:permissions:服务名:method 作为hash键，接口作为hash值，值示例</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8118.png"></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"id"</span><span class="token operator">:</span><span class="token number">67272</span><span class="token punctuation">,</span> <span class="token property">"code"</span><span class="token operator">:</span><span class="token string">"hszl-archives.archives-outbound.create"</span><span class="token punctuation">,</span> <span class="token property">"path"</span><span class="token operator">:</span><span class="token string">"/v1/&#123;organizationId&#125;/archives-outbounds"</span><span class="token punctuation">,</span> <span class="token property">"method"</span><span class="token operator">:</span><span class="token string">"post"</span><span class="token punctuation">,</span> <span class="token property">"publicAccess"</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token property">"loginAccess"</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token property">"signAccess"</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token property">"within"</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token property">"fdLevel"</span><span class="token operator">:</span><span class="token string">"organization"</span><span class="token punctuation">,</span> <span class="token property">"tag"</span><span class="token operator">:</span><span class="token null keyword">null</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>所以，以后遇到接口403问题，找问题的话就可以先到redis去看，然后再去数据库找，是否存在这样的接口，一般都是接口不存在或者没有刷新到表里面导致的403。</strong></p><h3 id="GetUserDetailsFilter"><a href="#GetUserDetailsFilter" class="headerlink" title="GetUserDetailsFilter"></a>GetUserDetailsFilter</h3><p>获取用户信息的过滤器。主要的任务就是：<strong>GetUserDetailsFilter</strong> <strong>会带着</strong> <strong>access_token</strong> <strong>访问 hzero-oauth 认证服务的</strong> <strong>/api/user</strong> <strong>接口获取用户信息。</strong></p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8119.png"></p><p>返回的结果中包含了hzero用户的信息</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8120.png"></p><p>带着token请求oauth服务</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8121.png"></p><p>在oauth服务中通过ouath2进行验证，<strong>OAuth2AuthenticationProcessingFilter</strong></p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8122.png"></p><p>oauth2会根据携带的token去查询用户信息,并将返回结果存储到当前的SecurityContextHolder中，</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8122.png"></p><p>hzero中认证服务中的tokenService的实现类为DefaultTokenServices，接口ResourceServerTokenServices：</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8124.png"></p><p>会通过TokenStore的redisTokenStore实现类来从redis获取用户认证信息</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8125.png"></p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8126.png"></p><p>最后的结果会存储到Authentication中的Principal，然后通过controller返回给网关</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8127.png"></p><h3 id="AddJwtFilter"><a href="#AddJwtFilter" class="headerlink" title="AddJwtFilter"></a>AddJwtFilter</h3><p>网关在得到 Principal 后，转换成 CustomUserDetails，之后，在这里将 UserDetails 转成 JwtToken。并设置到response中</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8128.png"></p><h3 id="LoginAccessRequestFilter"><a href="#LoginAccessRequestFilter" class="headerlink" title="LoginAccessRequestFilter"></a>LoginAccessRequestFilter</h3><p>访问的接口是否是登录才可访问接口</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8129.png"></p><h3 id="AdminUserPermissionFilter"><a href="#AdminUserPermissionFilter" class="headerlink" title="AdminUserPermissionFilter"></a>AdminUserPermissionFilter</h3><p>如果是admin用户，那么就返回false，不要往下再去执行过滤链了。</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8130.png"></p><h3 id="CommonRequestCheckFilter"><a href="#CommonRequestCheckFilter" class="headerlink" title="CommonRequestCheckFilter"></a>CommonRequestCheckFilter</h3><p>在系统中，会把接口分配给菜单，把菜单分配给用户，然后该用户就拥有了这个菜单下的所有接口权限</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8131.png"></p><p>最主要的就是这边，根据接口的权限code去查询 ，该接口权限是否在该用户的已分配菜单下，如果不是的话，就返回pemission_not_pass，也就是权限未通过。</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8132.png"></p><p>下面就是校验租户层级的权限</p><p><img src="/2021/12/03/hzero%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/%E4%BB%A3%E7%A0%8133.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hzero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hzero 服务注册</title>
      <link href="2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
      <url>2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>这里并不是指服务注册到注册中心，而是注册为hzero所能管理、使用的服务。</p><p>首先是hzero的admin服务启动时会拉取服务信息。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>org.hzero.admin.app.service.impl.RestServiceInitRegistry 实现了ServiceInitRegistry接口。</p><p>提供注册的接口</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%811.png" alt="代码1"></p><p>基本逻辑：</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%812.png" alt="代码2"></p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%813.png" alt="代码3"></p><p>注册的时候将该服务的信息写入到redis中</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%814.png" alt="代码4"></p><p>redis存储的信息</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"serviceName"</span><span class="token operator">:</span><span class="token string">"hszl-fin-all"</span><span class="token punctuation">,</span>    <span class="token property">"version"</span><span class="token operator">:</span><span class="token string">"1.3.5.RELEASE"</span><span class="token punctuation">,</span>    <span class="token property">"healthUrl"</span><span class="token operator">:</span><span class="token string">"http://10.221.4.98:6081/actuator/health"</span><span class="token punctuation">,</span>    <span class="token property">"metadata"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"VERSION"</span><span class="token operator">:</span><span class="token string">"1.3.5.RELEASE"</span><span class="token punctuation">,</span>        <span class="token property">"management.port"</span><span class="token operator">:</span><span class="token string">"6081"</span><span class="token punctuation">,</span>        <span class="token property">"developer"</span><span class="token operator">:</span><span class="token string">"lwy32954"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"initialized"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化服务"><a href="#初始化服务" class="headerlink" title="初始化服务"></a>初始化服务</h3><p>看一下admin服务初始化时到底做了些什么。</p><p>RestServiceInitRegistry中的start调用了doStart方法：</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%815.png" alt="代码5"></p><p><strong>可以看到，启动的时候会开启一个单线程的线程池，该线程会先初始化所有未初始化的服务，之后只要该线程没有被中断，那么该线程就会循环的去初始化为初始化的服务（如果存在的话）。</strong></p><p>获取未初始化服务：因为业务服务启动时会将自己的信息通过admin服务注册到redis中，但是这个时候还是没有初始化的，所以initialized的属性为false。</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%816.png" alt="代码6"></p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%817.png" alt="代码7"></p><p>然后初始化，主要两步，初始化服务，更新初始化状态字段，然后将初始化状态回写到redis中，</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%818.png" alt="代码8"></p><p>第二步，执行初始化链，里面有这执行初始化的filter，主要有3个任务：admin服务刷新路由，通知iam服务刷新权限，swagger服务刷新文档</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%819.png" alt="代码9"></p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8110.png" alt="代码10"></p><p>构造出一个默认的初始化链</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8111.png" alt="代码11"></p><p>然后依次执行每一个初始化的filter</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8112.png" alt="代码12"></p><p>就是将初始化拦截器链排序然后执行doFilter方法。比如解析并刷新路由（ParseRouteServiceImpl）、获取并刷新接口权限（PermissionRefreshService）</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端如何到hzero-register中去注册自己？</p><p>业务服务中的类<strong>AdminAutoRegistration</strong>，也是实现了SmartLifecycle接口</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8113.png" alt="代码13"></p><p>并且通过@EventListener进行了事件监听，在web容器初始化完成之后，开始注册自己</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8114.png" alt="代码14"></p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8115.png" alt="代码15"></p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8116.png" alt="代码16"></p><p><strong>一直向admin请求注册，如果注册不成功就开启一个线程不断重试。</strong></p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8117.png" alt="代码17"></p><p>admin提供的注册接口</p><p><img src="/2021/11/25/hzero%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/%E4%BB%A3%E7%A0%8118.png" alt="代码18"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hzero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hzero 基础服务</title>
      <link href="2021/11/20/hzero%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/"/>
      <url>2021/11/20/hzero%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="注册中心（hzero-register）"><a href="#注册中心（hzero-register）" class="headerlink" title="注册中心（hzero-register）"></a>注册中心（hzero-register）</h2><p><a href="https://open.hand-china.com/hzero-docs/v1.3/zh/docs/service/register/">https://open.hand-china.com/hzero-docs/v1.3/zh/docs/service/register/</a></p><p>基于Eureka的平台注册中心服务</p><p>功能：</p><ul><li>服务注册发现</li><li>服务健康检查</li><li>服务监控</li><li>注册中心其他功能</li></ul><h2 id="平台治理-hzero-admin"><a href="#平台治理-hzero-admin" class="headerlink" title="平台治理(hzero-admin)"></a>平台治理(hzero-admin)</h2><p><a href="https://open.hand-china.com/hzero-docs/v1.3/zh/docs/service/admin/">https://open.hand-china.com/hzero-docs/v1.3/zh/docs/service/admin/</a></p><p>管理服务，基础服务之一，把路由、限流、熔断等功能易用化，集中在管理服务来管控，提供自动化的路由刷新、权限刷新、swagger信息刷新服务，提供界面化的服务、配置、路由、限流、熔断管理功能以及Spring Boot Admin控制台。</p><p>功能：</p><ul><li>服务管理</li><li>配置管理</li><li>路由管理</li><li>限流规则管理</li><li>熔断规则管理</li><li>服务监控管理</li></ul><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>功能说明：</p><ul><li>创建服务</li><li>删除服务</li><li>修改服务</li><li>查询服务</li></ul><p>需要注意的是，服务对应的服务名和服务编码应该保持一致，且与微服务的spring.application.name保持一致。</p><p>一般情况下，<strong>一个新服务hzero-demo按hzero规范注册到注册中心后，hzero-admin服务会监听到该hzero-demo服务的注册，并自动为其创建服务、路由，最后将路由信息应用到网关并为其api生成权限信息及swagger信息，此时该服务自动成为hzero体系中的一个可访问服务</strong>。</p><p>如果hzero-admin服务未开启自动刷新功能，则需要手动维护路由信息、权限信息及swagger信息，而手动维护路由信息需要先手动创建服务并关联该服务创建路由。</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>功能说明：</p><ul><li>创建配置</li><li>删除配置</li><li>更新配置</li><li>查询配置</li><li>刷新配置</li></ul><p>通过服务名和服务版本定位到实例，表示配置与服务的绑定关系，如果不指定服务版本，则表示该配置会应用到该服务的所有实例。</p><p>在创建配置、删除配置、更新配置时均会触发刷新配置，将配置信息应用到绑定服务上。</p><p>ps. 刷新配置过程有可能由于网络原因失败，所以需要再次手动刷新配置。</p><h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><p>界面定位：Hzero菜单-&gt;服务治理-&gt;路由管理</p><p>功能说明：</p><ul><li>创建路由</li><li>删除路由</li><li>更新路由</li><li>查询路由</li><li>刷新路由</li></ul><p>在创建路由、删除路由、更新路由时均会触发刷新路由，将路由信息应用到网关服务上。</p><p>ps. 刷新路由过程有可能由于网络原因失败，所以需要再次手动刷新路由。</p><h3 id="监听服务注册并刷新路由、权限、swagger信息"><a href="#监听服务注册并刷新路由、权限、swagger信息" class="headerlink" title="监听服务注册并刷新路由、权限、swagger信息"></a>监听服务注册并刷新路由、权限、swagger信息</h3><p>此功能分解为三个：监听服务注册并刷新路由（添加网关到服务到映射关系）、监听服务注册并刷新权限（允许请求到服务到鉴权通过）、 监听服务注册并刷新swagger信息（允许查看api信息和模拟调用）</p><ol><li><p><strong>监听服务注册并刷新路由</strong>:服务注册后，hzero-admin服务会监听到服务注册事件并从该服务拉取路由信息， 如果路由信息符合规范且与现有路由不冲突，则为其创建路由并应用到网关，使之可以通过网关访问。</p><p>Note: 路由信息是由hzero-admin服务管理的，拉取、解析路由信息以及通知网关的工作均由hzero-admin服务完成； 另外，可能在网络抖动等原因出现刷新失败或网关未应用路由的情况，这时需要手动调用路由刷新接口（POST /v1/refresh/route）。</p></li><li><p><strong>监听服务注册并刷新权限</strong>:服务注册后，hzero-admin服务会监听到服务注册事件并<strong>通知hzero-iam服务</strong>从该服务拉取权限信息， 解析后存储到数据库和redis，存储到redis后，网关可获取到相应到权限信息。</p><p>Note: 监听和通知的工作由hzero-admin完成，真正的权限刷新（拉取、解析、保存权限信息及刷新到缓存）工作由hzero-iam完成； 另外，可能在网络抖动等原因出现刷新失败或缓存不一致的情况，这时需要手动调用权限刷新接口（POST /v1/refresh/permission）。</p></li><li><p><strong>监听服务注册并刷新swagger信息</strong>：服务注册后，hzero-admin服务会监听到服务注册事件并<strong>通知hzero-swagger服务</strong>从该服务拉取swagger信息， 存储到数据库，存储到数据库后，hzero-swagger可获取到相应的swagger信息。</p><p>Note: 监听和通知的工作由hzero-admin完成，真正的权限刷新（拉取、解析、保存swagger信息）工作由hzero-swagger完成； 另外，可能在网络抖动等原因出现刷新失败或api不一致的情况，这时需要手动调用swagger刷新接口（POST /v1/refresh/swagger）。</p></li></ol><h2 id="网关服务（hzero-gateway）"><a href="#网关服务（hzero-gateway）" class="headerlink" title="网关服务（hzero-gateway）"></a>网关服务（hzero-gateway）</h2><p>基于Spring Cloud Gateway的微服务网关服务</p><p>功能：</p><ul><li>用户鉴权</li><li>限流</li><li>整体运维</li><li>动态路由</li></ul><h3 id="启动类配置"><a href="#启动类配置" class="headerlink" title="启动类配置"></a>启动类配置</h3><p>需要注意的是，在编写引导类时需要指定web环境为REACTIVE类型，由于Spring Cloud Gateway基于webflux包开发，其web容器是REACTIVE类型，而hzero-starter-core包中依赖了web包，如果不指定web容器将会默认走webmvc而冲突。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableHZeroGateway</span><span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GatewayApplication</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">new</span> <span class="token class-name">SpringApplicationBuilder</span><span class="token punctuation">(</span><span class="token class-name">GatewayApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">web</span><span class="token punctuation">(</span><span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span>REACTIVE<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="GatewayHelper"><a href="#GatewayHelper" class="headerlink" title="GatewayHelper"></a>GatewayHelper</h3><ul><li>hzero 提供了 hzero-gateway-helper-api 鉴权接口包 和 hzero-gateway-helper-default 默认实现。</li><li>如果需要对鉴权逻辑进行整体改造，可以通过实现 org.hzero.gateway.helper.api.AuthenticationHelper 接口来完全定制化鉴权的部分。</li><li>如果仅需要对现有鉴权逻辑新增逻辑，可以通过实现 org.hzero.gateway.helper.api.HelperFilter 接口来新增鉴权逻辑。</li></ul><h2 id="OAuth-认证服务"><a href="#OAuth-认证服务" class="headerlink" title="OAuth 认证服务"></a>OAuth 认证服务</h2><p>hzero-oauth 服务是基于 Spring Security、Spring OAuth2、JWT 实现的统一认证服务中心，登录基于 spring security 的标准登录流程，客户端授权支持 oauth2.0 的四种授权模式：<strong>授权码模式</strong>、<strong>简化模式</strong>、<strong>密码模式</strong>、<strong>客户端模式</strong>，授权流程跟标准的 oauth2 流程一致。web 端采用简化模式(implicit)登录系统，移动端可使用密码模式(password)登录系统 。并支持基于 Spring Social 的三方账号登录方式(如微信)。</p><p>功能：</p><ul><li>统一登录界面</li><li>账户、手机、邮箱登录</li><li>短信登录</li><li>第三方登录功能</li><li>可客制化登录模板</li></ul><p><img src="/2021/11/20/hzero%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/D2C2E054-B051-44A1-BE28-FD8B4332A3D7.png"></p><h2 id="IAM服务-hzero-iam"><a href="#IAM服务-hzero-iam" class="headerlink" title="IAM服务(hzero-iam)"></a>IAM服务(hzero-iam)</h2><p>权限管理服务，平台统一的权限体系架构</p><ul><li>功能：</li><li>角色管理</li><li>菜单管理</li><li>帐户管理</li><li>用户组管理</li><li>租户管理</li><li>权限刷新</li><li>单据权限管理</li></ul><h3 id="接口权限自动刷新机制"><a href="#接口权限自动刷新机制" class="headerlink" title="接口权限自动刷新机制"></a>接口权限自动刷新机制</h3><p>IAM 服务保存了接口权限信息，一般情况下，（按照HZERO规范生成的）新服务注册到注册中心后， 系统会自动从该服务拉取该服务接口权限信息，并通过IAM权限刷新接口保存到数据库和缓存中， 这时新服务的api在网关的鉴权（网关从redis中获取权限信息）才能通过。</p><p>这里HZERO为用户做了三件事：</p><p><strong>1.自动监听服务注册事件，并从新服务拉取接口权限信息（该工作由hzero-admin服务完成）</strong></p><p><strong>2.hzero-admin服务通过远程调用通知hzero-iam服务完成权限刷新工作</strong></p><p><strong>3.hzero-iam从新服务拉取权限接口信息，并保存到数据库和缓存</strong></p><p>所以如果出现这样到情况，新服务注册后，接口权限没有刷新到IAM，导致网关鉴权失败，报错permission mismatch。 则原因可能是：</p><ul><li>hzero-admin服务不可用，无法监听到服务注册事件</li><li>hzero-iam服务不可用或hzero-admin与hzero-iam网络不通或网络抖动，hzero-admin远程调用hzero-iam失败</li><li>新服务不符合HZERO规范</li></ul><p>在hzero-admin、hzero-iam均可用，且网络可达的情况下，依然有很小的概率由于网络抖动原因而调用失败， 这时需要手动调用hzero-iam服务的权限刷新接口或hzero-admin服务的权限刷新接口。</p><p>ps.推荐使用hzero-admin服务的接口（路由刷新、swagger刷新等管理功能集中在hzero-admin服务，便于操作）</p><h2 id="平台基础服务-hzero-platform"><a href="#平台基础服务-hzero-platform" class="headerlink" title="平台基础服务(hzero-platform)"></a>平台基础服务(hzero-platform)</h2><p>平台功能基础服务，主要涵盖平台开发支持功能、平台主数据模块、系统管理模块等</p><p>功能：</p><ul><li><p>系统配置</p></li><li><p>值列表维护、值列表视图</p></li><li><p>多语言描述维护</p></li><li><p>编码规则管理</p></li><li><p>配置管理</p></li><li><p>规则引擎</p></li><li><p>数据源、数据库管理</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hzero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="2021/11/14/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>2021/11/14/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>快速运算底数的n次幂。其时间复杂度为O(log2N)，与朴素的O(N)相比效率有了极大的提高。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>每一步都把指数分成两半，而对应的底数做平方运算，这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而且最后表示的结果却一直不会变。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>求A^B的最后三位表示的整数。</p></blockquote><p><strong>求最后的几位整数，我们做取模运算就可以了，比如最后三位，我们可以把该数字和1000取模，最后一位，可以和10取模</strong></p><p>如果这题，我们使用简单for循环把结果算出来然后和1000取模的话，不做特殊处理的话，要么时间复杂度很高，要么就是得不到正确结果，比如返回0.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">normalPow1</span><span class="token punctuation">(</span><span class="token keyword">long</span> base<span class="token punctuation">,</span> <span class="token keyword">long</span> power<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> power<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        result <span class="token operator">=</span> result <span class="token operator">*</span> base<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回结果：</p><p><img src="http://www.qxnekoo.cn:8888/images/2022/01/05/image.png" alt="image.png"></p><p>根据取模运算的方程：__**(a * b) % p = (a % p * b % p) % p **__</p><p>我们可以对代码进行优化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">normalPow2</span><span class="token punctuation">(</span><span class="token keyword">long</span> base<span class="token punctuation">,</span> <span class="token keyword">long</span> power<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> power<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        result <span class="token operator">=</span> result <span class="token operator">*</span> base<span class="token punctuation">;</span>        result <span class="token operator">=</span> result <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://www.qxnekoo.cn:8888/images/2022/01/05/image-1.png" alt="image-1.png"></p><p>虽然最后计算出了结果，<strong>但是时间复杂度的话，很明显就是O(N)。</strong></p><p>快速幂的应用场景就有了。</p><blockquote><p>3^10=3<em>3</em>3<em>3</em>3<em>3</em>3<em>3</em>3*3</p><p>//尽量想办法把指数变小来，这里的指数为10</p><p>3^10=(3<em>3)</em>(3<em>3)</em>(3<em>3)</em>(3<em>3)</em>(3<em>3)</em></p><p><em>3^10=(3</em>3)^5</p><p>3^10=9^5</p><p>//此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10原本需要执行10次循环操作，求9^5却只需要执行5次循环操作，但是3^10却等于9^5,我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000=4^5000,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。</p><p>//现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5</p><p>9^5=（9^4）*（9^1）</p><p>//此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作</p><p>9^5=（81^2）*(9^1)</p><p>//把指数缩小一半，底数执行平方操作</p><p>9^5=（6561^1）*(9^1)*</p><p><em>9^5=（6561^0）</em>(9^1)<em>(6561^1)=1</em>(9^1)<em>(6561^1)=(9^1)</em>(6561^1)=9*6561=59049</p></blockquote><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">normalPow3</span><span class="token punctuation">(</span><span class="token keyword">long</span> base<span class="token punctuation">,</span> <span class="token keyword">long</span> power<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>power <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>power <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//如果指数为偶数</span>                <span class="token comment">//把指数缩小为一半</span>                power <span class="token operator">=</span> power <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token comment">//底数变大成原来的平方</span>                base <span class="token operator">=</span> base <span class="token operator">*</span> base <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//如果指数为奇数</span>                <span class="token comment">//把指数减去1，使其变成一个偶数</span>                power <span class="token operator">=</span> power <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">//此时记得要把指数为奇数时分离出来的底数的一次方收集好</span>                result <span class="token operator">=</span> result <span class="token operator">*</span> base <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span>                <span class="token comment">//此时指数为偶数，可以继续执行操作</span>                power <span class="token operator">=</span> power <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                base <span class="token operator">=</span> base <span class="token operator">*</span> base <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://www.qxnekoo.cn:8888/images/2022/01/05/image-2.png" alt="image-2.png"></p><p>代码可以接着进行优化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">normalPow4</span><span class="token punctuation">(</span><span class="token keyword">long</span> base<span class="token punctuation">,</span> <span class="token keyword">long</span> power<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>power <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>power <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            result <span class="token operator">=</span> result <span class="token operator">*</span> base <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        power <span class="token operator">=</span> power <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        base <span class="token operator">=</span> base <span class="token operator">*</span> base <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Import注解</title>
      <link href="2021/10/09/@Import/"/>
      <url>2021/10/09/@Import/</url>
      
        <content type="html"><![CDATA[<p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/147025312"><strong>https://zhuanlan.zhihu.com/p/147025312</strong></a></p><p><code>@Import</code>是<code>Spring</code>基于 Java 注解配置的主要组成部分。<code>@Import</code>注解提供了<code>@Bean</code>注解的功能，同时还有原来<code>Spring</code>基于 xml 配置文件里的<code>&lt;import&gt;</code>标签组织多个分散的xml文件的功能，当然在这里是组织多个分散的<code>@Configuration</code>的类。他只作用于类上。</p><h2 id="三种方式引入"><a href="#三种方式引入" class="headerlink" title="三种方式引入"></a>三种方式引入</h2><h3 id="直接引入"><a href="#直接引入" class="headerlink" title="直接引入"></a>直接引入</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">ConfigB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">class</span> <span class="token class-name">ConfigA</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token keyword">public</span> <span class="token class-name">ServiceInterface</span> <span class="token function">getServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式的优先于本身的类定义加载。</p><h3 id="指定实现ImportSelector-以及DefferredServiceImportSelector-的类，用于个性化加载。"><a href="#指定实现ImportSelector-以及DefferredServiceImportSelector-的类，用于个性化加载。" class="headerlink" title="指定实现ImportSelector(以及DefferredServiceImportSelector)的类，用于个性化加载。"></a>指定实现<code>ImportSelector</code>(以及<code>DefferredServiceImportSelector</code>)的类，用于个性化加载。</h3><p>指定实现<code>ImportSelector</code>的类，通过<code>AnnotationMetadata</code>里面的属性，动态加载类。<code>AnnotationMetadata</code>是<code>Import</code>注解所在的类属性（<strong>如果所在类是注解类，则延伸至应用这个注解类的非注解类为止</strong>）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"com.example.simpleboot.anno.ConfigB"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//这里直接指定ImportSelector的接口实现类，是具体的Bean类的全限定名称</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">ServiceImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">class</span> <span class="token class-name">ConfigA</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token keyword">public</span> <span class="token class-name">ServiceInterface</span> <span class="token function">getServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ConfigA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ServiceInterface</span> bean <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">ServiceInterface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bean<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式也是优先于本身的类定义加载，一般的，如果框架中给予 AnnotationMetadata的参数实现动态加载类，一般会写一个额外的 Enable 注解配合使用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">ServiceImportSelector2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableService</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceImportSelector2</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//这里的importingClassMetadata指的就是被Import修饰的类属性，如果所在类是注解类，则延伸至应用这个注解类的非注解类为止</span>        <span class="token comment">//也就是将EnableService注解上的属性全部拿到 放到这个Map中</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> annotationAttributes <span class="token operator">=</span> importingClassMetadata<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">EnableService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> annotationAttributes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"com.example.simpleboot.anno.ConfigB"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ImportBeanDefinitionRegistrar的类，用于个性化加载"><a href="#ImportBeanDefinitionRegistrar的类，用于个性化加载" class="headerlink" title="ImportBeanDefinitionRegistrar的类，用于个性化加载"></a><code>ImportBeanDefinitionRegistrar</code>的类，用于个性化加载</h3><p>与<code>ImportSelector</code>用法与用途类似，但是如果我们想重定义<code>Bean</code>，例如动态注入属性，改变<code>Bean</code>的类型和<code>Scope</code>等等，就需要通过指定实现<code>ImportBeanDefinitionRegistrar</code>的类实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceC</span> <span class="token keyword">implements</span> <span class="token class-name">ServiceInterface</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token class-name">ServiceC</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"CCCCCCCCCC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceImportBeanDefinitionRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> importingClassMetadata<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">EnableService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BeanDefinitionBuilder</span> beanDefinitionBuilder <span class="token operator">=</span> <span class="token class-name">BeanDefinitionBuilder</span><span class="token punctuation">.</span><span class="token function">rootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">ServiceC</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token comment">//增加构造参数</span>                <span class="token punctuation">.</span><span class="token function">addConstructorArgValue</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//注册Bean</span>        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"serviceC"</span><span class="token punctuation">,</span> beanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@EnableService</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"qxnekoo"</span><span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token string">"23"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span><span class="token string">"configA"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ConfigA</span> <span class="token punctuation">&#123;</span><span class="token comment">//    @Bean</span><span class="token comment">//    @ConditionalOnMissingBean</span><span class="token comment">//    public ServiceInterface getServiceA() &#123;</span><span class="token comment">//        return new ServiceA();</span><span class="token comment">//    &#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ImportBeanDefinitionRegistrar</code> 在 <code>@Bean</code> 注解之后加载，所以要修改<code>ConfigA</code>去掉其中被<code>@ConditionalOnMissingBean</code>注解的<code>Bean</code>，否则一定会报错有多个Bean</p><p><img src="/myimage/image-6.png" alt="image-6.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot自动配置基本原理</title>
      <link href="2021/09/20/Spring%20Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>2021/09/20/Spring%20Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>首先@EnableAutoConfiguration注解是一个关键点，可以点进去看一看</p><p><img src="http://www.qxnekoo.cn:8888/images/2021/12/22/image-1.png" alt="image-1.png"></p><p>有一个非常重要的@Import，这种方式是上一篇文章中@Import使用的第二种方式，看看AutoConfigurationImportSelector关键的代码。</p><p><img src="http://www.qxnekoo.cn:8888/images/2021/12/22/image.png" alt="image.png"></p><p><img src="http://www.qxnekoo.cn:8888/images/2021/12/22/image-2.png" alt="image-2.png"></p><p><a href="http://www.qxnekoo.cn:8888/image/U2ah"><img src="http://www.qxnekoo.cn:8888/images/2021/12/22/image-3.png" alt="image-3.png"></a></p><p>说白了也就是通过spring.factories类似SPI的机制，将可能不在包扫描路径下的Bean加入到容器中并生效，loadFactoryNames相关详情可见第一篇文章。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring.factories</title>
      <link href="2021/09/10/spring-factories/"/>
      <url>2021/09/10/spring-factories/</url>
      
        <content type="html"><![CDATA[<p>类似于JAVA SPI的机制。</p><blockquote><p>当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader</p></blockquote><p>而Spring boot则是在 META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取配置文件并实例化。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>spring-core包里定义了SpringFactoriesLoader类，这个类实现了检索META-INF/spring.factories文件。</p><p><strong>loadFactories</strong> 根据接口类获取其实现类的实例，这个方法返回的是对象列表。 </p><p><strong>loadFactoryNames</strong> 根据接口获取其接口类的名称，这个方法返回的是类名的列表。 </p><p>**loadSpringFactories **根据Spring.factories文件获得接口与其实现类们（可能有多个实现类），返回一个Map&lt;接口,List&lt;实现类名&gt;&gt;</p><p><a href="http://www.qxnekoo.cn:8888/image/Ubhu"><img src="http://www.qxnekoo.cn:8888/images/2021/12/22/image-4.png" alt="image-4.png"></a></p><p>常量FACTORIES_RESOURCE_LOCATION就是”META-INF/spring.factories”</p><p>result.computeIfAbsent就是将配置文件中的配置放入到Map&lt;配置属性名，List&lt;配置结果&gt;&gt;中</p><p><a href="http://www.qxnekoo.cn:8888/image/Ug66"><img src="http://www.qxnekoo.cn:8888/images/2021/12/22/image-5.png" alt="image-5.png"></a></p><p>在日常工作中，我们可能需要实现一些SDK或者Spring Boot Starter给被人使用时， </p><p> 我们就可以使用Factories机制。Factories机制可以让SDK或者Starter的使用只需要很少或者不需要进行配置，只需要在服务中引入我们的jar包即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS（一）</title>
      <link href="2021/09/07/BFS1/"/>
      <url>2021/09/07/BFS1/</url>
      
        <content type="html"><![CDATA[<p>核心思想，把一些问题抽象成图，从一个点开始，向四周扩散，一般来说，写 BFS 算法都是用“队列”这种数据结构，每次将一个节点周围的所有节点加入队列。</p><p>BFS 和 DFS 最主要的区别：<strong>BFS 找到的路径一定是最短的，但代价是空间复杂度比 DFS 大很多。</strong></p><p>常见场景：<strong>在一幅图中从起点 start 到终点 target 的最近距离。</strong>比如走迷宫，单词替换字母，连连看等等。</p><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token class-name">Node</span> start<span class="token punctuation">,</span><span class="token class-name">Node</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> q<span class="token punctuation">;</span> <span class="token comment">//核心数据结构</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> visited<span class="token punctuation">;</span>  <span class="token comment">//避免走回头路</span>        q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将起点加入队列</span>    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//记录扩散的步数</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>q not empty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sz <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将队列中的所有节点向四周扩散</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sz<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span> cur <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//是否到达终点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur is target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> step<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//将cur相邻节点加入队列</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token operator">:</span> cur<span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>x not in visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//更新步数</span>        step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cur.adj() 泛指与 cur 相邻的节点，visited 的主要作用就是防止走回头路，但是像一般的二叉树结构，没有子节点到达父节点指针，就不需要 visited。</p><h2 id="二叉树的最小高度"><a href="#二叉树的最小高度" class="headerlink" title="二叉树的最小高度"></a>二叉树的最小高度</h2><p>计算二叉树的根节点到叶子节点的最短距离。起点就是 root 根节点，终点就是最靠近根节点的那个叶子节点。</p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> treeNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//q.offer(q.)</span>            <span class="token class-name">TreeNode</span> poll <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>poll<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> poll<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> depth<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>poll<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>poll<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>poll<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>poll<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//记得这边要累加</span>        depth<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> depth<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引出两个问题：</p><ol><li><p>BFS 可以找到最短路径，DFS 可以吗？</p><p>BFS 来说，depth 每增加一次，队列中的所有节点都向前迈一步，这个逻辑保证了一旦找到了一个终点，走的步数都是最少的。BFS 算法的时间复杂度最坏是 O(N)。</p><p>DFS 也可以找到最短路径，但是它是通过递归的堆栈记录走过的路径，要把二叉树中所有树杈都探索完，然后对比出路径最少的那一个，而 BFS 是可以在还没有完全遍历出这棵树的情况下得到答案，相对来说，BFS 的效率更高。</p></li><li><p>DFS 为啥要存在？</p><p>简单来说 BFS 的空间复杂度较高，对 DFS 来说，空间复杂度无非就是递归堆栈，在最坏的情况下顶多就是树的高度 O(logN)，而 BFS 来说最坏的空间复杂度为 O(N)。</p></li></ol><h2 id="密码锁的最少次数"><a href="#密码锁的最少次数" class="headerlink" title="密码锁的最少次数"></a>密码锁的最少次数</h2><p><a href="https://leetcode-cn.com/problems/open-the-lock/">题目内容</a>：</p><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><p><strong>思路：对于一串数字，比如’0000’来说，他一次一共有 2*4 = 8 中的旋转可能，依次穷举，也就是说，对于这个节点来说，每个节点有8个相邻的节点，有两个注意点：1.不能走回头路，因为是最少。2.遇到死亡数字时，跳过，不要进行任何处理。</strong></p><p>伪代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'9'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">String</span> <span class="token function">minusOne</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'9'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token class-name">String</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">'0000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> s<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//。。找到</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token function">plusOne</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token function">minusOne</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//步骤加一</span>        res<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>全代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">openLock</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> deadends<span class="token punctuation">,</span> <span class="token class-name">String</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> deadSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>deadends<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"0000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> setp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sz <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> poll <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//进行死亡密码的校验</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>deadSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>poll<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>poll<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> setp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//将这个节点分布的其他节点加进来 已经加进去过的就不需要了</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>poll<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token function">minusOne</span><span class="token punctuation">(</span>poll<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        setp<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向-BFS"><a href="#双向-BFS" class="headerlink" title="双向 BFS"></a>双向 BFS</h2><p><strong>传统的 BFS 框架是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</strong></p><p>使用朴素 BFS 进行求解时，队列中最多会存在两层的搜索节点，因此搜索空间的上限取决于目标节点所在的搜索层次的深度所对应的宽度。下图展示了朴素 BFS 可能面临的搜索空间爆炸问题：</p><p><img src="https://pic.leetcode-cn.com/1623894968-XELIvK-image.png" alt="搜索空间爆炸"></p><p>而双向 BFS 同时从两个方向开始搜索，<strong>一旦搜索到相同的值，意味着找到了一条联通起点和终点的最短路径</strong></p><p><img src="https://pic.leetcode-cn.com/1623894976-CCMljJ-image.png" alt="图解双向 BFS"></p><p>这里先展示下别人的 BFS 逻辑，之后补上三叶姐的实现思路。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">openLock2</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> deadends<span class="token punctuation">,</span> <span class="token class-name">String</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> deadSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>deadends<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//用集合不用队列</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> q1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> q2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"0000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>q2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//在遍历的过程中不能修改哈希集合</span>        <span class="token comment">//用temp存储q1的扩散结果</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> cur <span class="token operator">:</span> q1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>deadSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//如果q1和q2有交集 则表示有一条联通的路径的 返回结果</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>q2<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> step<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> up <span class="token operator">=</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    temp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">String</span> down <span class="token operator">=</span> <span class="token function">minusOne</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    temp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        step<span class="token operator">++</span><span class="token punctuation">;</span>        q1 <span class="token operator">=</span> q2<span class="token punctuation">;</span>        q2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>技巧点：</p><ol><li>不使用队列，而是使用 Set，可以快速的判断是否有交集</li><li>while 循环的是去交换 q1 和 q2 的内容，所以只要默认扩散 q1，就相当于轮流扩散 q1 和 q2。</li></ol><p>还有一个额外的技巧点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>q2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>q2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> tempFOrSwap <span class="token operator">=</span> q1<span class="token punctuation">;</span>        q1<span class="token operator">=</span>q2<span class="token punctuation">;</span>        q2<span class="token operator">=</span>tempForSwap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是每次去操作数据较少的那个 Set，因为 Set 中的数据越多，占用的空间增长速度就越快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>里氏替换原则</title>
      <link href="2021/08/20/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
      <url>2021/08/20/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>简单描述：简称 LSP 原则，子类对象能替换在程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p><h2 id="哪些会违背-LSP"><a href="#哪些会违背-LSP" class="headerlink" title="哪些会违背 LSP"></a>哪些会违背 LSP</h2><p>按照协议来设计（Design by Contract）：子类在设计的时候，要遵循父类的行为约定（或者叫协议）。<strong>父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定</strong>，行为约定包括了，函数声明要实现的功能；对输入、输出、异常的约定甚至包括了注释中所罗列的任何特殊说明。实际上，子类和父类之间的关系，也是可以替换为实现类和接口的关系。</p><ol><li><p>子类违背了父类的实现功能</p><p>父类某个函数查询按金额排序，子类却按照时间排序。</p></li><li><p>子类违背父类对输入、输出、异常的约定</p><p>子类某个函数对输入的数据校验比父类更加严格，子类抛出了比父类更多的异常。</p></li><li><p>子类违背父类注释中所罗列的任何特殊说明</p><p>父类提款函数约定提款金额不得大于存款，但是子类提款函数约定vip账户能透支提现。</p></li></ol><h2 id="和多态的区别"><a href="#和多态的区别" class="headerlink" title="和多态的区别"></a>和多态的区别</h2><p>从定义和代码实现来看，多态和里氏替换是类似的，但是他们的关注点是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，<strong>是代码的实现思路</strong>。而里氏替换是一种设计原则，用来<strong>指导继承关系中子类该如何去设计</strong>，子类的设计要保证再替换父类的时候，不改变原有程序的逻辑不破坏原有程序的正确性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开闭原则</title>
      <link href="2021/08/18/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
      <url>2021/08/18/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>扩展性是代码质量最重要的衡量标准之一。在 23 种设计模式中，<strong>大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</strong></p><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>英文全称是 Open Closed Principle，简写为 OCP，翻译过来就是：<strong>软件实体（模块、类、方法）应该“多扩展开发、对修改关闭”。</strong></p><p>开闭原则可以用于不同粒度的代码中，可以是模块，也可以是类，还可以是方法（及其属性），同一个代码改动，在粗粒度下，被认为是“修改”，在细代码粒度下，又可以被认定为“扩展”。实际上也没有必要去纠结一个代码是“修改”还是“扩展”，只要他没有 破坏原有代码的正常运行，没有破坏原有的单元测试，就可以说是一个合格的测试。</p><p>下面是一个 API 接口监控告警的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Alert</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AlertHandler</span><span class="token punctuation">></span></span> alertHandlers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAlertHandler</span><span class="token punctuation">(</span><span class="token class-name">AlertHandler</span> alertHandler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>alertHandlers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>alertHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">ApiStatInfo</span> apiStatInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">AlertHandler</span> handler <span class="token operator">:</span> alertHandlers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            handler<span class="token punctuation">.</span><span class="token function">check</span><span class="token punctuation">(</span>apiStatInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AlertHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">AlertRule</span> rule<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">Notification</span> notification<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AlertHandler</span><span class="token punctuation">(</span><span class="token class-name">AlertRule</span> rule<span class="token punctuation">,</span><span class="token class-name">Notification</span> notification<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rule <span class="token operator">=</span> rule<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>notification <span class="token operator">=</span> notification<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">ApiStatInfo</span> apiStatInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TpsAlertHandler</span> <span class="token keyword">extends</span> <span class="token class-name">AlertHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">TpsAlertHandler</span><span class="token punctuation">(</span><span class="token class-name">ALertRule</span> rule<span class="token punctuation">,</span> <span class="token class-name">Notification</span> notification<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>rule<span class="token punctuation">,</span>notification<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">ApiStatInfo</span> apiStatInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> tps <span class="token operator">=</span> apiStatInfo<span class="token punctuation">.</span><span class="token function">getRequestCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>apiStatInfo<span class="token punctuation">.</span><span class="token function">getDurationOfSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tps<span class="token operator">></span>rule<span class="token punctuation">.</span><span class="token function">getMatchedRule</span><span class="token punctuation">(</span>apiStatInfo<span class="token punctuation">.</span><span class="token function">getApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxTps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            notification<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token class-name">NotificationEmergencyLevel</span><span class="token punctuation">.</span>URGENCY<span class="token punctuation">,</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ErrorAlertHandler</span> <span class="token keyword">extends</span> <span class="token class-name">AlertHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ErrorALertHandler</span><span class="token punctuation">(</span><span class="token class-name">AlertRule</span> rule<span class="token punctuation">,</span><span class="token class-name">Notification</span> notification<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>rule<span class="token punctuation">,</span>notification<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">ApiStatInfo</span> apiStatInfo<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">long</span> errorCount <span class="token operator">=</span> apiStatInfp<span class="token punctuation">.</span><span class="token function">getErrorCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>errorCount<span class="token operator">></span>rule<span class="token punctuation">.</span><span class="token function">getMatchedRule</span><span class="token punctuation">(</span>apiStatInfo<span class="token punctuation">.</span><span class="token function">getApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxErrorCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            notification<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token class-name">NotificationEmergenccyLevel</span><span class="token punctuation">.</span>SERVER<span class="token punctuation">,</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationContext</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">AlertRule</span> alertRule<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Notification</span> notification<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Alert</span> alert<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initializeBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        alertRule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlertRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//省略初始化参数</span>        notification <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Notification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//省略初始化参数</span>        alert <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Alert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        alert<span class="token punctuation">.</span><span class="token function">addAlertHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TpsAlertHandler</span><span class="token punctuation">(</span>alertRule<span class="token punctuation">,</span>notification<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        alert<span class="token punctuation">.</span><span class="token function">addAlertHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ErrorAlertHandler</span><span class="token punctuation">(</span>alertRule<span class="token punctuation">,</span>notification<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Alert</span> <span class="token function">getAlert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> alert<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//饿汉模式</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ApplicatioContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">initializeBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">getSingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> applicationContext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ApiStatInfo</span> apiStatInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApiStatInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//省略设置 apiStatInfo 属性的代码</span>        <span class="token class-name">ApplicationContext</span><span class="token punctuation">.</span><span class="token function">getSingleIntance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAlert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">check</span><span class="token punctuation">(</span>apiStatInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想添加新的告警逻辑，只需要基于扩展的方法创建新的 handler 类即可，不需要改动原来 check() 函数的逻辑。</p><h2 id="修改代码意味着违背开闭原则？"><a href="#修改代码意味着违背开闭原则？" class="headerlink" title="修改代码意味着违背开闭原则？"></a>修改代码意味着违背开闭原则？</h2><p>添加一个新的功能，不可能任何模块、类、方法的代码都不“修改”，类需要创建、组装、并且做一些初始化操作，才能构建可运行的程序。<strong>我们要做的就是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的逻辑代码满足开闭原则。</strong></p><h2 id="如何做到"><a href="#如何做到" class="headerlink" title="如何做到"></a>如何做到</h2><p>需要更加偏向顶层的指导思想：<strong>时刻具备扩展意识、抽象意识、封装意识。</strong></p><p>具体的方法论：很多设计原则、设计思想、设计模式都是以提高代码的扩展性为最终目的的。最常用来提高扩展性的方法有：<strong>多态、依赖注入、基于接口而非实现编程</strong>，以及大部分的<strong>设计模式</strong>（比如，装饰、策略、模板、职责链、状态等）。</p><blockquote><p>多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，都是用一种设计思路，<strong>只是从不同的角度、不同的层面来阐述而已。</strong></p></blockquote><p>代码中通过 Kafka 来发送异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MessageQueue</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KafakaMessageQueue</span> <span class="token keyword">implements</span> <span class="token class-name">MessageQueue</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RocketMQMessageQueue</span> <span class="token keyword">implements</span> <span class="token class-name">MessageQueue</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MessageFromatter</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JsonMessageFromatter</span> <span class="token keyword">implements</span> <span class="token class-name">MessageFromatter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProtoBufMessageFromatter</span> <span class="token keyword">implements</span> <span class="token class-name">MessageFromatter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">MessageQueue</span> msgQueue<span class="token punctuation">;</span> <span class="token comment">//基于接口而非实现编程</span>    <span class="token keyword">public</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token class-name">MessageQueue</span> msgQueue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msgQueue <span class="token operator">=</span> msgQueue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// msgFormatter：多态、依赖注入 </span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendNotification</span><span class="token punctuation">(</span><span class="token class-name">Notification</span> notification<span class="token punctuation">,</span> <span class="token class-name">MessageFormatter</span> msgFormatter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//... </span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何应用"><a href="#如何应用" class="headerlink" title="如何应用"></a>如何应用</h2><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单一职责原则</title>
      <link href="2021/08/12/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
      <url>2021/08/12/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>SOLID 原则，由五个原则组成，分别是：<strong>单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则</strong>。</p><p>单一职责原则（Signle Responsibility Principle），简称 SRP，a class or module should have a single responsibility。一个类或者模块只负责完成一个职责（功能）。</p><blockquote><p>类（class）和模块（module）的理解。</p><ol><li>模块看作比类更抽象的概念，类也可以看作模块。</li><li>把模块看作是比类更粗粒度的代码块，模块中包含多个类，多个类组成一个模块。</li></ol></blockquote><p>不要设计大而全的类，要设计力度小、功能单一的类，如果一个类中包含了两个或两个以上业务不相干的功能放到同一个类中，那就违反了单一职责原则。</p><h2 id="如何判断类的职责是否足够单一"><a href="#如何判断类的职责是否足够单一" class="headerlink" title="如何判断类的职责是否足够单一"></a>如何判断类的职责是否足够单一</h2><p>比如下面的用户类:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserInfo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> telephone<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> createTime<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> lastLoginTime<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> avatarUrl<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> provinceOfAddress<span class="token punctuation">;</span> <span class="token comment">// 省</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> cityOfAddress<span class="token punctuation">;</span> <span class="token comment">// 市</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> regionOfAddress<span class="token punctuation">;</span> <span class="token comment">// 区 </span>  <span class="token keyword">private</span> <span class="token class-name">String</span> detailedAddress<span class="token punctuation">;</span> <span class="token comment">// 详细地址</span>  <span class="token comment">// ...省略其他属性和方法...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户的地址信息是否可以作为一个单独的业务类抽出来？</p><p><strong>不能脱离具体的应用场景，如果系统中的这些地址字段仅仅作为展示，那么现在的用户类其实是合理的。但是如果这个系统中有电商的模块，地址信息会再物流模块中被使用，那么地址信息就可以从用户类中抽出来！</strong></p><p><em><strong>不同的应用场景，不同的需求背景下，对一个类的职责是否单一的判定，可能都是不一样的。</strong></em></p><p>不同的业务层面的判断也会有所不同，从“用户”的层面来看，这个类的设计是合理的，但是从“地址信息”、“登录认证信息”来看，用户类就可以继续拆分。</p><h2 id="实际开发"><a href="#实际开发" class="headerlink" title="实际开发"></a>实际开发</h2><p>在实际开发中，并没有必要过早的未雨绸缪，过度设计，可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候我们就可以将这个粗粒度的类，拆分成几个更细粒度的类，这就是<strong>持续重构</strong>。</p><p>判断职责是否单一的依据是非常主观的，实际上一些侧面的判断指标更具有指导意义和可执行性：</p><ul><li>类的代码行数、函数或者属性过多</li><li>类依赖的其他类过多，或者依赖类的其他类过多</li><li>私有方法过多</li><li>类的名字难以命名</li><li>类中大量的方法都是集中操作类的某几个属性</li></ul><h2 id="是否越单一越好"><a href="#是否越单一越好" class="headerlink" title="是否越单一越好"></a>是否越单一越好</h2><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类的职责越单一，类依赖的被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高类聚、低耦合。但是如果拆分的过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><blockquote><p>内聚和耦合是一对意思，从相反的方向进行阐述</p><ol><li>内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。</li><li>耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意结合起来，就增加了耦合性，成了高耦合。</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法（一）</title>
      <link href="2021/08/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%951/"/>
      <url>2021/08/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%951/</url>
      
        <content type="html"><![CDATA[<p>解决一个回溯问题，实际上就是一个决策树的遍历过程。</p><ol><li>路径：已经做出的选择</li><li>选择列表：当前可以做的选择</li><li>结束条件：到达决策树地测嗯，无法在做出选择的条件</li></ol><p><strong>其核心就是 for 循环里面的递归，在递归调用前“做选择”，在递归调用之后“撤销选择”。</strong></p><p>代码框架：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>满足结束条件<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>路径<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择 in 选择列表<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        做选择        <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 回溯</span>        撤销选择    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>比如给出三个数字[1,2,3]（不包含重复数字），一般会如下的方式排列：</p><p><img src="https://img-blog.csdnimg.cn/20200702134757690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70" alt="全排列"></p><p>这棵树就是回溯方法的“决策树”。将上述三个点翻译过来就是：</p><p><strong>[2] 就是路劲，已经选择过的节点，[1,3] 就是选择列表，而结束条件就是选择列表为空的时候了。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200702135341483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70"></p><p>定义的 backtrack 函数其实就像是一个指针，在这颗树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。</p><p>多叉树的遍历框架：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span> child <span class="token operator">:</span> root<span class="token punctuation">.</span>childern<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 前序遍历需要的操作</span>        <span class="token function">traverse</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 后序遍历需要的操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200702135758233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70" alt="多叉树遍历"></p><p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200702135824932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FBUTEyMzY2Ng==,size_16,color_FFFFFF,t_70"></p><p>再看核心代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>选择 in 选择列表<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 做选择。相当于前序遍历的操作</span>    将该选择从选择列表移除    路径<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>选择<span class="token punctuation">)</span>    <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span>    <span class="token comment">// 撤销选择。相当于后序遍历的操作</span>    路径<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>选择<span class="token punctuation">)</span>    将该选择再加入选择列表<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。</p><p>全排列代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 记录「路径」</span>    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> track <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> track<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 路径：记录在 track 中</span><span class="token comment">// 选择列表：nums 中不存在于 track 的那些元素</span><span class="token comment">// 结束条件：nums 中的元素全都在 track 中出现</span><span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> track<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 触发结束条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>track<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span>track<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 排除不合法的选择</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>track<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 做选择</span>        track<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 进入下一层决策树</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> track<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 取消选择</span>        track<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个算法解决全排列不是很高效，因为对链表使用 contains 方法需要 O(N)  的时间复杂度。有更好的方法通过元素交换达到目的。</p><p>不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整颗决策树是无法避免的。<strong>这也是回溯算法的一个特点，不想动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</strong></p><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>棋盘中皇后可以攻击同一行、同一列，或者左上，左下、右上、右下四个方向的任意单位。现在给出一个 N * N 的棋盘，让你放置 N 个皇后，使得他们不能互相攻击，返回所有合法的结果。</p><p>这个问题的本质和全排列差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><p><img src="https://img-blog.csdnimg.cn/2019011517540754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BpeW9uZ2R1bzMzOTM=,size_16,color_FFFFFF,t_70#pic_center"></p><p>代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//初始化棋盘</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backTracing</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backTracing</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">chsToList</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> chs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            chs<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span><span class="token punctuation">;</span>            <span class="token comment">//递归</span>            <span class="token function">backTracing</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//回溯</span>            chs<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">chsToList</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch <span class="token operator">:</span> chs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//检查列中是否有皇后冲突</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> x<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//检查右上方是否有皇后冲突</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token generics"><span class="token punctuation">&lt;</span> n <span class="token operator">&amp;</span><span class="token operator">&amp;</span> i <span class="token punctuation">></span></span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//检查左上方是否有皇后冲突</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最坏的时间复杂度能达到 O(n^n+1)，而且无法优化。</p><p>得到结果就返回，而不是得到所有结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">backTracing</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">chsToList</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> chs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            chs<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span><span class="token punctuation">;</span>            <span class="token comment">//递归</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">backTracing</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//回溯</span>            chs<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回溯算法就是一个多叉树的遍历问题，关键就在于前序遍历和后序遍历做一些操作：<strong>写 backTracing 函数的时候，需要维护走过的“路径”和当前可以做的“选择列表”，当触发“结束条件”时，将“路径“记入结果集。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（一）</title>
      <link href="2021/07/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921/"/>
      <url>2021/07/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921/</url>
      
        <content type="html"><![CDATA[<p>动态规划的一般形式就是求最值，动态规划的核心问题是穷举，但是简单的穷举会存在一个问题，那就是<strong>重叠子问题</strong>，需要备忘录或者“DP table”来优化穷举过程。一般来说，一定会具有“<strong>最优子结构”</strong>，这样才能通过子问题的最值得到原问题的最值。还有一个重点就是<strong>状态转移方程</strong>。</p><ol><li>这个问题有什么 base case（最简单的情况）是什么？</li><li>这个问题有什么状态？</li><li>对于每个状态，可以做出什么选择使得状态发生变化？</li><li>如何定义dp数组/函数的含义来表现“状态”和“选择”？</li></ol><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><ol><li><p>暴力递归：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>类似于上楼梯的问题：在只能一步和两步的情况下，问到N层楼梯有多少种走法？</p><p>当n&gt;2时，f(n)  = f(n-1)+f(n-2) ， f(1) =1 ，f(2)=2。</p><p>因为到达第n层楼梯的前提条件为：到达了n-1层楼梯或者n-2层楼梯，只有这样下一步才有可能到达n层楼梯。</p></blockquote><p>递归树：</p><p><img src="http://www.qxnekoo.cn:8888/images/2022/01/05/1.jpg"></p><p><strong>递归的时间复杂度：子问题的个数乘以解决一个子问题需要的时间。</strong></p><p>二叉树的节点总数为指数级别的，所以时间复杂度为O(2^n)，指数级别。存在大量的重复计算。即重叠子问题。</p></li><li><p>带备忘录的递归解法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>ints<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//这个函数的第一次递归会将所有的x[0]到x[n-1]都算出来</span>    x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">helper</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本算法不涉及到冗余计算，数量和输入规模n成正比，时间复杂度为O(N)。和刚才的暴力算法相比，算是降维打击了。</p><p>这种算法叫做<strong>自顶向下</strong>，想得到f(20)的解，就先算出f(19)和f(18)的值，以此推算到基本的 f(1)和f(0)。并且仍然属于递归！！</p><p>还有一种是自底向上的，从f(1),f(0)开始算f(3),f(4)……直到算到最后的f(20)，这就是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算的关键所在。</p></li><li><p>dp数组的迭代算法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">fib3</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ints<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ints<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ints<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ints<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> ints<span class="token punctuation">[</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> ints<span class="token punctuation">[</span>x <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ints<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何自下而上：</p><p><img src="http://www.qxnekoo.cn:8888/images/2022/01/05/4.jpg" alt="4.jpg"></p><p>状态转移方程：把f(n)想为一个状态，这个状态是有f(n-1)和f(n-2)转换而来的，这就叫状态转移方程。 </p><blockquote><p>return f(n-1)+f(n-2) 和 dp[i]=dp[i-1]+dp[i-2]以及dp table的初始化方式，都是对这个状态转移方程的不同表现形式。</p></blockquote><p>最后一个细节问题，我们发现上面的状态转移方程中的f(n)只和f(n-1)和f(n-2)有关，只要想办法存储这两个状态就好了，这个过程叫做“<strong>状态压缩</strong>”。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">fib4</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> prev <span class="token operator">+</span> next<span class="token punctuation">;</span>        prev <span class="token operator">=</span> next<span class="token punctuation">;</span>        next <span class="token operator">=</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索算法</title>
      <link href="2021/06/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
      <url>2021/06/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-insert-position/">leetcode35题</a>：</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 </p><p>输入：[1,3,5,6], 5  ==&gt;  输出：2</p><p>输入：[1,3,5,6], 2  ==&gt;  输出：1</p><p>这题非常简单，不用任何算法，直接从头开始遍历查询就可以了，提交通过之后看了答案才知道其实这题的考点是：二分查找。然后我并没有发觉，非常惭愧啊！！！</p><h2 id="基本的二分搜索"><a href="#基本的二分搜索" class="headerlink" title="基本的二分搜索"></a>基本的二分搜索</h2><p>搜索一个数，如果存在返回其索引，否则返回-1。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span>  <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>left + (right - left)/2 和 (left+right)/2 的结果一样，但如果 left、right 太大的话，直接相加会导致整型溢出，所以需要先减再加。</p></blockquote><ol><li><p>为什么 while 循环的条件是 &lt;= 而不是 &lt; 呢？</p><p>主要是初始化 right 的值为 nums.length-1 ,而不是 nums.length，这两个的区别是：前者相当于两端都闭区间 [left,right]，后者相当于左闭右开区间 [left,right]。因为索引大小为 nums.length 是越界的。</p><p>left &lt; right 的终止条件是 left = right 但是，[left ,right] 的区间其实并不是空，因为还有一个元素。</p></li><li><p>有什么缺陷？</p><p>有序数组[1,3,3,3,4]，target 为 3，该算法返回的正中间的索引 2。但是如果想得到 target 的左侧边界，也就是索引 1，或者右索引 3，该算法是无法处理的。</p><p><strong>虽然可以通过向左或向右线性搜索，但是这样就不能保证二分搜索对数级的复杂度了。</strong></p></li></ol><h2 id="左侧边界的二分搜索"><a href="#左侧边界的二分搜索" class="headerlink" title="左侧边界的二分搜索"></a>左侧边界的二分搜索</h2><p>先看代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">leftBound</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//注意 这里不是减一  因为右边是开区间</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//注意  因为是开区间 所以没有必要等于 比如 [6,6)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//注意 没有减一 因为右边的区间是开区间</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实也可以将 right 初始化为 nums.length ，这个之后再说，先看上面的代码。</p><p>总体思路：找到对应的 target 的时候，不要急着返回结果，将 right（开区间）移动至该位置，依次循环该操作。最后找到的 left 就是要获取的位置，最后与这个相关的还有一个问题，就是为什么没有返回 -1，如果没有找到指定的值该如何处理？</p><p>其实这个找位置的问题可以转换一下，即：<strong>在有序数组中有多少个比给定值小的数？</strong>答案就是该值应该在数组中的位置，只要看一下数组中该位置中的数是不是给定的值，如果是，则找到了该数，如果不是，那么在该数组中就没有要找到的值，就可以返回 -1 了。</p><blockquote><p>nums[mid] == target 这种情况的处理：right = mid;</p><p>找到 target 时不要立即返回，而是缩小“搜索区间”的上界 right，在区间 [left,right) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><p>至于为什么返回 left 而不是 right，因为都是一样的,while 的终止条件是 left=right。</p></blockquote><hr><p> right 初始化为 nums.length-1 的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">leftBound2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//检查出界的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> nums<span class="token punctuation">.</span>length <span class="token operator">||</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="右侧边界的二分搜索"><a href="#右侧边界的二分搜索" class="headerlink" title="右侧边界的二分搜索"></a>右侧边界的二分搜索</h2><p>先看代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span>  <span class="token function">rightBoundBinary</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路：知道对应的 target 的时候，不要立即返回，而是增加 left 的值，也就是缩小下区间。</p><p>为什么是 left -1，而不是 right - 1 其实无所谓，因为终止条件是 left = right，用哪个都行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆、优先队列</title>
      <link href="2021/06/14/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>2021/06/14/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>leetcode 第1046简单题：</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p><hr><p>一般的队列特性：元素先进先出。优先队列不遵循先进先出的概念，分为两种情况：</p><ul><li>最大优先队列，无论入队顺序，当前最大的元素出队。</li><li>最小优先队列，无论出对顺序，当前最小的元素出队。</li></ul><p>从数据结构上来看，一般的队列是线性结构，但是优先队列使用线性结构实现的时间复杂度很高为 O(n)。</p><p>所以优先队列一般是通过二叉堆来实现的。</p><blockquote><p>二叉堆特性：</p><ol><li>最大堆的堆顶是整个堆中的最大元素</li><li>最小堆的堆顶是整个堆中的最小元素</li></ol></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>堆是一个完全二叉树</p><p>完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p></li><li><p>堆中每一个节点的值都必须大于等于（或小于等于）<strong>其子树中每个节点的值</strong>。</p><p>堆中每个节点的值都大于等于（或者小于等于）<strong>其左右子节点的值</strong>。大于等于子树中每个节点值的堆，叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，叫做“小顶堆”。</p></li></ul><p>实现堆，要先知道对都支持哪些操作以及如何存储一个堆。<strong>完全二叉树比较适合用数组存储，用数组存储完全二叉树是非常节省存储空间的，因为我们不需要存储左右节点的指针，单纯地通过数组下标，就可以找到一个节点的左右子节点和父节点。</strong></p><p><img src="https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg" alt="数组存储堆"></p><p>数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i/2 的节点。</p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>以大顶堆举例，插入：</p><p>如果加一个新的元素放到数组的最后，那么很有可能是不满足堆的特性了，所以需要调整，这个过程叫做堆化。（有两种，从下往上、从上往下）</p><p><img src="https://static001.geekbang.org/resource/image/e5/22/e578654f930002a140ebcf72b11eb722.jpg" alt="添加一个22的元素"></p><p><strong>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。</strong></p><p><img src="https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg" alt="从下往上堆化过程"></p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Heap</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span> <span class="token comment">// 数组，从下标1开始存储数据</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>  <span class="token comment">// 堆可以存储的最大数据个数</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">// 堆中已经存储的数据个数</span>  <span class="token keyword">public</span> <span class="token class-name">Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 堆满了</span>    <span class="token operator">++</span>count<span class="token punctuation">;</span>    a<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 自下往上堆化</span>      <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// swap()函数作用：交换下标为i和i/2的两个元素</span>      i <span class="token operator">=</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> swap <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> z <span class="token operator">=</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>      a<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除堆顶元素：</p><p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p><p><img src="https://static001.geekbang.org/resource/image/59/81/5916121b08da6fc0636edf1fc24b5a81.jpg" alt="堆化过程"></p><p>此时可以看到，这个树已经不是完全二叉树了。</p><p>我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。</p><blockquote><p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p></blockquote><p><img src="https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg" alt="从上往下堆化过程"></p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 堆中没有数据</span>  a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">--</span>count<span class="token punctuation">;</span>  <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 自上往下堆化</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> maxPos <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>maxPos<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxPos <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> maxPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    i <span class="token operator">=</span> maxPos<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> swap <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个包含 n 个节点的完全二叉树，树的高度不会超过 log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。从后往前处理数组，并且每个数据都是从上往下堆化。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从最后一个非叶子节点开始，依次堆化就行了。</p><p><img src="https://static001.geekbang.org/resource/image/50/1e/50c1e6bc6fe68378d0a66bdccfff441e.jpg"></p><p><img src="https://static001.geekbang.org/resource/image/aa/9d/aabb8d15b1b92d5e040895589c60419d.jpg"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> maxPos <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>maxPos<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxPos <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> maxPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    i <span class="token operator">=</span> maxPos<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个建堆的时间复杂度为O(n),下面看排序。</p><p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下表为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n-1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到 n-1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</p><p><img src="https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg" alt="img"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">buildHeap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> k <span class="token operator">=</span> n<span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">--</span>k<span class="token punctuation">;</span>         <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>为什么实际开发的时候，快速排序要比堆排序性能好，这两种排序算法的时间复杂度都是O(nlogn),甚至堆排序比快速排序的时间复杂度还要稳定。</p><ol><li><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，<strong>这样对 CPU 缓存是不友好的。</strong>CPU对于顺序访问的数据更加友好，可以做缓存。</p><p><img src="https://static001.geekbang.org/resource/image/83/ce/838a38286dcace89ca63895b77ae8ece.jpg" alt="img"></p></li><li><p>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</p><p>堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贫血模型与充血模型</title>
      <link href="2021/05/30/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/30/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>很多业务系统基于 MVC 三层架构来开发，这是一种基于贫血模型的 MVC 三层架构开发模式。虽然已经成为标准的 Web 项目的开发模式，但却违反了面向对象编程风格，是一种彻底的面向过程的编程风格。</p><blockquote><p>特别是领域驱动设计（Domain Driven Design，简称 DDD）之后，基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的 DDD 开发模式越来越被人提倡。</p></blockquote><h2 id="贫血模型的传统开发模式"><a href="#贫血模型的传统开发模式" class="headerlink" title="贫血模型的传统开发模式"></a>贫血模型的传统开发模式</h2><p>一般就将后端项目分为 Repository 层、Service 层、Controller 层。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">////////// Controller+VO(View Object) //////////</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span> <span class="token comment">//通过构造函数或者IOC框架注入</span>    <span class="token keyword">public</span> <span class="token class-name">UserVo</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">UserBo</span> userBo <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">UserVo</span> userVo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>convert userBo <span class="token keyword">to</span> <span class="token namespace">userVo<span class="token punctuation">.</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userVo<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserVo</span> <span class="token punctuation">&#123;</span><span class="token comment">//省略其他属性、get/set/construct方法</span>  <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> cellphone<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">////////// Service+BO(Business Object) //////////</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">;</span> <span class="token comment">//通过构造函数或者IOC框架注入</span>    <span class="token keyword">public</span> <span class="token class-name">UserBo</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">UserEntity</span> userEntity <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">UserBo</span> userBo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>convert userEntity <span class="token keyword">to</span> <span class="token namespace">userBo<span class="token punctuation">.</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userBo<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserBo</span> <span class="token punctuation">&#123;</span><span class="token comment">//省略其他属性、get/set/construct方法</span>  <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> cellphone<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">////////// Repository+Entity //////////</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserRepository</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name">UserEntity</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserEntity</span> <span class="token punctuation">&#123;</span><span class="token comment">//省略其他属性、get/set/construct方法</span>  <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> cellphone<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。</p><p>UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。<strong>像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）</strong>。</p><p><em>同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</em></p><blockquote><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型正好相反，数据和对应的业务逻辑被封装到同一个类中，因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p></blockquote><h3 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h3><p>主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互，它被大众熟知，还是基于另一个概念的兴起，那就是微服务。</p><blockquote><p>除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。</p></blockquote><p>实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。</p><p>在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。<strong>总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</strong></p><h3 id="为什么贫血模式受欢迎"><a href="#为什么贫血模式受欢迎" class="headerlink" title="为什么贫血模式受欢迎"></a>为什么贫血模式受欢迎</h3><ol><li><p>大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。因为业务比较简单，<strong>即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义</strong>。</p></li><li><p>充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</p></li><li><p>思维已固化，转型有成本。</p></li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="充血模型的-DDD-开发一个虚拟钱包系统"><a href="#充血模型的-DDD-开发一个虚拟钱包系统" class="headerlink" title="充血模型的 DDD 开发一个虚拟钱包系统"></a>充血模型的 DDD 开发一个虚拟钱包系统</h3><p>限定钱包暂时只支持充值、提现、支付、查询余额、查询交易流水这五个核心的功能。</p><p><img src="https://static001.geekbang.org/resource/image/d1/30/d1a9aeb6642404f80a62293ab2e45630.jpg"></p><p>交易流水都需要包含哪些信息？</p><p><img src="https://static001.geekbang.org/resource/image/38/68/38b56bd1981d8b40ececa4d638e4a968.jpg"></p><p>交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualWallet</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Domain领域模型(充血模型)</span>  <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Long</span> createTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">BigDecimal</span> balance <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">VirtualWallet</span><span class="token punctuation">(</span><span class="token class-name">Long</span> preAllocatedId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> preAllocatedId<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">BigDecimal</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">debit</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InsufficientBalanceException</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">credit</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidAmountException</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualWalletService</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 通过构造函数或者IOC框架注入</span>  <span class="token keyword">private</span> <span class="token class-name">VirtualWalletRepository</span> walletRepo<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">VirtualWalletTransactionRepository</span> transactionRepo<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">VirtualWallet</span> <span class="token function">getVirtualWallet</span><span class="token punctuation">(</span><span class="token class-name">Long</span> walletId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">VirtualWalletEntity</span> walletEntity <span class="token operator">=</span> walletRepo<span class="token punctuation">.</span><span class="token function">getWalletEntity</span><span class="token punctuation">(</span>walletId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">VirtualWallet</span> wallet <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>walletEntity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> wallet<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">BigDecimal</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token class-name">Long</span> walletId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> walletRepo<span class="token punctuation">.</span><span class="token function">getBalance</span><span class="token punctuation">(</span>walletId<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Transactional</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">debit</span><span class="token punctuation">(</span><span class="token class-name">Long</span> walletId<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">VirtualWalletEntity</span> walletEntity <span class="token operator">=</span> walletRepo<span class="token punctuation">.</span><span class="token function">getWalletEntity</span><span class="token punctuation">(</span>walletId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">VirtualWallet</span> wallet <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>walletEntity<span class="token punctuation">)</span><span class="token punctuation">;</span>    wallet<span class="token punctuation">.</span><span class="token function">debit</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">VirtualWalletTransactionEntity</span> transactionEntity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VirtualWalletTransactionEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setAmount</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token class-name">TransactionType</span><span class="token punctuation">.</span>DEBIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setFromWalletId</span><span class="token punctuation">(</span>walletId<span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionRepo<span class="token punctuation">.</span><span class="token function">saveTransaction</span><span class="token punctuation">(</span>transactionEntity<span class="token punctuation">)</span><span class="token punctuation">;</span>    walletRepo<span class="token punctuation">.</span><span class="token function">updateBalance</span><span class="token punctuation">(</span>walletId<span class="token punctuation">,</span> wallet<span class="token punctuation">.</span><span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Transactional</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">credit</span><span class="token punctuation">(</span><span class="token class-name">Long</span> walletId<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">VirtualWalletEntity</span> walletEntity <span class="token operator">=</span> walletRepo<span class="token punctuation">.</span><span class="token function">getWalletEntity</span><span class="token punctuation">(</span>walletId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">VirtualWallet</span> wallet <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>walletEntity<span class="token punctuation">)</span><span class="token punctuation">;</span>    wallet<span class="token punctuation">.</span><span class="token function">credit</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">VirtualWalletTransactionEntity</span> transactionEntity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VirtualWalletTransactionEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setAmount</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token class-name">TransactionType</span><span class="token punctuation">.</span>CREDIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionEntity<span class="token punctuation">.</span><span class="token function">setFromWalletId</span><span class="token punctuation">(</span>walletId<span class="token punctuation">)</span><span class="token punctuation">;</span>    transactionRepo<span class="token punctuation">.</span><span class="token function">saveTransaction</span><span class="token punctuation">(</span>transactionEntity<span class="token punctuation">)</span><span class="token punctuation">;</span>    walletRepo<span class="token punctuation">.</span><span class="token function">updateBalance</span><span class="token punctuation">(</span>walletId<span class="token punctuation">,</span> wallet<span class="token punctuation">.</span><span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Transactional</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Long</span> fromWalletId<span class="token punctuation">,</span> <span class="token class-name">Long</span> toWalletId<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...跟基于贫血模型的传统开发模式的代码一样...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，重新来看一下 VirtualWallet 类的实现代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualWallet</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Long</span> createTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">BigDecimal</span> balance <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> isAllowedOverdraft <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">BigDecimal</span> overdraftAmount <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">BigDecimal</span> frozenAmount <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">VirtualWallet</span><span class="token punctuation">(</span><span class="token class-name">Long</span> preAllocatedId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> preAllocatedId<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">freeze</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unfreeze</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increaseOverdraftAmount</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decreaseOverdraftAmount</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">closeOverdraft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">openOverdraft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">BigDecimal</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">BigDecimal</span> <span class="token function">getAvaliableBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BigDecimal</span> totalAvaliableBalance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>frozenAmount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isAllowedOverdraft<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      totalAvaliableBalance <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>overdraftAmount<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> totalAvaliableBalance<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">debit</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BigDecimal</span> totalAvaliableBalance <span class="token operator">=</span> <span class="token function">getAvaliableBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>totoalAvaliableBalance<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InsufficientBalanceException</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">credit</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidAmountException</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>让 service 的实现依赖 VirtualWallet 类，而不是 VirtualWallet 类依赖 service 实现。即 VirtualWallet 类里面只关注<em>业务逻辑</em>，其他与数据库交互、发送邮件、日志记录等等都是放到 service 或者 repository 中进行处理的</strong></p><p>Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？</p><ol><li><p>Service 类负责与 Repository 交流。VirtualWalletService 类负责与 Repository 层打交道，调用 Respository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。</p><blockquote><p>之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，<strong>将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</strong></p></blockquote></li><li><p>Service 类负责跨领域模型的业务聚合功能。VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。</p></li><li><p>Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多用组合少用继承</title>
      <link href="2021/05/27/%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF/"/>
      <url>2021/05/27/%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>继承是面向对象的四大特性之一，用来表示类之间的 is -a 关系，可以解决代码复用问题。但继承层次过深、过复杂，也会影响到代码的可维护性。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>定义一个鸟的类，有些鸟会飞，有些鸟不会飞。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractBird</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//...省略其他属性和方法...</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ostrich</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBird</span> <span class="token punctuation">&#123;</span> <span class="token comment">//鸵鸟</span>  <span class="token comment">//...省略其他属性和方法...</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnSupportedMethodException</span><span class="token punctuation">(</span><span class="token string">"I can't fly.'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于不会飞的鸟来说，都要重写 fly 方法，不够优雅，增加了代码的工作量，也暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p><p>如果通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird：</p><p><img src="https://static001.geekbang.org/resource/image/1e/b7/1e27919f63ef615dba98bc00673914b7.jpg" alt="img">虽然看上去很清晰，但是如果现在还要加上鸟会不会叫，会不会下蛋等等。<strong>类的继承层次会越来越深，继承关系会越来越复杂，会导致代码可读性很差。</strong>这是继承的最大问题。</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>可以利用组组合（composition）、接口、委托（delegation）三个技术手段，来解决刚刚继承存在的问题。</p><p>接口表示具有某种行为特性，“会飞”这样的行为就可以定义一个 Flyable 接口，对于叫、下蛋的行为特性也可以类似的定义 Tweetable 接口、Egglayable 接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Tweetable</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EggLayable</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ostrich</span> <span class="token keyword">implements</span> <span class="token class-name">Tweetable</span><span class="token punctuation">,</span> <span class="token class-name">EggLayable</span> <span class="token punctuation">&#123;</span><span class="token comment">//鸵鸟</span>  <span class="token comment">//... 省略其他属性和方法...</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sparrow</span> impelents <span class="token class-name">Flyable</span><span class="token punctuation">,</span> <span class="token class-name">Tweetable</span><span class="token punctuation">,</span> <span class="token class-name">EggLayable</span> <span class="token punctuation">&#123;</span><span class="token comment">//麻雀</span>  <span class="token comment">//... 省略其他属性和方法...</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样带来的问题就是，每个鸟类的这些实现的方法都需要我们写出来，会带来大量的代码重复。所以我们可以在定义三个实现类：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；<span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyAbility</span> <span class="token keyword">implements</span> <span class="token class-name">Flyable</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//... &#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ostrich</span> <span class="token keyword">implements</span> <span class="token class-name">Tweetable</span><span class="token punctuation">,</span> <span class="token class-name">EggLayable</span> <span class="token punctuation">&#123;</span><span class="token comment">//鸵鸟</span>  <span class="token keyword">private</span> <span class="token class-name">TweetAbility</span> tweetAbility <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TweetAbility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//组合</span>  <span class="token keyword">private</span> <span class="token class-name">EggLayAbility</span> eggLayAbility <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EggLayAbility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//组合</span>  <span class="token comment">//... 省略其他属性和方法...</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    tweetAbility<span class="token punctuation">.</span><span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 委托</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    eggLayAbility<span class="token punctuation">.</span><span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 委托</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承改为组合意味着更细粒度的划分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>不推荐使用继承。</p><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，应该尽量少用甚至不用继承。</p></li><li><p>组合相比继承的优势。</p><p>继承的三个作用（is-a 关系、多态、代码复用）都可以通过组合、接口、委托三个技术手段来达成。利用组合还能解决层次过深、过复杂的继承关系影响代码的可维护性问题。</p></li><li><p>判断组合还是继承</p><p>鼓励多用组合少用继承，但组合也并不是完美的，继承也不是一无是处。使用的时候要根据具体的情况，如果类之间的继承结构稳定，层次比较浅，关系不复杂，就可以大胆地使用继承，反之就尽量使用组合替代继承。</p><blockquote><p>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于接口而非实现</title>
      <link href="2021/05/26/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/05/26/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>Program to an interface,not an implementation.</p><p>接口：接口是一组“协议”或“约定”，是功能提供者提供给使用者的一个“功能列表”。这个原则能有效地提高代码质量，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。</p><p>上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的实现，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><blockquote><p>基于抽象而非实现编程:</p><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</p></blockquote><h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AliyunImageStore</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//...省略属性、构造函数等...</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBucketIfNotExisting</span><span class="token punctuation">(</span><span class="token class-name">String</span> bucketName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...创建bucket代码逻辑...</span>    <span class="token comment">// ...失败会抛出异常..</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...根据accesskey/secrectkey等生成access token</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">uploadToAliyun</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">,</span> <span class="token class-name">String</span> accessToken<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...上传图片到阿里云...</span>    <span class="token comment">//...返回图片存储在阿里云上的地址(url）...</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Image</span> <span class="token function">downloadFromAliyun</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> accessToken<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...从阿里云下载图片...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// AliyunImageStore类的使用举例</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImageProcessingJob</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> BUCKET_NAME <span class="token operator">=</span> <span class="token string">"ai_images_bucket"</span><span class="token punctuation">;</span>  <span class="token comment">//...省略其他无关代码...</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Image</span> image <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment">//处理图片，并封装为Image对象</span>    <span class="token class-name">AliyunImageStore</span> imageStore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AliyunImageStore</span><span class="token punctuation">(</span><span class="token comment">/*省略参数*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    imageStore<span class="token punctuation">.</span><span class="token function">createBucketIfNotExisting</span><span class="token punctuation">(</span>BUCKET_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> accessToken <span class="token operator">=</span> imageStore<span class="token punctuation">.</span><span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    imagestore<span class="token punctuation">.</span><span class="token function">uploadToAliyun</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> BUCKET_NAME<span class="token punctuation">,</span> accessToken<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。</p><p>如果某一天忽然说不要用阿里云了，用自己的私有云。那么需要重新设计一个 PrivateImageStore 类与替换掉项目中所有的 AliyunImageStore 类了，不仅如此，AliyunImageStore 所有 public 方法都要在 PrivateImageStore 重新设计。问题如下：</p><ol><li>AliyunImageStore 类中有些<strong>函数命名暴露了实现细节</strong>，比如，uploadToAliyun() 和 downloadFromAliyun()。这样的方法放到 PrivateImageStore 是极其不合适的，如果要重新命名这两个方法的话，那么也需要将项目中所有用到这写方法的地方全改了。</li><li>存储到阿里云和存储到私有云的流程不一定一致，比如私有云可能就没有获取 access_token 的这一步。所以获取 token 的方法是否要搬到 PrivateImageStore 中，而在上传下载的代码中都有调用这个方法，这里的逻辑也要做调整。</li></ol><p>根据开始说的原则来说，要做到下面几点：</p><ul><li>函数的命名不能暴露任何实现细节。比如 uploadToAliyun()，应该改为更加抽象的命名方式，比如： upload()。</li><li>封装具体的实现细节。和阿里云相关的特殊上传（下载） 流程就不应该暴露给调用者，对流程进行封装，对外提供一个包裹所有上传（下载）细节的方法，给调用者使用。</li><li>为实现类定义抽象的接口，具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li></ul><p>修改代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ImageStore</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">String</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">Image</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AliyunImageStore</span> <span class="token keyword">implements</span> <span class="token class-name">ImageStore</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//...省略属性、构造函数等...</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">createBucketIfNotExisting</span><span class="token punctuation">(</span>bucketName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> accessToken <span class="token operator">=</span> <span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...上传图片到阿里云...</span>    <span class="token comment">//...返回图片在阿里云上的地址(url)...</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">Image</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> accessToken <span class="token operator">=</span> <span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...从阿里云下载图片...</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createBucketIfNotExisting</span><span class="token punctuation">(</span><span class="token class-name">String</span> bucketName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...创建bucket...</span>    <span class="token comment">// ...失败会抛出异常..</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...根据accesskey/secrectkey等生成access token</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 上传下载流程改变：私有云不需要支持access token</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrivateImageStore</span> <span class="token keyword">implements</span> <span class="token class-name">ImageStore</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">createBucketIfNotExisting</span><span class="token punctuation">(</span>bucketName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...上传图片到私有云...</span>    <span class="token comment">//...返回图片的url...</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">Image</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...从私有云下载图片...</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createBucketIfNotExisting</span><span class="token punctuation">(</span><span class="token class-name">String</span> bucketName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...创建bucket...</span>    <span class="token comment">// ...失败会抛出异常..</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// ImageStore的使用举例</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImageProcessingJob</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> BUCKET_NAME <span class="token operator">=</span> <span class="token string">"ai_images_bucket"</span><span class="token punctuation">;</span>  <span class="token comment">//...省略其他无关代码...</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Image</span> image <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token comment">//处理图片，并封装为Image对象</span>    <span class="token class-name">ImageStore</span> imageStore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrivateImageStore</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    imagestore<span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> BUCKET_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切记，不要通过实现类反推接口的定义，可能会导致接口定义不够抽象，依赖具体的实现，没有意义。<strong>一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何是实现细节。接口的定义只表明做什么，而不是怎么做</strong>，要考虑接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p></li><li><p>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</p></li><li><p>“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口与抽象类</title>
      <link href="2021/05/26/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>2021/05/26/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>抽象类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 抽象类</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">Logger</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span> <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>enabled <span class="token operator">=</span> enabled<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>minPermittedLevel <span class="token operator">=</span> minPermittedLevel<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>      <span class="token comment">//需注意这几行的代码，最终对外暴露的方法是log()，log()方法中统一对参数进行检查，已达到代码复用的目的。doLog是抽象方法，在不同的实现类中重写。</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> loggable <span class="token operator">=</span> enabled <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>minPermittedLevel<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> level<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loggable<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">doLog</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doLog</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 抽象类的子类：输出日志到文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileLogger</span> <span class="token keyword">extends</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">Writer</span> fileWriter<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span>    <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">,</span> <span class="token class-name">String</span> filepath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> enabled<span class="token punctuation">,</span> minPermittedLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fileWriter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doLog</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> mesage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 格式化level和message,输出到日志文件</span>    fileWriter<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageQueueLogger</span> <span class="token keyword">extends</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">MessageQueueClient</span> msgQueueClient<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MessageQueueLogger</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span>    <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">,</span> <span class="token class-name">MessageQueueClient</span> msgQueueClient<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> enabled<span class="token punctuation">,</span> minPermittedLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>msgQueueClient <span class="token operator">=</span> msgQueueClient<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doLog</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> mesage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 格式化level和message,输出到消息中间件</span>    msgQueueClient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>抽象类不允许被实例化，只能被继承。</li><li>抽象类可以包含属性和方法，方法及可以包括代码实现，也可以不包括代码实现。不包含代码实现的方法叫做抽象方法。</li><li>子类继承抽象方法，必须实现抽象类中的所有抽象方法。</li></ul><p>接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> req<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 接口实现类：鉴权过滤器</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthencationFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> req<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...鉴权逻辑..</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 接口实现类：限流过滤器</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimitFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> req<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...限流逻辑...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 过滤器使用Demo</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// filters.add(new AuthencationFilter());</span>  <span class="token comment">// filters.add(new RateLimitFilter());</span>  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Filter</span><span class="token punctuation">></span></span> filters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRpcRequest</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> req<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Filter</span> filter <span class="token operator">:</span> filters<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        filter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">RpcException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// ...处理过滤结果...</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ...省略其他处理逻辑...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一般来说，接口不能包含属性（成员变量）。<strong>成员变量默认且只能是public static final的</strong>。</li><li>一般来说，接口只能声明方法，方法不能包含代码实现。<strong>default修饰的方法</strong>是可以有方法实现的，为子类提供默认实现。多实现的情况下<strong>如果父接口中的default方法有重复，则子类必须重写此方法</strong>。</li><li>类实现接口的时候，必须实现接口中声明的所有方法。default 方法除外。</li></ul><p><strong>抽象类只能被子类继承，表示一种 is-a 的关系。接口则表示 has-a 的关系，表示具有某些功能。</strong></p><p>抽象类更多的是为了<strong>代码复用</strong>，而<strong>接口侧重于解耦</strong>，接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p><blockquote><p>基于接口编程而非实现编程</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，现有子类的代码重复，然后在抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><ol><li><p>抽象类和接口的语法特性</p><p>抽象类不允许被实例化，只能被继承，它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫做抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p></li><li><p>抽象类和接口存在的意义</p><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，<strong>是为了解决代码复用问题</strong>。接口是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，<strong>是为了解决解耦问题</strong>，隔离接口和具体的实现，提高代码的扩展性。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配算法</title>
      <link href="2021/05/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>2021/05/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>主串：aaaaaab</p><p>模式串：aab</p><p>最常见的就是 BF 算法（暴力算法）,假设主串的长度是m,模式串的长度是n，那么在这种极端情况下，BF 算法的最坏时间复杂度为 O(mn)</p><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p>相对于逐个字符比较两个字符串，仅比较两个字符串的 hashcode 要容易的多。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3FjZnFrSkFlbG1GWngxUkI0Q3RkVXNBVGdnbWxFNElpYlZVY3hvWk5pYjF0YzZMNkl0NjZoTWliSkhwam9aZFFvazBwbllrbURLSU5uVncvNjQw?x-oss-process=image/format,png"></p><p>生成 hashcode 的算法很多样，比如：</p><ul><li><p>按位相加</p><p>a=&gt;1,b=&gt;2,c=&gt;3 然后把所有的字符串相加，结果就是 hashcode。</p><p>bce = 2+3+5 =10</p><p>算法简单，但是可能产生 hash 冲突，比如 bec,bce,ceb 的 hashcode 是一样的。</p></li><li><p>转换成 26 进制数</p><p>把每一个字符串当成一个 26 进制数来计算</p><p>bce = 2*(26^2) + 3*26 + 5 = 1435</p><p>大幅减少了 hash 冲突，但计算量很大，可能出现超出整型范围的情况，需要的结果进行取模。</p></li></ul><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><blockquote><p>这里先选择按位相加的 hash 算法.</p></blockquote><p>主串通常长于模式串，把整个主串转换成 hashcode 是没有意义的，只有比较<strong>主串当中和模式串等长的子串才有意义</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3FjZnFrSkFlbG1GWngxUkI0Q3RkVXNvOFg1aWNVNGZ2dHQxSzNmT3hUdmdYU0syVGljZ3lFRTZvR0VpYkJlUEgwc0Q2SFZFZ1JoYlNzUUEvNjQw?x-oss-process=image/format,png" alt="图片"></p><p>不匹配就找下一个子串，直到找到下一个hash值相等的子串。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3FjZnFrSkFlbG1GWngxUkI0Q3RkVXNpYnlwUmEyMFFvREc2V3AyUGpvbmpBV3dLUThTU1NpYXFHb0dpYzNBOWg5QkhNcm5yR21EZ0VDQ1EvNjQw?x-oss-process=image/format,png" alt="图片"></p><p>如果找到了，还需要考虑 hash 冲突的场景，所以需要继续比较模式串和子串中的字符（BF 算法）。类似于 HashMap 的冲突，先比较 hashCode，在通过 equals 方法比较。</p><blockquote><p>每次 hash 的时间复杂度为 O(n)，如果全部字串都进行 hash，总的时间复杂度就和 BF 算法一样，都是 O(mn)？</p><p>是的，所以计算子串的 hash 值并不是独立的，从第二个子串开始，每一个子串的 hash 都可以由上一个子串进行简单的增量计算来得到。</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">leetcode<span class="token punctuation">.</span>common<span class="token punctuation">.</span>classic<span class="token punctuation">.</span>string</span><span class="token punctuation">;</span><span class="token comment">/** * RK 算法 * * @author qianxin * @date 2021/05/21 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabinKarp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"aacdesadsdfer"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pattern  <span class="token operator">=</span> <span class="token string">"adsd"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">rabinKarp</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">rabinKarp</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">,</span> <span class="token class-name">String</span> pattern<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> patternHash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> strCode <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>strCode <span class="token operator">==</span> patternHash <span class="token operator">&amp;&amp;</span> <span class="token function">compareString</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> str<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//如果不是最后一轮，更新主串从i到i+n的hash值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">-</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                strCode <span class="token operator">=</span> <span class="token function">nextHash</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> strCode<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> hashcode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            hashcode <span class="token operator">+=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> hashcode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHash</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        hash <span class="token operator">-=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        hash <span class="token operator">+=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">compareString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">String</span> str<span class="token punctuation">,</span> <span class="token class-name">String</span> pattern<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> strSub <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> strSub<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RK 算法计算单个子串的 hash 的时间复杂度是 O(n)，但由于后续的子串 hash 是增量计算，所以总的时间复杂度仍然是 O(n)。</p><p>缺点就是哈希冲突，每一次哈希冲突的时候，RK 算法都要对子串和模式串进行逐个字符的比较，如果冲突太多了，RK 算法就退化成了 BF 算法。</p><h2 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h2><p><strong>坏字符规则</strong>:模式串和子串中不匹配的字符。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3A5M2xaRHZJVWljbWJ2aWFBVXB6SnpvVkx2d2V4WE11YjdtS2dlZGNmZ2xpY1JqaWNmY3duWkdMeXhGZUI5QmY0ODJ0aWFvQnMxMlczT0JYZy82NDA?x-oss-process=image/format,png" alt="img"></p><p>上面的 T 就是坏字符，检测顺序是从后往前检测。</p><blockquote><p>坏字符的位置越靠右，下一轮模式串的挪动跨度就可能越长，节省的比较次数也就越多。这就是BM算法从右向左检测的好处。</p></blockquote><p><strong>只有模式串中和坏字符 T 对齐的位置也是 T 字符的情况下</strong>，两者才有匹配的可能。</p><p>直接把模式串当中的从后往前的上一个字符 T 和主串的坏字符对齐，进行下一轮的比较：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3A5M2xaRHZJVWljbWJ2aWFBVXB6SnpvVm9hZnNtZ1ZBcXdnUVl1SXBaS2liaWFHaWFqNHhXNHkyZnVNVEdramljTWZ6UkFLWWIxeWljNExBSnd3LzY0MA?x-oss-process=image/format,png" alt="img"></p><p>如果坏字符在模式串中不存在的话，那么就需要挪到主串坏字符的下一位：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3A5M2xaRHZJVWljbWJ2aWFBVXB6SnpvVkFmcEdlem9JTUlpY3Z5akd4SzV1NHVSSTNBWmhnZDNpYmdUMmt4ZDZSYzBsNUpmajFpYTJHNkQ4dy82NDA?x-oss-process=image/format,png" alt="img"></p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>坏字符规则下的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bm</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"ABCDCD"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pattern <span class="token operator">=</span> <span class="token string">"CDC"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">boyerMoore</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 在模式串中，查找index下标之前的字符是否和坏字符匹配     *     * @param pattern     * @param badCharacter     * @param index     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findCharacter</span><span class="token punctuation">(</span><span class="token class-name">String</span> pattern<span class="token punctuation">,</span> <span class="token keyword">char</span> badCharacter<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//从后往前找</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> badCharacter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//模式串不存在该字符，返回-1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">boyerMoore</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">,</span> <span class="token class-name">String</span> pattern<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> strLength <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> patternLength <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> strLength <span class="token operator">-</span> patternLength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> i<span class="token punctuation">;</span>            <span class="token comment">//模式传匹配</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> patternLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>start <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">!=</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> start<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//寻找坏字符在模式串中的对应</span>            <span class="token keyword">int</span> charIndex <span class="token operator">=</span> <span class="token function">findCharacter</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>start <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//计算坏字符产生的位移</span>            <span class="token keyword">int</span> bcOffset <span class="token operator">=</span> charIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> i <span class="token operator">-</span> charIndex <span class="token operator">:</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            start <span class="token operator">+=</span> bcOffset<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h3><p>模式串和子串当中相匹配的后缀。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3BJSlVXS0ExU1dVREpKZTJpYUFHWEFqNXJHMlhkUXp3RUVJOXNBaWEwdkI5UDkwU1BCQWljVFA5cmFnbllQWEp2ZTlNY3ZkY0tzRE5SM0EvNjQw?x-oss-process=image/format,png" alt="img"></p><p>如果模式串其他位置也包含与“GCG”相同的片段，那么我们就可以挪动模式串，让这个片段和好后缀对齐，进行下一轮的比较：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3BJSlVXS0ExU1dVREpKZTJpYUFHWEFqVGljMEtTbGtnbkJnY2RpYzlZeVNRNU9OTktQdU9ET3hHNUlON0hxVTV5Q2Fob1plRXZ1RTNTcUEvNjQw?x-oss-process=image/format,png" alt="img"></p><p>在这个例子中，采用好后缀规则能够让模式串向后移动更多位，节省了更多无谓的比较。</p><p><strong>如果模式串中没有好后缀的字符串，应该直接移动到主串的好后缀的下一位？</strong></p><p>不行，要判断一个特殊情况，就是<strong>模式串的前缀是否和好后缀的后缀</strong>的相匹配，以免挪过头了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3BJSlVXS0ExU1dVREpKZTJpYUFHWEFqczNlbFQyOXJaVThpYmwzQ3R2WEd6Z3NNR2NhbUZMSXdIekNpYVBTSGhRMDVEZlZ1UW13aWFzVmtBLzY0MA?x-oss-process=image/format,png" alt="img"></p><blockquote><p>什么时候用坏字符？什么时候用好后缀呢？</p><p>可以在每一轮的字符比较之后，按照话字符和好后缀规则分别计算相应的挪动距离，哪一种距离更长，我们就把模式串挪动对应的长度。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU 缓存淘汰算法</title>
      <link href="2021/05/21/LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
      <url>2021/05/21/LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>LRU(Least Recently Used)缓存淘汰算法是一种常用策略。</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前被缓存在链表中了，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部</li><li>如果此数据没有在缓存链表中：<ul><li>如果此时缓存未满，则将此节点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾节点删除，将新的数据节点插入链表的头部。</li></ul></li></ol><p>不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><h2 id="力扣146LRU缓存机制"><a href="#力扣146LRU缓存机制" class="headerlink" title="力扣146LRU缓存机制"></a>力扣146LRU缓存机制</h2><p>接受一个 capacity 参数作为缓存的最大容量，实现两个 API，一个 put(key,val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。（get、put 方法的时间复杂度为 O(1)）</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ol><li>cache 中的元素必须要有时序，以区分最近使用和久未使用的数据，容量满了后要删除最久未使用的元素。</li><li>要在 cache 中快速找到某个 key 是否存在并且返回对应的 val。</li><li>每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，cache 要支持在<strong>任意位置快速插入和删除元素</strong>。</li></ol><p>哈希表查找快，但数据无固定顺序；链表有顺序之分，插入、删除快，但是查找慢，所以一个新的数据结构：<strong>哈希链表 LinkedHashMap</strong>。</p><blockquote><p>为什么要双向链表？</p><p><strong>双向链表删除节点的时间复杂度为 O(1)。</strong></p><p>哈希表中已经存在了 key 了，为什么链表中还要存 key，只存 val 不行吗？</p><p>删除节点时还要删除哈希表中对应的内容，key 只能从链表的 Node 中拿。</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>节点类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">leetcode<span class="token punctuation">.</span>common<span class="token punctuation">.</span>classic<span class="token punctuation">.</span>lru</span><span class="token punctuation">;</span><span class="token comment">/** * @author qianxin * @date 2021/05/20 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> val<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双链表：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">leetcode<span class="token punctuation">.</span>common<span class="token punctuation">.</span>classic<span class="token punctuation">.</span>lru</span><span class="token punctuation">;</span><span class="token comment">/** * @author qianxin * @date 2021/05/20 * 通过 Node 类型构建一个双链表，实现 LRU 算法的 API * * 实现的双链表 API 从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久未使用的 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleList</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 头尾虚节点     */</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>    <span class="token comment">/**     * 链表长度     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">DoubleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//初始化双向链表的数据</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 在链表尾部添加节点x，时间复杂度为O（1）     *     * @param x 添加的节点     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 删除链表中的 x 节点（x一定存在）     * 由于是双链表且给的是目标节点，时间复杂度为O(1)     *     * @param x 删除的节点     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        x<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 双链表删除链表中的第一个节点，并返回该节点，时间复杂度为O(1)     *     * @return 被删除的节点     */</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Node</span> first <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token function">remove</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> first<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 返回链表长度，时间复杂度为O(1)     *     * @return 链表长度     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LRU类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">leetcode<span class="token punctuation">.</span>common<span class="token punctuation">.</span>classic<span class="token punctuation">.</span>lru</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><span class="token comment">/** * @author qianxin * @date 2021/05/20 * &lt;p> * 双向链表和哈希表结合在一起 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LruCache</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">></span></span> nodeHashMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">DoubleList</span> cache<span class="token punctuation">;</span>    <span class="token comment">/**     * 最大容量     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cap<span class="token punctuation">;</span>    <span class="token comment">/**     * 删除某个 key 的时候却忘记在 map 中删除对应的 key，有效的方法是：在这两种数据结构之伤提供一层抽象的 API     * 避免 get 和 put 直接操作 cache 和 map 的细节     *     * @param capacity     */</span>    <span class="token keyword">public</span> <span class="token class-name">LruCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cap <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nodeHashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 将某个节点变为头节点（最初访问的）     *     * @param key 访问的 key     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">makeRecently</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> x <span class="token operator">=</span> nodeHashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//先删除该节点</span>        cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将该节点重新加入到队尾</span>        cache<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 添加一个新的节点（最近使用元素）     *     * @param key 访问键     * @param val 值     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addRecently</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        nodeHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 删除key     *     * @param key 要删除的 key     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">deleteKey</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> x <span class="token operator">=</span> nodeHashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//移除节点</span>        cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在map中删除</span>        nodeHashMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 移除最久未使用的元素     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeLeaseRecently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//第一个元素就是最久未使用的</span>        <span class="token class-name">Node</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在map中移除</span>        nodeHashMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nodeHashMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">makeRecently</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nodeHashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//如果已经包含了该元素 那么就删除在重新加入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeHashMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">deleteKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cap <span class="token operator">==</span> cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//如果容量满了 需要移除头节点最久未使用的</span>            <span class="token function">removeLeaseRecently</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">addRecently</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="java-内置哈希链表"><a href="#java-内置哈希链表" class="headerlink" title="java 内置哈希链表"></a>java 内置哈希链表</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">leetcode<span class="token punctuation">.</span>common<span class="token punctuation">.</span>classic<span class="token punctuation">.</span>lru</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedHashMap</span><span class="token punctuation">;</span><span class="token comment">/** * @author qianxin * @date 2021/05/21 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashLinkedListLru</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> cap<span class="token punctuation">;</span>    <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">HashLinkedListLru</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cap <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">makeRecently</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> val <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//先移除元素</span>        cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//再添加到尾部</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">makeRecently</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">makeRecently</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//链表头部的元素是最久未使用的</span>            <span class="token keyword">int</span> oldSetKey <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>oldSetKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向过程</title>
      <link href="2021/05/19/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B/"/>
      <url>2021/05/19/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h2><p>违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成面向过程编程风格。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShoppingCart</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> itemsCount<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">double</span> totalPrice<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingCartItem</span><span class="token punctuation">></span></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getItemsCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>itemsCount<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setItemsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> itemsCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>itemsCount <span class="token operator">=</span> itemsCount<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>totalPrice<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTotalPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> totalPrice<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>totalPrice <span class="token operator">=</span> totalPrice<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingCartItem</span><span class="token punctuation">></span></span> <span class="token function">getItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token class-name">ShoppingCartItem</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    itemsCount<span class="token operator">++</span><span class="token punctuation">;</span>    totalPrice <span class="token operator">+=</span> item<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// ...省略其他方法...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>itemsCount 和 totalPrice。虽然我们将它们定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。外部可以通过 setter 方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。</p><blockquote><p>通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p></blockquote><p>items 属性的 getter 方法，返回的是一个 List集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，<code>cart.getItems().clear(); // 清空购物车</code>，清空购物车虽然很合理，但是不应该将清空购物车的业务逻辑暴露给上层代码</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class ShoppingCart &#123;  &#x2F;&#x2F; ...省略其他代码...  public void clear() &#123;    items.clear();    itemsCount &#x3D; 0;    totalPrice &#x3D; 0.0;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要查看购物车，可以通过 Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。</p><h2 id="滥用全局变量和全局方法"><a href="#滥用全局变量和全局方法" class="headerlink" title="滥用全局变量和全局方法"></a>滥用全局变量和全局方法</h2><p>静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。定义一个大而全的 Constants 类，并不是一种很好的设计思路。</p><ol><li><p>影响代码可维护性</p></li><li><p>增加代码的编译时间。</p><p>每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率</p></li><li><p>影响代码的复用性</p><p>另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。</p></li></ol><p>改进方法，当然还是要根据具体业务场景具体处理，不能以一概全：</p><ul><li>将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。</li><li>哪个类用到了某个常量，我们就把这个常量定义到这个类中。提高了类设计的内聚性和代码的复用性。</li></ul><p>只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。</p><blockquote><p>我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计一个过于大而全的 Utils 类。</p></blockquote><h2 id="定义数据和方法分离的类"><a href="#定义数据和方法分离的类" class="headerlink" title="定义数据和方法分离的类"></a>定义数据和方法分离的类</h2><p>定义相应的 VO（View Object）、BO（Business Object）、Entity。一<strong>般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。</strong></p><p>实际上，这种开发模式叫作基于<strong>贫血模型</strong>的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。</p><blockquote><p>面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。</p></blockquote><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出<strong>易维护、易读、易复用、易扩展的高质量代码</strong>。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>滥用 getter、setter 方法</li><li>Constants 类、Utils 类的设计问题</li><li>基于贫血模型的开发模式</li></ol><blockquote><p>“充血模型”相对于“贫血模型”有什么好处？可读性其实可能“贫血模型”还好一点，这也可能有思维惯性的原因在里面。但从灵活和扩展性来说“充血模型”会优秀很多，因为好的“充血模型”往往意味着边界清晰（耦合低），功能内敛（高内聚）。</p><p>想构建优秀的“充血模型”架构，除了要对业务领域和领域设计有足够的认知，在重构手法和重构意愿上还要有一定讲究和追求，这样才能让项目以“充血模型”持续且良性的迭代。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和链表</title>
      <link href="2021/05/17/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"/>
      <url>2021/05/17/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>两种非常基本的数据结构。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一种线性的数据结构，而且在实现上也是用的连续的内存空间，所以<strong>寻址读取数据比较容易，插入和删除比较困难</strong>，插入和删除会变更数组中数据的位置。</p><blockquote><p>是一种<strong>线性表</strong>数据结构。他用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型的数据</strong>。</p></blockquote><p><strong>查询的的时间复杂度为O(1)，插入或删除的时间复杂度为O(N)。</strong></p><blockquote><p>上面的表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1) 。即便是排好序的数组，用二分查找，时间复杂度是O(logn)。正确的表述：，数组是支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p></blockquote><p>在 java 中，ArrayList 底层就是使用的数组。</p><p>ArrayList 最大的优势就是可以将<strong>很多数组操作的细节封装起来</strong>，比如数组插入、删除数据时需要搬移其他数据等。<strong>还有就是支持动态扩容（1.5倍），在创建ArrayList的时候实现指定数据大小</strong>。</p><p>相对于ArrayList容器，数组的优势：</p><ul><li><p>ArrayList 无法存储基本类型，比如int、long，需要封装为 Integer、Long类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p></li><li><p>如果数组大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提高的大部分 API，也可以直接使用数组。</p></li><li><p>当要表示多维数组是，用数组往往会更加直观，比如 Object[][] array;而用容器的话需要这样定义：</p><p>ArrayList&lt;ArrayList&lt;object&gt;&gt;</p></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表的存储并不需要连续的内存空间，因为节点中存储了下一个节点的引用地址，所以当进入删除和插入的时候，只需要改变节点直接的应用即可，但是查询的时候却需要从头节点或者尾节点遍历地去查找。</p><p><strong>查询的时间复杂度为O(N)，插入或删除的时间复杂度为O(1)。</strong></p><ul><li><p>单向链表</p><p><img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="单链表"></p><p>每个节点都包含下一节点的指针。</p><ul><li><p>循环链表</p><p>实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。</p><p><img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" alt="循环链表"></p></li></ul></li><li><p>双向链表</p><p>每个节点都有两个指针，分别指向直接后继和直接前驱。从任意节点开始，都可以很方便的访问它的前驱节点和后继节点，一般构造双向循环链表。<strong>双向链表需要额外的两个空间来存储后继节点和前驱节点，存储同样多的数据，双向链表要比单链表占用更多的内存空间</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="双向链表"></p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。</p><blockquote><p>除此之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p></blockquote><p>java 中的 LinkedList 就是双向链表，通常可以作为栈或队列使用。他也是 Deque(双端队列) 和 Queue（队列）的实现类。</p><p>在使用 Queue 接口的时候，<strong>避免使用 Collection 的 add() 和 remove() 方法，而是使用 offer() 来加入元素和使用 poll() 来获取并移出元素。他们的优点使用过返回值可以判断成功与否，add() 和 remove() 方法在失败的时候会抛出异常。</strong></p><p>而 Deque 接口（继承了 Queue）作为双端队列更强大：可作为队列，FIFO(先进先出)，头进尾出；也可以作为栈，LIFO(后进先出)，头进头出。<strong>目前也是推荐 Deque 来替代 Stack 类。</strong></p></li></ul><p><img src="https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg" alt="复杂度"></p><blockquote><p>数组使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是<strong>只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中</strong>，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。</p><p>对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。</p></blockquote><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>对于单链表来说，即使数据是排好序的，想要查询其中的一个数据，只能从头开始遍历链表，这样效率很低，时间复杂度很高，为O(N)。</p><p>为了解决这个痛点，跳表的数据结构诞生了。</p><blockquote><p>跳表中的数据一定是排好序的。</p></blockquote><p>为链表建立一个索引，这样查找起来更快，如下图所示：</p><p><img src="https://pics3.baidu.com/feed/d009b3de9c82d1587da38b47c003c9dcbc3e4235.png?token=127a19172e91fc6235537cd82de7af6c&s=15B66D338FA879034E7D84CE0300E032" alt="跳表"></p><p>我们要查询红色结点，我们查询的路线即黄线表示出的路径查询，每一级最多遍历两个结点即可。</p><p>跳表的主要应用有 redis 等。主要优点是可以根红黑树，AVL等平衡树一样，做到比较稳定地插入、查询和删除。理论插入查询删除的算法时间复杂度为O(logN)。</p><h2 id="实现-LRU-算法"><a href="#实现-LRU-算法" class="headerlink" title="实现 LRU 算法"></a>实现 LRU 算法</h2><p>常见的策略有三种：先进先出策略FIFO（First in,First out）、最少使用策略 LFU（LEASE Frequently Uesd）、最近最少使用策略 LRU（Lease Recently Used）。</p><p>维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<ul><li>如果此时缓存未满，则将此节点直接插入到链表的头部</li><li>如果此时缓存已满，则将链表尾部的节点删除，将新的数据节点插入链表的头部。</li></ul></li></ol><p>因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><p>如果想优化这个思路的话，可以引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三元运算符的 NPE</title>
      <link href="2021/04/27/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%20NPE/"/>
      <url>2021/04/27/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%20NPE/</url>
      
        <content type="html"><![CDATA[<p>今天上班（摸鱼）的时候，看到了这样一篇博文：</p><p><a href="https://mp.weixin.qq.com/s/iQ6qdNv7WTLa3drxNa9png">https://mp.weixin.qq.com/s/iQ6qdNv7WTLa3drxNa9png</a></p><p>关于三目运算符的 NPE问题，这个问题我还从来没接触过，就研究了一番。</p><p>主要是阿里巴巴Java开发手册发布了最新版，新增了一条规约：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/27/alibaba1.jpg" alt="alibaba1.jpg"></p><p>我们把这个反例代码拿到 <code>IDEA</code> 中研究一下:</p><p>按照以前的想法，觉得得到的 <code>result</code> 结果为 <code>null</code>，但现实是残酷的：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/27/fd703a8560a7fcee6aec31f285ca36ab.png" alt="代码示例1"></p><p>讲真的，完全看代码，我还真不知道这个空指针是在哪个地方报的。</p><p>先不急，慢慢来，将 <code>flag</code> 改为 <code>true</code>，执行结果，代码成功运行结束。<code>result</code> 结果为 2，那么难道是三目运算符第三个参数 <code>c</code> 报的空指针嘛！</p><p>其实那个规约中已经讲的很清楚了，因为自动拆箱导致NPE，那是因为啥导致自动拆箱了呢？其实上面也说了三目运算符自动拆箱的场景：</p><ol><li><strong>表达式一和表达式二只要有一个是原始类型</strong>。</li><li><strong>表达式一和表达式二的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。</strong></li></ol><p>把 <code>flag</code> 改为 <code>flase</code>，我们可以对 <code>class</code> 文件进行 <code>javap -c</code> 查看</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/27/javap.png"></p><p>我理解的 <code>intValue</code> 就应该是自动拆箱了，最后再来查看一下反编译后的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">San</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Integer</span> result <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> c<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一看就很明显了，<code>c.intValue()</code>，空指针就是在这边报出来的。</p><p>将运行代码改一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">Boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>flag <span class="token operator">?</span> i <span class="token operator">:</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>反编译出来：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">San</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Integer</span> result <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">:</span> c<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，并没有出现自动拆箱。</p><p><u>经过测试发现，<code>Integer</code> 类型发生运算时，会导致其自动拆箱，变为基础类型，那么三元表达式中的另外一个参数也会自动拆箱，导致 <code>null</code> 调用方法，产生 <code>NPE</code>。这应该是上面产生 <code>NPE</code> 的原因了。</u></p><p>这也是上面博文中得到的结论：</p><blockquote><p>由于使用了三目运算符，并且第二、第三位操作数分别是基本类型和对象。所以对对象进行拆箱操作，由于该对象为null，所以在拆箱过程中调用null.intValue()的时候就报了NPE。</p></blockquote><p>疑问：博文中举得例子我在运行的时候并没有 <code>NPE</code> 产生。(win10 java version”1.8.0_121”)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Boolean</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>反编译之后</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">San</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Boolean</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实细心的我发现将第二句改为 <code>boolean b = ((map != null) ? map.get(&quot;test&quot;) : false);</code>就会抛出 <code>NPE</code> 了。可能是由于博主笔误了吧。</p><p>再次反编译:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">San</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">)</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个空指针也能理解了，也是由于拆箱导致的 <code>NPE</code>。</p><p>小插曲：boolean作为基础类型是必须给默认值的，否则会编译报错。</p><blockquote><p>时间 2020/5/13 更新</p></blockquote><p>想起之前的一个空指针，mybatis中查出的数据放到一个pojo中，但是表中是没有数据的，按理说查出来的list应该是没有数据的，也就是说长度为0，但是那次报了个空指针，然后找到报错的地方，竟然是一个属性的get方法报出来的，也就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getXxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> xxx<span class="token punctuation">;</span>        <span class="token comment">//这边报了个空指针出来  我差点吐了</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后发现这个get函数的返回类型是基本类型long，但是xxx的类型是Long，当时没仔细去想，把long改为Long，之后就不报空指针了。</p><blockquote><p>现在看来，其实也就是自动拆箱导致的空指针问题！因为表中的没有数据，查出来自然是null，然后自动拆箱，抛出空指针，binggo！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal相关</title>
      <link href="2020/08/12/ThreadLocal%E7%9B%B8%E5%85%B3/"/>
      <url>2020/08/12/ThreadLocal%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>之前使用了一次 ThreadLocal，想着自己能不能看看源码，看看到底底层是怎么做的。</p><p>印象中看过一些博客说是在 ThreadLocal 中会维持一个类似 Map 的东西，里面存储的就是线程 id 和对应线程 set 的值。</p><p>先大致看一下类结构：</p><p>可以看到确实存在一个 ThreadLocalMap 的静态类，该类中又有个内部静态类 Entry，先看一下 Entry的这个类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** The value associated with this ThreadLocal. */</span>    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到内部还是很简单的。（WeakReference 还是要留意的）</p><p>再看 ThreadLocalMap 类，几个关键的属性：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * The table, resized as necessary. * table.length MUST always be a power of two. */</span><span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment">/** * The number of entries in the table. */</span><span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">/** * The next size value at which to resize. */</span><span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment">// Default to 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐约可以看到哈希表的那些苗头了，数组、阈值、大小等等。</p><p>那可以先做一个假设：</p><p><strong>这个 table （entry 数组）就是存放各个线程 set 值的，各个值最终会放到对应 entry 的 value 属性上面。</strong></p><p>看上去挺像一回事儿的。</p><h2 id="具体看代码"><a href="#具体看代码" class="headerlink" title="具体看代码"></a>具体看代码</h2><p>首先先看 set 方法，看看到底做了什么？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//ThreadLocal 类中</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//ThreadLocal 类中</span><span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>   <span class="token comment">//没想到吧!!</span><span class="token punctuation">&#125;</span><span class="token comment">//ThreadLocal 类中</span><span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有点小惊讶，map 竟然是从当前线程里面拿到的。</p><p>而 Thread 类中确实也有着对应的 threadLocals。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Thread 类中</span><span class="token comment">/* ThreadLocal values pertaining to this thread. This map is maintained     * by the ThreadLocal class. */</span><span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，第一次 set 的时候，从当前线程去取这个 threadLocals 肯定为 null，那么接下来就会去走 createMap 方法了，该方法看名字就知道是创建一个 ThreadLocalMap 出来，参数为当前线程和set 的值。最后创建一个 ThreadLocalMap 实例并赋给当前线程的 threadLocals。此时 threadLocals 就不会为空了。看一下构造方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//ThreadLocalMap 类</span><span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">setThreshold</span><span class="token punctuation">(</span>INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>他将当前的 ThreadLocal 对象和 set 的值放到传入到了 Entry 的构造方法去构造一个 Entry 出来。可以看到，我们 set 的值，确实是存到了 Entry 的 value 中，这是不会错的。</p><p>除此之外，还能看到 ThreadLocal 对象会参与到一个哈希计算中，目的其实就是找到该 Entry 在 table 的下标。因为最后 Entry 还是会放到 table 数组中来维护的。</p><p>那如果第二次 set，此时就不会去创建 ThreadLocalMap，而是直接用线程 Thread 里面 threadLocals.set 方法，并传入当前的 ThreadLocal 和 set 的值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//ThreadLocalMap 类</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// We don't use a fast path as with get() because it is at</span>    <span class="token comment">// least as common to use set() to create new entries as</span>    <span class="token comment">// it is to replace existing ones, in which case, a fast</span>    <span class="token comment">// path would fail more often than not.</span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//遍历 table 找到合适的位置i</span>        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//如果已存在就覆盖掉</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//没有的话就去新建并替换掉该 table 中该位置Entry</span>            <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//最后该位置重新给一个新的 entry</span>    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token comment">//清除一些 Slots 必要的话会去重新哈希</span>        <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的内容还是挺多的，但是主要目的了解就行了，具体的哈希算法，包括存放位置 i 的计算等等还是比较复杂的。主要目的就是通过当前的ThreadLocal 对象去找到此次 set 的值的 Entry 应在位于 table 数组的位置。</p><p>接下来看一下 get 方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//ThreadLocal 类</span><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//ThreadLocalMap 类</span><span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Entry</span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大致浏览一下其实也很清楚了，先看一下当前线程中 threadLocals 有没有值，有的话则根据当前的 ThreadLocal 对象去获取 Entry 并返回里面的 value。没有的话则返回 null。</p><p>上面总结的来看的话并回头看看那个假设：</p><p><strong>这个 ThreadLocalMap 其实是由 Thread 也就是当前线程来维护的，并不是 ThreadLocal 来维护的。ThreadLocal 最主要的用处是参与到了哈希位置的计算，也就是 set 的值的 Entry 放在 table 的哪个位置上。</strong></p><p>假设也只是对了一半：这个 table （entry 数组）不是存放<strong>各个线程 set 值的</strong>，存放的是<strong>当前线程不同的 ThreadLocal 对象 set 的值</strong>(下面有代码验证)。值确实是存放在了 Entry 对象的 value 中。</p><ol><li><p>为什么能做到线程间的数据隔离？</p><p>因为数据都是存放在线程自己的 threadLocals (也就是ThreadLocalMap)中，get 也是从自己的 ThreadLocalMap 中 get。</p></li><li><p>既然 set 的值是线程自己维护的，为什么要设计成哈希表的形式（table,entry 数组)？还要做复杂的哈希计算，重新哈希等等，直接用一个 Object 来存放不香吗？</p><p>因为一个线程可能不止使用一个 ThreadLocal，当我有多个值想在线程的上下文使用的时候，就可以使用<strong>多个 ThreadLocal</strong>，即创建多个 ThreadLocal 对象来使用。此时就需要数组来存放这些数据了。<strong>这些对象在代码中也就被视为 key</strong>，用来计算哈希位置，存储和获取 value(set 的值)，这就是通常所说的表现行为类似 Map 结构，但实际上里面得数据结构和 HashMap 的 &lt;k,v&gt; 还是不大一样的。 </p></li></ol><p><img src="http://www.qxnekoo.cn:8888/images/2020/08/13/threadLocal.jpg" alt="threadLocal.jpg"></p><p>测试代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> threadLocal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"threadLocal1对象"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         threadLocal2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">Demo2</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">Thread</span> main <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在两个输出语句那边打上断点，然后就一目了然了：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/08/13/threadLocal_ex1.png" alt="threadLocal_ex1.png"></p><p><img src="http://www.qxnekoo.cn:8888/images/2020/08/13/threadLocal_ex2.png" alt="threadLocal_ex2.png"></p><p><img src="http://www.qxnekoo.cn:8888/images/2020/08/13/threadLocal_ex3.png" alt="threadLocal_ex3.png"></p><p>上面基本就是大致流程和底层的一些原理了，其实内部还是有很多算法的……其实看源代码的话很简单就能看得出原理了，最值钱的还是那些个算法呀！</p><p>下面来看看这个 WeakReference! 这个 Entry 为什么要继承它称为一个弱引用？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">></span></span> appleWeakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> WeakReference 称为弱引用对象，而 apple 称为被弱引用对象，但被弱引用对象只是在这边是弱引用，可能其他地方会有强引用。</p><p>引用一共分为四种：强引用，软引用，弱引用，虚引用。引用强度依次递减。</p><p>在虚拟机部分也介绍过，这边就不一一赘述了，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止，不管当前内存是否足够，都会回收掉弱引用关联的对象。</strong></p><p>一个简单的示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//继承WeakReference 称为一个弱引用对象 用来引用User 对象</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token class-name">User</span> referent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car2</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">User</span> u<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Car2</span><span class="token punctuation">(</span><span class="token class-name">User</span> referent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>u <span class="token operator">=</span> referent<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行类</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">User</span> u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">User</span> u2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Car</span> car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Car2</span> car2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car2</span><span class="token punctuation">(</span>u2<span class="token punctuation">)</span><span class="token punctuation">;</span>    u <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    u2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>car2<span class="token punctuation">.</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">nullnekoo.User@1540e19d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到在强引用 u 和 u2 被置为 null 后，一旦系统发生 gc 被弱引用的对象 u2 便被垃圾收集器回收了，而 u 还是可以获取到的。</p><p>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么应该用 WeakReference 来记住此对象。也就是说这个对象有自己的生命周期，但你不想介入这个对象的生命周期，这时就用弱引用。</p><ol><li><p>为什么要将 entry 继承WeakReference？为什么不使用强引用？</p><p>先想一下如果使用强引用的话，entry 类该怎么写？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** The value associated with this ThreadLocal. */</span>    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>        <span class="token class-name">ThreadLocal</span> key<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        key <span class="token operator">=</span> k<span class="token punctuation">;</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>entry.get() 也就变成了 entry.key 来使用了。这个不是关键，关键是此时 Entry 中有一个强引用（ThreadLocal key）引用着 ThreadLocal 对象，如果 ThreadLocal 我们不再使用了，但是线程的 threadLocals（ThreadLocalMap） 里的 entry 有个强引用，而这个 threadLocals 由于是线程的属性，它的生命周期和线程一样长，也就是说只要线程一直在，这个 ThreadLocal 对象就一直不会被垃圾收集。（值得一提的是，只要线程池不关闭，线程池中的核心线程是不会被结束的）。ThreadLocal 空间一直被占用着无法被释放，可能会导致内存泄漏。</p><p>还有一方面是，一般 ThreadLocal 对象在声明的时候已经有强引用了，当我们想回收该对象，如果此时 entry 里还使用强引用的话，即使断开强引用，垃圾收集器也不会去清理整个对象的。</p></li><li><p>为什么使用了弱引用，还存在内存泄漏的问题？</p><p>entry 对象中，key 是通过弱引用引入的，但是 value 值本身是强引用引入。那就存在一种情况，那就是 key 由于弱引用的关系在 gc 时被回收了，但是 value 还是驻留在线程的 ThreadLocalMap 的 entry 中，导致有值无 key 的 无效entry，内存泄漏。</p><p>虽然如此，但是源码中已经为我们做了很多防止工作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// expunge entry at staleSlot</span>    tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// Rehash until we encounter null</span>    <span class="token class-name">Entry</span> e<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>         i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span>                <span class="token comment">// null because multiple entries could have been stale.</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法作用就是擦除某个下表的 Entry（置为 null，可以回收），同时检测整个 Entry[] 表中对 key 为 null 的 Entry 一并擦除，重新调整索引。</p><p>该方法，在每次调用 ThreadLoca l的 get、set、remove 方法时都会执行，即 ThreadLocal 内部已经帮我们做了对 key 为 null 的 Entry 的清理工作。</p></li><li><p>既然使用弱引用、强引用都会导致内存泄漏，为什么选择使用弱引用而不是强引用？</p><p>弱引用相比强引用，我能想到的唯一好处就是如果用户忘写 remove，弱引用造成的代价会比强引用小的多，毕竟弱引用会自行清理一部分 key，同时 remove 和 get 方法里添加了清除无效 entry的逻辑，避免了引起严重的内存泄漏。</p></li><li><p>声明 ThreadLocal 对象的时候已经给了一个强引用，那么什么时候垃圾收集器会清理这个 ThreadLocal 对象？</p><p>我们手动可以断开这个强引用；obj作为句柄保持着对对象的引用，如果当前线程执行完毕，虚拟机栈被回收，栈中引用的obj句柄被回收，对象没有句柄保持引用，也会被回收。</p></li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>目前我们使用多线程都是通过线程池管理的，对于核心线程数之内的线程都是长期驻留池内的。显式调用 remove，<strong>一方面是防止内存泄漏，最为重要的是，不及时清除有可能导致严重的业务逻辑问题，产生线上故障（使用了上次未清除的值）。</strong>出现异常了也要在 finally 中清除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory 基础设施</title>
      <link href="2020/08/10/BeanFactory%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
      <url>2020/08/10/BeanFactory%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/</url>
      
        <content type="html"><![CDATA[<p>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/08/10/BeanFactory-.png" alt="BeanFactory-.png"></p><p>下面列举一些基础设施：</p><ol><li><p><em>BeanDefinitionRegistry 注册表</em></p><p>Spring 配置文件中的每一个节点元素在 Spring 容器里通过一个 BeanDefinition 对象表示，他描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了<strong>向容器手工注册</strong> BeanDefinition</p><p>对象的方法。</p></li><li><p><em>BeanFactory 顶层接口</em></p><p>位于类结构树的顶端，它最主要的方法就是 getBean(String beanName)，该方法从容器返回特定名称的 Bean，<strong>BeanFactory 的功能通过其他的接口得到不断扩展。</strong></p></li><li><p><em>ListableBeanFactory</em></p><p>该接口定义了访问容器中的 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法。</p></li><li><p><em>HierarchicalBeanFactory 父子级联</em></p><p>父子级联 IOC 容器的接口，子容器可以通过接口方法访问父容器；通过 HierarchicalBeanFactory 接口，Spring 的 IOC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现在 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层的 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</p></li><li><p><em>ConfigurableBeanFactory</em></p><p>增强了 IOC 容器的<strong>可定制性</strong>，定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</p></li><li><p><em>AutowireCapableBeanFactory 自动装配</em></p><p>定义了将容器中的 Bean 按某种规则（如名字匹配、按类型匹配等）进行自动装配的方法。</p></li><li><p><em>SignletonBeanRegistry 运行期间注册单例 Bean</em></p><p>定义了允许在运行期间像容器注册单实例 Bean 的方法，对于单实例（singleton）的 Bean 来说，<strong>BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从 IOC 容器的缓存中获取 Bean实例</strong>。Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，他是一个用 HashMap 实现的缓存器，单实例的 Bean 以 beanName 为键保存在这个 HashMap 中。</p></li><li><p>依赖日志框架</p><p>在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用 Log4J，即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错。</p></li></ol><h2 id="不得不提的-ApplicationContext-面向开发应用"><a href="#不得不提的-ApplicationContext-面向开发应用" class="headerlink" title="不得不提的 ApplicationContext(面向开发应用)"></a>不得不提的 ApplicationContext(面向开发应用)</h2><p>ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。ApplicationContext 继承了HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/08/10/ApplicationContext.png" alt="ApplicationContext.png"></p><ol><li><p>ClassPathXmlApplicationContext: 默认从类路径加载配置文件</p></li><li><p>FileSystemXmlApplicationContext: 默认从文件系统中装在配置文件</p></li><li><p>ApplicationEventPublisher:让容器拥有发布应用上下文事件的功能，包括容器启动、关闭事件。</p></li><li><p>MessageSource:为应用提供 i18n 国际化消息访问的功能</p></li><li><p>ResourcePatternResolver:所有 ApplicationContext 实现类都实现类似于 PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件装载 Spring 的配置文件</p></li><li><p>LifeCycle:该接口是 Spring 2.0 加入的，该接口提供了 start() 和 stop() 两个方法，主要用于异步处理过程，在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现，ApplicationContext 会将 stop/start 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</p></li><li><p>ConfigurableApplicationContext 扩展于 ApplicationContext，他新增加了两个主要的方法：refresh() 和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下使用 refresh() 即可启动应用上下文，在已经启动的状态下，调用 refresh() 则清除缓存并重新装载配置信息，而调用 close() 则可关闭应用上下文。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：对于所有对象都通用的方法</title>
      <link href="2020/08/10/%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>2020/08/10/%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="10-重写-equals-方法时遵守通用约定"><a href="#10-重写-equals-方法时遵守通用约定" class="headerlink" title="10.重写 equals 方法时遵守通用约定"></a>10.重写 equals 方法时遵守通用约定</h2><p>什么时候需要重写 equals 方法呢？</p><p>如果一个类包含一个逻辑相等的概念，此概念有别于对象标识，而且父类还没有重写过 equals 方法。这通常用在值类的情况。</p><blockquote><p>值类只是一个表示值的类，例如 Integer 或 String 类。程序员使用 equals 方法比较值对象的引用，期望它们在逻辑上是否相等，而不是引用相同的对象。不仅如此，还支持重写过 equals 的实例作为 Map 的键(key) ，或者 Set 里的元素，已满足预期和期望的行为。</p></blockquote><p>通用约定：equals 方法实现了一个等价关系，它有以下属性：</p><ul><li>自反性：对于任何非空引用 x，x.equals(x) 必须返回 true。</li><li>对称性：对于任何非空引用 x 和 y，如果且当且仅当 y.equals(x) 返回true时 x.equals(y) 必须返回true。</li><li>传递性：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true。</li><li>一致性：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false。</li><li>对于任何非空引用 x，x.equals(null) 必须返回 false。</li></ul><p>最重要的提醒：</p><ol><li><p>当重写 equals 方法时，同时也要重写 hashCode 方法。</p></li><li><p>不要让 equals 方法试图太聪明。例如，File 类不应该试图将引用的符号连接等同于同一文件对象。</p></li><li><p>在 equals 时方法声明中，不要将参数 Object 替换成其他类型。换了的话就不是重写，而是重载了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//错误示范</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">MyClass</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>总之，除非必须，在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全可能就是想要的。如果确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。</p><h2 id="11-覆盖-equals-时总要覆盖-hashCode"><a href="#11-覆盖-equals-时总要覆盖-hashCode" class="headerlink" title="11.覆盖 equals 时总要覆盖 hashCode"></a>11.覆盖 equals 时总要覆盖 hashCode</h2><p>在每个覆盖 equals 方法的类中，都必须覆盖 hashCode 方法。</p><p>因没有覆盖 hashCode 而违反的关键约定是第二条：相等的对象必须具有相等的散列码（hash code）。 </p><h2 id="12-始终重写-toString-方法"><a href="#12-始终重写-toString-方法" class="headerlink" title="12.始终重写 toString 方法"></a>12.始终重写 toString 方法</h2><p>toString 的通用约定要求，返回的字符串应该是一个简单但内容丰富的表示，对人们来说是很容易阅读的。（建议所有的子类重写这个方法）</p><p>当对象传递到 println、printf、字符串连接操作符或断言，或者由调试器打印时，toString 方法会自动被调用。</p><p>实际上，toString 方法应该返回对象中包含的所有需要关注的信息，如果对象很大或者包含不利于字符串表示的状态，这是不切实际的。这种情况下，toString 应该返回一个摘要。</p><p>除非父类已经这样做了，否则在每个实例化的类中从写 Object 的 toString 实现，它使得类更加舒适地使用和协助调试。toString 方法应该以一种美观的格式返回对象的简明有用的描述。</p><h2 id="13-谨慎地重写-clone-方法"><a href="#13-谨慎地重写-clone-方法" class="headerlink" title="13.谨慎地重写 clone 方法"></a>13.谨慎地重写 clone 方法</h2><p>Cloneable 接口的目的是作为一个 mixin 接口。它主要的缺点是缺少 clone 方法，但他决定了 Object 受保护的 clone 方法实现的行为：如果一个类实现了 Cloneable 接口，那么 Object 的 clone 方法将返回该对象的逐个属性（field-by-field）拷贝；否则会抛出 CloneNotSupportedException 异常。这是一个反常的接口使用，不应该仿效。</p><p><strong>通常，实现一个接口用来表示可以为客户做什么，但是，Cloneable 接口会修改父类上受保护方法（Object 的 clone 方法是受保护的）的行为。</strong></p><p>如果一个 final 类有一个不调用 super.clone 的 clone 方法，那么这个类没有理由实现 Cloneable 接口，因为它不依赖于 Object 的 clone 实现的行为。</p><p>假如希望在一个类中实现 Cloneable 接口，它的父类提供一个行为良好的 clone 方法。</p><p>考虑到与 Cloneable 接口相关的所有问题，新的接口不应该继承他，新的可扩展类不应该实现它。虽然实现 Cloneable 接口对 final 类没有危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的。</p><p>通常，复制功能最好由构造方法或工厂提供，一个明显的例外是数组，它最好用 clone 方法复制。</p><h2 id="14-考虑实现-Comparable-接口"><a href="#14-考虑实现-Comparable-接口" class="headerlink" title="14.考虑实现 Comparable 接口"></a>14.考虑实现 Comparable 接口</h2><p>compareTo 方法并没有在 Object 类中声明，它是 Comparable 中的唯一方法。通过实现 Comparable 接口，一个类表明它的实例有一个自然顺序。</p><p>实现 Comparable 接口，可以让类与所有依赖此接口的通用算法和集合实现进行互操作，几乎 Java 平台所有平台类库中的所有值类以及所有枚举类型都实现了 Comparable 接口。编写具有明显自然顺序（字母顺序，数字顺序或时间顺序）的值类，则应该实现 Comparable 接口。</p><p>考虑到 BigDecimal 类，其 compareTo 方法与 equals 不一致，如果创建一个空的 HashSet 实例，然后添加 new BigDecimal(“1.0”) 和 new BigDecimal(“1.00”)，则该集合将包含两个元素，因为与 equals 方法进行比较时，添加到集合的两个 BigDecimal 实例是不相等的。但是如果使用 TreeSet，则集合只包含一个元素，因为使用 compareTo 方法进行比较时，两个 BigDecimal 实例是相等的。</p><p>在 Java 8 中 Comparator 接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实 现 compareTo 方法，就像 Comparable 接口所要求的那样。 在使用这种方法时，考虑使用 Java 的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> COMPARATOR <span class="token operator">=</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">User</span> u<span class="token punctuation">)</span><span class="token operator">-></span>u<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">User</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> COMPARATOR<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现 Comparable 接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较 compareTo 方法的实现中的字段值时，请避免使用”&lt;”和”&gt;”运算 符。 相反，使用包装类中的静态 compare 方法或 Comparator 接口中的构建方法。</p><h2 id="15-使类和成员的可访问性最小化"><a href="#15-使类和成员的可访问性最小化" class="headerlink" title="15.使类和成员的可访问性最小化"></a>15.使类和成员的可访问性最小化</h2><p>将设计良好的组件与设计不佳的组件区分开来的最重要的因素是，组件将其内部数据和其他组件的其他实现细节隐藏起来。一个设计良好的组件隐藏了它的所有实现细节，干净地将它的 API 与它的实现分离开来。然后组件只通过他们的 API 进行通信，并且对彼此内部的工作一无所知。这称为信息隐藏或封装，是软件设计的基本原则。</p><p>对于顶层（非嵌套的）类和接口，只有两个可能的访问级别：包级私有和公共的。</p><p><strong>通过将其设置为包级私有，可以将其作为实现的一部分，而不是导出的 API</strong>，可以修改、替换、或者在后续的版本中消除它，而不必担心损害现有的客户端。如果把它公开，就有义务永远地支持它，以保持兼容性。</p><p>如果一个包级私有顶级类或接口只被一个类使用，那么可以考虑这个类作为使用它的唯一类的私有静态嵌套类。这将它的可访问性从包级的所有类减少到使用它的一个类。但是，减少不必要的公共类的可访问性要比包级私有的顶级类更重要：公共类是包的 API 的一部分，而包级私有的顶级类已经是这个包实现的一部分了。</p><p>对于成员（属性、方法、嵌套类和嵌套接口），有四种可能访问级别：</p><ul><li>private：该成员只能在声明它的顶级类内访问。</li><li>package-private：成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。</li><li>protected：成员可以从被声明的类的子类中访问，以及它声明的包中的任何类。</li><li>public：该成员可以从任何地方被访问。</li></ul><p>在仔细设计你的类的公共 API 之后，你的反应应该是让所有其他成员设计为私有的。 只有当同一个包中的其他类真的需要访问成员时，需要删除私有修饰符，从而使成员包成为包级私有的。也就是说，私有成员和包级私有成员都是类 实现的一部分，通常不会影响其导出的 API。</p><p>对于公共类的成员，当访问级别从包私有到受保护级时，可访问性会大大增加。受保护的成员是类导出的 API 的一部分，并且必须永远支持。此外，导出类的受保护成员表示对实现细节的公开承诺。对受保护成员的需求应该相对较少。</p><p>总而言之，应该尽可能地减少程序元素的可访问性（在合理访问内）。在仔细设计一个最小化的公共 API 之后，应该防止任何散乱的类，接口或成员称为 API 的一部分。除了作为常量的公共静态属性 final 属性外，公共类不应该有公共属性。确保 public static final 属性引用的对象是不可变的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> effective </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：创建和销毁对象</title>
      <link href="2020/06/27/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/06/27/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ol><li>用静态工厂方法代替构造器</li><li>遇到多个构造器参数时要考虑使用构建器</li><li>用私有构造器或者枚举类型强化 Singleton 属性</li><li>通过私有构造器强化不可实例化的能力</li><li>优先考虑依赖注入来引用资源</li><li>避免创建不必要的对象</li><li>消除过期的对象引用</li><li>避免使用终结方法和清除方法</li><li>try-with-resources 优先于 try-finally</li></ol><h2 id="1-用静态工厂方法代替构造器"><a href="#1-用静态工厂方法代替构造器" class="headerlink" title="1.用静态工厂方法代替构造器"></a>1.用静态工厂方法代替构造器</h2><p>一个类获取实例，最传统的就是通过共有的构造器。除此之外：类可以提供一个共有的<strong>静态工厂方法（static factory metod）</strong>，它只是返回类的实例的静态方法。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span>TRUE <span class="token operator">:</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span>FALSE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>与设计模式中的工厂方法模式不同，不直接对应于设计模式的工厂方法。</p><p>优势：</p><ol><li><p>有名称。当一个类需要多个带有相同签名得构造器时，用静态工厂方法代替构造器，并且仔细选择名称以便突出静态工厂之间的区别。</p></li><li><p>不必在每次调用它们的时候都创建一个新对象。（类似享元模式，用于经常请求创建相同的对象的场景）</p></li><li><p>他们可以返回原返回类型的任何子类型的对象。这样在选择返回对象的类时就有了更大的灵活性。（使用这种静态工厂方法时，甚至要求客户端通过接口来引用被返回的对象，而不是通过它的实现类来引用被返回的对象，这是一种良好的习惯）</p></li><li><p>所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。（只要是已声明的返回类型的子类型，都是允许的）参考 EnumSet，实现类对客户端来说是不可见的，客户端也无需去关心。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">noneOf</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> elementType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> universe <span class="token operator">=</span> <span class="token function">getUniverse</span><span class="token punctuation">(</span>elementType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>universe <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassCastException</span><span class="token punctuation">(</span>elementType <span class="token operator">+</span> <span class="token string">" not an enum"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>universe<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">64</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegularEnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>elementType<span class="token punctuation">,</span> universe<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JumboEnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>elementType<span class="token punctuation">,</span> universe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。比如 服务提供者框架、SPI，在具体的就是 JDBC。</p><blockquote><p>服务提供者框架：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。</p><p>三个重要的组件：服务接口（Service Interface），提供者用来注册实现的。服务访问API（Provider Registration API）,客户端用于获取服务实例，即客户端指定某种选择实现的条件，如果没有，就会返回一个默认的或者允许客户端遍历所有可用的实现。是灵活的“静态工厂”。</p><p>第四个组件就是服务提供者接口(Service Provider Interface)，他是可选的。表示产生服务接口之实例的工厂对象。如果没有服务提供者接口，实现就通过反射的方式进行实例化。</p></blockquote><p>对于 JDBC 来说，Connection 就是服务接口的一部分，DriverManager.registerDriver 是提供者注册 API，DriverManager.getConnection 是服务访问 API，Driver 是服务提供接口。（jdk1.6 后 Java 平台提供了一个通用的服务提供者框架 java.util.ServiceLoader）.</p></li></ol><p>静态工厂方法的惯用名称：</p><ul><li>Date d  = Date.from(instant)</li><li>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK,QUEEN)</li><li>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)</li><li>StackWalker luke = StackWalker.getInstance(options)</li><li>Object newArray = Array.newInstance(classObject,arrayLen)</li><li>FileStore fs = Files.getFileStore(path)</li><li>BufferedReader br = Files.newBufferedReader(path)</li><li>List&lt;Complaint&gt; litany = Collection.list(legacyLitany)</li></ul><h2 id="2-遇到多个构造器参数时要考虑使用构建器"><a href="#2-遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="2.遇到多个构造器参数时要考虑使用构建器"></a>2.遇到多个构造器参数时要考虑使用构建器</h2><p>静态工厂和构造器有个共同的局限性：<strong>不能很好地扩展大量的可选参数</strong>。也就是除了必要的参数，还有很多可选的参数。</p><p>这种类，一般有两种方式：</p><ol><li>重叠构造器：第一个构造器只有必要的参数，第二个构造器有一个可选的参数，第三个构造器有两个可选的参数，以此类推，最后一个构造器包含了所有的可选参数。</li><li>JavaBean 模式：也是用的最多的，先调用一个无参构造器来创建对象，然后再调用 setter 方法来设置必要的参数以及可选的参数。</li></ol><p>第一种方式可行，但当有很多参数的时候，客户端的代码将会很难编写，而且不易阅读。</p><p>第二种方式很简便，但是在构造过程中 JavaBean 可能处于不一致的状态。JavaBeans 模式使得把类做成不可变的可能性不复存在。</p><p>第三种方式：<strong>建造者模式</strong></p><p>他不直接生成想要的对象，而是让<strong>客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个 builder 对象。然后客户端在 builder 对象上调用类似于 setter 的方法，来设置每个相关的可选参数。最后客户端调用无参的 build 方法来生成通常是不可变的对象</strong>。 这个 builder 通常是它构建的类的静态成员类。</p><p>Builder 模式也可以用于类层次结构。抽象类有抽象类的 builder，具体类有具体类的 builder。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">nekoo<span class="token punctuation">.</span>effictive</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">EnumSet</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Objects</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span><span class="token punctuation">;</span><span class="token comment">/** * */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Pizza</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Topping</span> <span class="token punctuation">&#123;</span>HAM<span class="token punctuation">,</span> MUSHROOM<span class="token punctuation">,</span> ONION<span class="token punctuation">,</span> PEPPER<span class="token punctuation">,</span> SAUSAGE<span class="token punctuation">&#125;</span>    <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Topping</span><span class="token punctuation">></span></span> toppings<span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Topping</span><span class="token punctuation">></span></span> toppings <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">noneOf</span><span class="token punctuation">(</span><span class="token class-name">Topping</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">addTopping</span><span class="token punctuation">(</span><span class="token class-name">Topping</span> topping<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            toppings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>topping<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">abstract</span> <span class="token class-name">Pizza</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 子类必须重写这个方法来返回this         *         * @return this         */</span>        <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token class-name">T</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Pizza</span><span class="token punctuation">(</span><span class="token class-name">Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> builder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        toppings <span class="token operator">=</span> builder<span class="token punctuation">.</span>toppings<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">nekoo<span class="token punctuation">.</span>effictive</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Objects</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">nekoo<span class="token punctuation">.</span>effictive<span class="token punctuation">.</span></span><span class="token class-name">Pizza<span class="token punctuation">.</span>Topping</span><span class="token punctuation">.</span>ONION<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NyPizza</span> <span class="token keyword">extends</span> <span class="token class-name">Pizza</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">&#123;</span>SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE<span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Size</span> size<span class="token punctuation">;</span>    <span class="token comment">//带有递归类型的参数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builders</span> <span class="token keyword">extends</span> <span class="token class-name">Pizza<span class="token punctuation">.</span>Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Builders</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Size</span> size<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Builders</span><span class="token punctuation">(</span><span class="token class-name">Size</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token class-name">NyPizza</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NyPizza</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token class-name">Builders</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">NyPizza</span><span class="token punctuation">(</span><span class="token class-name">Builders</span> builder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> builder<span class="token punctuation">.</span>size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">NyPizza</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NyPizza<span class="token punctuation">.</span>Builders</span><span class="token punctuation">(</span><span class="token class-name">Size</span><span class="token punctuation">.</span>SMALL<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTopping</span><span class="token punctuation">(</span>ONION<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>builder 模式也有他自身的不足。为了创建对象，必须先创建它的构建器。而且builder 模式比重叠构造器更加冗长，因此只有在很多参数的时候才会使用。</p><p><strong>如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder 模式就是一种不错的选择。</strong></p><h2 id="3-用私有构造器或者枚举类型强化-Signleton-属性"><a href="#3-用私有构造器或者枚举类型强化-Signleton-属性" class="headerlink" title="3.用私有构造器或者枚举类型强化 Signleton 属性"></a>3.用私有构造器或者枚举类型强化 Signleton 属性</h2><p>实现 Singleton 有两种常见的方法。</p><p>这两个方法都要保持构造器为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。</p><ol><li><p>共有静态成员是个 final 域。（饿汉）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Elvis</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Elvis</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Elvis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Elvis</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但这样的方式有个缺点就是，客户端仍然可以通过反射机制来调用到私有的构造器，比如 AccessibleObject.setAccessible 方法。抵御这种攻击可以修改构造器，让他在要求创建第二个实例的时候抛出异常。</p></li><li><p>公有的成员是个静态工厂方法。（饿汉）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Elvis</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Elvis</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Elvis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Elvis</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Elvis</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的优势在于：公有的静态域是 final的，所以该域总是包含相同的对象引用。还有就是它更简单。还可以通过方法引用作为提供者。Elvis::getInstance 就是一个 Supplier&lt;Elivs&gt;。</p><p>上述两种方式想让类变成可序列化的，仅仅是 implements Serializable 是不够的，还需要提供一个 readResolve 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>第三种方式就是声明一个包含单个元素的枚举类型。</p><p>无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂序列化或者反射攻击的时候也是的。是实现单例模式的最佳实践。这个就不多说了。</p><blockquote><p>如果 Signleton 必须扩展一个超类，而不是扩展 Enum 的时候，就不宜使用这个方法。（虽然可以申明枚举去实现接口）</p></blockquote><blockquote><p>时间： 2020/7/21</p></blockquote><h2 id="4-通过私有构造器强化不可实例化的能力"><a href="#4-通过私有构造器强化不可实例化的能力" class="headerlink" title="4.通过私有构造器强化不可实例化的能力"></a>4.通过私有构造器强化不可实例化的能力</h2><p>有时候可能需要编写只包含静态方法和静态域的类。这样的<strong>工具类</strong>不希望被实例化，因为没有任何意义。</p><p>所以需要将其包含一个私有的构造器，保证不能被实例化。另外，通过将类做成抽象类来强制该类不可被实例化是行不通的。（这样做甚至会误导用户）</p><p>进一步来说，私有的构造器保证了从外部不可以实例化该类，但是还是可以在该类的内部去访问，所以可以在私有的构造器中抛出一个 AsserttionError。</p><h2 id="5-优先考虑依赖注入来引用资源"><a href="#5-优先考虑依赖注入来引用资源" class="headerlink" title="5.优先考虑依赖注入来引用资源"></a>5.优先考虑依赖注入来引用资源</h2><p>许多类会依赖一个或多个底层的资源。可以把类实现为静态工具类（方法和属性都是 static）。也可以将这些类实现为 Singleton 。</p><p>比如，拼写检查器需要依赖词典。静态工具类和 Singleton 类不适于需要引用底层资源的类。</p><p>一种简单的依赖注入形式就是，当创建一个实例时，就将该资源传到构造器中，在创建拼写检查器时就将词典注入其中。</p><p>依赖注入同样适用于构造器、静态工厂和构建器。另一种变体是将资源工厂传给构造器。工厂是可以被重复调用来创建类型实例的一个对象。工厂具体表现为<strong>工厂方法模式</strong>，比如 JAVA8 新增的接口 Supplier&lt;T&gt;，适用于表示工厂。</p><p>总而言之，不要用 Singleton 和静态工厂工具类来实现依赖一个或多个底层资源类，且该资源的行为会影响到该类的行为；也不要直接用这个类来创建这些资源。而应该将这些资源或者工厂传给构造器，通过他们来创建类。</p><h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6.避免创建不必要的对象"></a>6.避免创建不必要的对象</h2><p>对于同时提供静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法而不是构造器，以避免创建不必要的对象。</p><p>比如，Boolean.valueOf(String) 几乎总是优先于构造器 Boolean(String)，Boolean(String)在 Java9 中已经被废弃了。</p><blockquote><p>时间： 2020/7/21</p></blockquote><h2 id="7-消除过期引用的对象引用"><a href="#7-消除过期引用的对象引用" class="headerlink" title="7.消除过期引用的对象引用"></a>7.消除过期引用的对象引用</h2><p>经常在看源码的过程中会看到这样的代码：<code>elements[size] = null;</code>，有点理解不了，因为并不是逻辑上要求它为空，而是突然就给了一个 <code>null</code>。</p><p>但其实这样做的原因，很大一部分程度上为了<strong>消除过期引用的对象引用</strong>，也就是永远都不会被解除的引用，他们不会被 Java 的垃圾收集机制所收集，一但出现问题，很难复现和排查。</p><p>最常见的就是栈。凡是在 elements 数组的“活动部分”之外的任何引用都是过期的。活动部分是指 elements 中下标小于 size 的那些元素。（因为栈是可伸缩的，先增长，然后再收缩，从栈中弹出来的对象将不会被当作垃圾回收，即使栈的程序不在引用这些对象）</p><ol><li>只要类是自己管理内存，程序员就该警惕内存泄露的问题。一旦元素被释放，则该元素中包含的任何对象引用都应该被清空。</li><li>内存泄漏第二个常见的来源是缓存。（WeakHashMap）</li><li>第三个常见的来源是监听器和其他回调。（WeakHashMap）</li></ol><p>内存泄漏通常不会表现明显的失败，所以他们可以在系统中存在很多年，只有通过分析代码或者 Heap 解析工具（Heap Profiler）才能发现内存泄漏问题。</p><h2 id="8-避免使用终结方法和清除方法"><a href="#8-避免使用终结方法和清除方法" class="headerlink" title="8.避免使用终结方法和清除方法"></a>8.避免使用终结方法和清除方法</h2><h2 id="9-try-with-resources-优先于-try-finally"><a href="#9-try-with-resources-优先于-try-finally" class="headerlink" title="9.try-with-resources 优先于 try-finally"></a>9.try-with-resources 优先于 try-finally</h2><p>Java7 引入了 try-with-resources 语句。要使用这个构造的资源，必须先实现 AutoCloseable 接口，其中包含了单个返回 void 的 close 方法。如果编写了一个类，它代表是必须被关闭的资源，那么这个类也应该实现 AutoCloseable。</p><p>在处理必须关闭的资源时，始终要优先考虑用 try-with-resources，而不是用 try-finally。</p>]]></content>
      
      
      
        <tags>
            
            <tag> effective </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS</title>
      <link href="2020/05/09/AQS/"/>
      <url>2020/05/09/AQS/</url>
      
        <content type="html"><![CDATA[<p>首先还是看一下源码中的注释</p><pre class="line-numbers language-none"><code class="language-none">Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.  This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic &#123;@code int state&#125; value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.  Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated &#123;@code int state&#125; value manipulated using methods &#123;@link #getState&#125;, &#123;@link #setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect to synchronization.Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class.  Class &#123;@code AbstractQueuedSynchronizer&#125; does not implement any synchronization interface.  Instead it defines methods such as &#123;@link #acquireInterruptibly&#125; that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods.This class supports either or both a default &lt;em&gt;exclusive&lt;&#x2F;em&gt; mode and a &lt;em&gt;shared&lt;&#x2F;em&gt; mode. When acquired in exclusive mode,attempted acquires by other threads cannot succeed. Shared mode acquires by multiple threads may (but need not) succeed. This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well. Threads waiting in the different modes share the same FIFO queue. Usually, implementation subclasses support only one of these modes, but both can come into play for example in a &#123;@link ReadWriteLock&#125;. Subclasses that support only exclusive or only shared modes need not define the methods supporting the unused mode.This class defines a nested &#123;@link ConditionObject&#125; class that can be used as a &#123;@link Condition&#125; implementation by subclasses supporting exclusive mode for which method &#123;@link  #isHeldExclusively&#125; reports whether synchronization is exclusively held with respect to the current thread, method &#123;@link #release&#125; invoked with the current &#123;@link #getState&#125; value fully releases this object, and &#123;@link #acquire &#125;, given this saved state value,eventually restores this object to its previous acquired state.  No &#123;@code AbstractQueuedSynchronizer&#125; method otherwise creates such a condition, so if this constraint cannot be met, do not use it.  The behavior of &#123;@link ConditionObject&#125; depends of course on the semantics of its synchronizer implementation.This class provides inspection, instrumentation, and monitoring methods for the internal queue, as well as similar methods for condition objects. These can be exported as desired into classes using an &#123;@code AbstractQueuedSynchronizer&#125; for their synchronization mechanics.Serialization of this class stores only the underlying atomic integer maintaining state, so deserialized objects have empty thread queues. Typical subclasses requiring serializability will define a &#123;@code readObject&#125; method that restores this to a known initial state upon deserialization.  Usage To use this class as the basis of a synchronizer, redefine the following methods, as applicable, by inspecting and&#x2F;or modifying the synchronization state using &#123;@link #getState&#125;, &#123;@link #setState&#125; and&#x2F;or &#123;@link #compareAndSetState&#125;:    &#123;@link #tryAcquire&#125;  &#123;@link #tryRelease&#125;  &#123;@link #tryAcquireShared&#125;  &#123;@link #tryReleaseShared&#125;  &#123;@link #isHeldExclusively&#125;  Each of these methods by default throws &#123;@link UnsupportedOperationException&#125;.  Implementations of these methods must be internally thread-safe, and should in general be short and not block. Defining these methods is the &lt;em&gt;only&lt;&#x2F;em&gt; supported means of using this class. All other methods are declared &#123;@code final&#125; because they cannot be independently varied.You may also find the inherited methods from &#123;@link AbstractOwnableSynchronizer&#125; useful to keep track of the thread owning an exclusive synchronizer.  You are encouraged to use them -- this enables monitoring and diagnostic tools to assist users in determining which threads hold locks.Even though this class is based on an internal FIFO queue, it does not automatically enforce FIFO acquisition policies.  The core of exclusive synchronization takes the form:  * Acquire: *     while (!tryAcquire(arg)) &#123; *        &lt;em&gt;enqueue thread if it is not already queued&lt;&#x2F;em&gt;; *        &lt;em&gt;possibly block current thread&lt;&#x2F;em&gt;; *     &#125; * * Release: *     if (tryRelease(arg)) *        &lt;em&gt;unblock the first queued thread&lt;&#x2F;em&gt;;(Shared mode is similar but may involve cascading signals.)Because checks in acquire are invoked before enqueuing, a newly acquiring thread may barge ahead of others that are blocked and queued.  However, you can, if desired,define &#123;@code tryAcquire&#125; and&#x2F;or &#123;@code tryAcquireShared&#125; to disable barging by internally invoking one or more of the inspection methods, thereby providing a fair FIFO acquisition order.In particular, most fair synchronizers can define &#123;@code tryAcquire&#125; to return &#123;@code false&#125; if &#123;@link #hasQueuedPredecessors&#125; (a method specifically designed to be used by fair synchronizers) returns &#123;@code true&#125;.  Other variations are possible.Throughput and scalability are generally highest for the default barging (also known as greedy,renouncement, and convoy-avoidance) strategy. While this is not guaranteed to be fair or starvation-free, earlier queued threads are allowed to recontend before later queued threads, and each recontention has an unbiased chance to succeed against incoming threads.  Also, while acquires do not &quot;spin&quot; in the usual sense, they may perform multiple invocations of &#123;@code tryAcquire&#125; interspersed with other computations before blocking.  This gives most of the benefits of spins when exclusive synchronization is only briefly held, without most of the liabilities when it isn&#39;t. If so desired, you can augment this by preceding calls to acquire methods with &quot;fast-path&quot; checks, possibly prechecking &#123;@link #hasContended&#125; and&#x2F;or &#123;@link #hasQueuedThreads&#125; to only do so if the synchronizer is likely not to be contended.This class provides an efficient and scalable basis for synchronization in part by specializing its range of use to synchronizers that can rely on &#123;@code int&#125; state, acquire, and release parameters, and an internal FIFO wait queue. When this does not suffice, you can build synchronizers from a lower level using &#123;@link java.util.concurrent.atomic atomic&#125; classes, your own custom &#123;@link java.util.Queue&#125; classes, and &#123;@link LockSupport&#125; blocking support.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中文（之后会对翻译不好的地方手动翻译一下）</p><pre class="line-numbers language-none"><code class="language-none">提供一个框架，用于实现依赖于先进先出（FIFO）等待队列的阻塞锁和相关的同步器（信号灯，事件等）。此类旨在为大多数依赖单个原子&#123;@code int state&#125;值表示状态的同步器提供有用的基础。子类必须定义更改此状态的受保护方法，并定义该状态对于获取或释放此对象而言意味着什么。鉴于这些，此类中的其他方法将执行所有排队和阻塞机制。子类可以维护其他状态字段，但是仅跟踪关于同步的使用方法&#123;@link #getState&#125;，&#123;@ link #setState&#125;和&#123;@link #compareAndSetState&#125;操作的原子更新的&#123;@code int state&#125;值。子类应该定义为用于实现其封闭类的同步属性的非公共内部帮助器类。类&#123;@code AbstractQueuedSynchronizer&#125;没有实现任何同步接口。相反，它定义了&#123;@link #acquireInterruptible&#125;之类的方法，可以通过具体的锁和相关的同步器适当地调用这些方法来实现其公共方法。此类支持默认排他模式和共享模式之一或两者。当以独占模式进行获取时，其他线程尝试进行的获取将无法成功。由多个线程获取的共享模式可能（但不一定）成功。该类不理解这些差异，只是从机械意义上说，当成功获取共享模式时，下一个等待线程（如果存在）也必须确定它是否也可以获取。在不同模式下等待的线程共享相同的FIFO队列。通常，实现子类仅支持这些模式之一，但例如可以在&#123;@link ReadWriteLock&#125;中发挥作用。仅支持互斥模式或仅支持共享模式的子类无需定义支持未使用模式的方法。此类定义了一个嵌套的&#123;@link ConditionObject&#125;类，该类可以被支持独占模式的子类用作&#123;@link Condition&#125;实现，为此方法&#123;@link #isHeldExclusively&#125;报告是否针对当前线程专有地保持同步，使用当前&#123;@link #getState&#125;值调用的方法&#123;@link #release&#125;会完全释放此对象，并且给定已保存的状态值，&#123;@ link #acquire&#125;最终会将此对象恢复为其先前获取的状态。否则，没有&#123;@code AbstractQueuedSynchronizer&#125;方法会创建这样的条件，因此，如果无法满足此约束，请不要使用它。 &#123;@link ConditionObject&#125;的行为当然取决于其同步器实现的语义。此类提供了内部队列的检查，检测和监视方法，以及条件对象的类似方法。可以根据需要使用&#123;@code AbstractQueuedSynchronizer&#125;将它们导出到类中以实现其同步机制。此类的序列化仅存储基础原子整数维护状态，因此反序列化的对象具有空线程队列。需要可序列化的典型子类将定义一个&#123;@code readObject&#125;方法，该方法可在反序列化时将其恢复为已知的初始状态。 用法 要将此类用作同步器的基础，请使用&#123;@link #getState&#125;，&#123;@ link #setState&#125;和&#x2F;或&#123;@link #compareAndSetState检查和&#x2F;或修改同步状态，重新定义以下方法（如适用） &#125;：  &#123;@link #tryAcquire&#125;  &#123;@link #tryRelease&#125;  &#123;@link #tryAcquireShared&#125;  &#123;@link #tryReleaseShared&#125;  &#123;@link #isHeldExclusively&#125;默认情况下，这些方法中的每一个都会引发&#123;@link UnsupportedOperationException&#125;。这些方法的实现必须在内部是线程安全的，并且通常应简短且不阻塞。定义这些方法是&lt;em&gt; only &lt;&#x2F; em&gt;支持的使用此类的方法。所有其他方法都声明为&#123;@code final&#125;，因为它们不能独立变化。您可能还会发现从&#123;@link AbstractOwnableSynchronizer&#125;继承的方法对于跟踪拥有独占同步器的线程很有用。鼓励您使用它们-这将启用监视和诊断工具，以帮助用户确定哪些线程持有锁。即使此类基于内部FIFO队列，它也不会自动执行FIFO获取策略。独占同步的核心采取以下形式： * Acquire: *     while (!tryAcquire(arg)) &#123; *        &lt;em&gt;如果线程尚未进行排队，则对其进行排队&lt;&#x2F;em&gt;; *        &lt;em&gt;可能阻塞当前线程&lt;&#x2F;em&gt;; *     &#125; * * Release: *     if (tryRelease(arg)) *        &lt;em&gt;解除第一个排队线程的阻塞&lt;&#x2F;em&gt;;  （共享模式相似，但可能涉及级联信号。）因为获取队列中的获取检查是在排队之前被调用的，所以新获取线程可能会在其他被阻塞和排队的线程之前进行插入。但是，如果需要，您可以定义&#123;@code tryAcquire&#125;和&#x2F;或&#123;@code tryAcquireShared&#125;以通过内部调用一种或多种检查方法来禁用插入，从而提供公平的FIFO获取顺序。尤其是大多数公平的同步器如果&#123;@link #hasQueuedPredecessors&#125;（一种专门设计用于公平同步器的方法）返回&#123;@code true&#125;，则可以定义&#123;@code tryAcquire&#125;以返回&#123;@code false&#125;。其他变化也是可能的。对于默认插入（也称为贪婪，放弃和避免通信）策略，吞吐量和可伸缩性通常最高。尽管不能保证这是公平的，也不会出现饥饿现象，但是可以让较早排队的线程在较晚排队的线程之前进行重新竞争，并且每个重新争用都可以毫无偏向地成功抵御传入线程。同样，尽管获取不是通常意义上的旋转，但它们可能会在阻塞之前执行&#123;@code tryAcquire&#125;的多次调用，并插入其他计算。当仅短暂地保持排他同步时，这将提供旋转的大部分好处，而在不进行排他同步时，则不会带来很多负担。如果需要的话，您可以通过在调用之前对获取方法进行“快速路径”检查来增强此功能，可能会预先检查&#123;@link #hasContended&#125;和&#x2F;或&#123;@link #hasQueuedThreads&#125;以仅在同步器可能不这样做的情况下这样做争辩。这个类为同步提供了一个有效的和可扩展的基础，部分是通过将它的使用范围专门化为同步器，这些同步器可以依赖于&#123;@code int&#125;state、获取和释放参数，以及一个内部FIFO等待队列。当这还不够时，您可以使用&#123;@link java.util.concurrent从较低的层次构建同步器。原子原子&#125;类，您自己的自定义&#123;@link java.util。队列&#125;类和&#123;@link LockSupport&#125;阻塞支持。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下：</p><p>全称：<code>AbstractQueuedSynchronizer</code> 抽象的队列式同步器（抽象类）。值得注意的是它使用的是**<u>模板方法模式的设计模式</u>**。搞清楚它的设计模式对理解它的源代码很有帮助。</p><blockquote><p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：<br>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p></blockquote><p><strong><code>AQS</code> 的核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 <code>AQS</code> 是用 <code>CLH</code> 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br><code>CLH（Craig，Landin，and Hagersten）</code>队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong><code>AQS</code> 是将每一条请求共享资源的线程封装成一个 <code>CLH</code> 锁队列的一个结点（<code>Node</code>），来实现锁的分配。</strong></p><p>用大白话来说，<code>AQS</code> 就是基于 <code>CLH</code> 队列，用 <code>volatile</code> 修饰共享变量 <code>state</code>，线程通过 <code>CAS</code>去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p><p><strong>自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是 <code>AQS</code> 的衍生物</strong></p><p>从使用层面上来说有两种功能：独占和共享</p><ul><li>独占锁，每次只能有一个线程持有锁， <code>ReentrantLock</code> 就是以独占方式实现的互斥锁。</li><li>共享锁，允许多个线程同时获取锁，并发访问共享资源，比如 <code>ReentrantReadWriteLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReadWriteLock</code>、<code>CyclicBarrier</code>。</li></ul><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>这边简单介绍下：</p><p><u>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</u></p><p><strong>通过定义一个算法骨架，而将算法中的步骤延迟到子类，这样子类就可以复写这些步骤的实现来实现特定的算法。</strong></p><p>是类的一种行为，只需要准备一个抽象类，将逻辑用具体方法和构造函数的形式来表现，<strong>后声明一些抽象方法来迫使子类必须实现其逻辑</strong>，不同的子类可以实现不同的方法，从而可以让剩余的逻辑有不同的实现。即可以定义抽象的方法，让子类实现剩余的逻辑。</p><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Game</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">startPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">endPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//模板 算法骨架 子类也无法重写其算法逻辑 但是具体方法的逻辑可以交给子类重写</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">startPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">endPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>子类 <code>Cricket</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cricket</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">&#123;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">void</span> <span class="token function">endPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cricket Game Finished!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cricket Game Initialized! Start playing."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">void</span> <span class="token function">startPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cricket Game Started. Enjoy the game!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Clicket</span>  c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Clicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比如源码中的acquire方法（模板方法）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，这个方法是 <code>final</code>，也就是说这个方法是不会被子类重写的，再看看tryAcquire()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虽然这个方法不是 <code>abstract</code> 的，但是也能很清楚的知道，该方法需要被子类重写逻辑，方法里面的逻辑可以由各个子类来重写自己的逻辑，但方法的调用逻辑是由父类这边来操控的。</p><p><code>acquire</code> 这个方法的主要逻辑是</p><ul><li>通过 <code>tryAcquire</code> 尝试获取独占锁，如果成功返回 <code>true</code>，失败返回 <code>false</code></li><li>如果 <code>tryAcquire</code> 失败，则会通过 <code>addWaiter</code> 方法将当前线程封装成 <code>Node</code> 添加到 <code>AQS</code> 队列尾部</li><li><code>acquireQueued</code>，将 <code>Node</code> 作为参数，通过自旋去尝试获取锁。</li></ul><h2 id="回到同步器"><a href="#回到同步器" class="headerlink" title="回到同步器"></a>回到同步器</h2><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中需要修改同步状态，于是有 3 个方法: <code>getState()、setState(int newState)、compareAndSetState(int expect,int update)</code>。</p><blockquote><p>getState():获取当前同步状态</p><p>setState(int newState):设置当前同步状态</p><p>compareAndSetState(int expect,int update):使用 CAS 设置当前状态，该方法能保证状态设置的原子性</p></blockquote><ul><li><p>和锁之间的关系</p><p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p><p><strong>锁是面向使用者的</strong>，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问）,隐藏了实现细节；<strong>同步器面向的是锁的实现者</strong>，他简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待于唤醒等底层操作。缩合同步器很好地隔离了使用者和实现者所需关注的领域。</p></li></ul><p>同步器中可重写的方法：</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">protected boolean trtAcquire(int arg)</td><td align="center">独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行 CAS 设置同步状态</td></tr><tr><td align="center">protected boolean tryRelease(int arg)</td><td align="center">独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td align="center">protected int tryAcquireShared(int arg)</td><td align="center">共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败</td></tr><tr><td align="center">protected boolean tryReleaseShared(int arg)</td><td align="center">共享式释放同步状态</td></tr><tr><td align="center">protected boolean isHeldExclusively()</td><td align="center">当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所占</td></tr></tbody></table><p>下面是同步器的模板方法：</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">final void acquire(int arg)</td><td align="center">独占式获取同步状态，如果当前线程获取同步状态成功，则改由该方法返回，否则，还将会进入同步队列等待，该方法会调用重写的 tryAcquire(int arg) 方法</td></tr><tr><td align="center">final void acquireInterruptibly(int arg)</td><td align="center">与 acquire 相同，当时该方法响应中断，当前线程未获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出 InterruptedException 并返回</td></tr><tr><td align="center">final boolean tryAcquireNanos(int arg,long nanos)</td><td align="center">在 acquireinterruptibly 基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么会返回 false，如果获取到了返回 true</td></tr><tr><td align="center">final void acquireShared(int arg)</td><td align="center">共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td></tr><tr><td align="center">final void acquireSharedInterruptibly(int arg)</td><td align="center">与 acquireShared 相同，该方法响应中断</td></tr><tr><td align="center">final boolean tryAcquireSharedNanos(int arg,long nanos)</td><td align="center">在 acquireSharedInterruptibly基础上增加了超时限制</td></tr><tr><td align="center">final boolean release(int arg)</td><td align="center">独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td></tr><tr><td align="center">final boolean releaseShared(int arg)</td><td align="center">共享式的释放同步状态</td></tr><tr><td align="center">final Collection&lt;Thread&gt; getQueuedThreads()</td><td align="center">获取等待在同步队列上的线程集合</td></tr></tbody></table><p>模板方法基本分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态、查询同步队列中的等待线程状况。</p><h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。。</p><blockquote><p>节点用来保存获取同步状态失败的线程引用、等待状态记忆前驱和后继节点。</p></blockquote><p><img src="http://www.qxnekoo.cn:8888/images/2020/05/11/AQS_QUEUE.png" alt="AQS_QUEUE.png"></p><p>获取锁的流程：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/05/11/AQS_PROCEDURE.png" alt="AQS_PROCEDURE.png"></p><p>下面举几个例子吧，首先是 <code>Mutex</code>，这个也是源码注释中的一个例子：</p><blockquote><p>这是一个不可重入的互斥锁类，它使用值0表示解锁状态，使用值1表示锁定状态。虽然非重入锁并不严格要求记录当前所有者线程，但是这个类这样做是为了使使用更容易监控。它还支持 condition，并公开其中一种instrumentation 的方法:</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//同步器 使用内部静态类</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> release<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>            s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一个可共享的例子(同时只能有两个线程能够获得锁)：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TwinsLock</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//return super.tryAcquireShared(arg);</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> newState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> arg<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newState <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> newState<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//return super.tryReleaseShared(arg);</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> newState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> arg<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Sync</span> sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AQS</code> 的内容确实复杂难懂，尤其是源码，以后再来补充吧。(目前我知道的是 tryAcquire 和 tryRelease 返回 true是代表抢占成功、释放成功。还不知道对不对)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI</title>
      <link href="2020/05/02/SPI/"/>
      <url>2020/05/02/SPI/</url>
      
        <content type="html"><![CDATA[<p>全称 <code>Service Provider Interface</code>，是 <code>jdk</code> 内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如 <code>java.sql.Driver</code> 接口，其他不同厂商可以针对同一接口做出不同的实现，<code>MySQL</code> 和 <code>PostgreSQL</code> 都有不同的实现提供给用户，而 <code>Java</code> 的 <code>SPI</code> 机制可以为某个接口寻找服务实现。<code>Java</code> 中 <code>SPI</code> 机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p><p>SPI 与 API 区别：</p><ul><li>API 是调用并用于实现目标的类、接口、方法等的描述；</li><li>SPI 是扩展和实现以实现目标的类、接口、方法等的描述；</li></ul><p>换句话说，API 为操作提供特定的类、方法，SPI 通过操作来符合特定的类、方法。</p><p>机制如下：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/05/12/SPI.png" alt="SPI"></p><p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p><p>系统设计的各个抽象，往往有很多不同的实现方案，在面向对象的设计里，一般推荐模块之间基于接口编程，模块之间步对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就是需要一种服务发现机制。</p><p>Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li><p>数据库驱动加载接口实现类的加载<br> JDBC 加载不同类型数据库的驱动</p></li><li><p>日志门面接口实现类加载<br> SLF4J 加载不同提供商的日志实现类</p></li><li><p>Spring<br> Spring 中大量使用了 SPI,比如：对 servlet3.0 规范对 ServletContainerInitializer 的实现、自动类型转换 Type Conversion SPI(Converter SPI、Formatter SPI) 等 </p></li><li><p>Dubbo<br> Dubbo 中也大量使用 SPI 的方式实现框架的扩展, 不过它对 Java 提供的原生 SPI 做了封装，允许用户扩展实现 Filter 接口</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1、当服务提供者提供了接口的一种具体实现后，在 jar 包的 META-INF/services 目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</p><p>2、接口实现类所在的 jar 包放在主程序的 classpath 中；</p><p>3、主程序通过 java.util.ServiceLoder 动态装载实现模块，它通过扫描 META-INF/services 目录下的配置文件找到实现类的全限定名，把类加载到 JVM；</p><p>4、SPI 的实现类必须携带一个不带参数的构造方法。<strong>（因为要通过反射获取到实例对象）</strong></p><p>新建一个 maven 项目，目录结构</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/05/12/SPI_ex1.png" alt="SPI_ex1"></p><p>默认 maven 的compile level 为5，在pom中改一下，添加</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码很简单，大概浏览一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//IShout.java</span><span class="token keyword">package</span> <span class="token namespace">foo</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IShout</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Cat.java</span><span class="token keyword">package</span> <span class="token namespace">foo<span class="token punctuation">.</span>impl</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">foo<span class="token punctuation">.</span></span><span class="token class-name">IShout</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">IShout</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"miao miao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//Dog.java</span><span class="token keyword">package</span> <span class="token namespace">foo<span class="token punctuation">.</span>impl</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">foo<span class="token punctuation">.</span></span><span class="token class-name">IShout</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">IShout</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"wang wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//主类</span><span class="token keyword">package</span> <span class="token namespace">foo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ServiceLoader</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SPIMain</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IShout</span><span class="token punctuation">></span></span> shouts <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">IShout</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">IShout</span> s<span class="token operator">:</span>shouts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            s<span class="token punctuation">.</span><span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>META-INF目录是自己新建的，为什么必须是这个文件夹，因为是源码里面写死的：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/05/12/SERVICE_LOADER_SPI.png" alt="SERVICE_LOADER_SPI"></p><p>里面有一个以“接口全限定名”为命名的文件，内容为实现类的全限定名：</p><pre class="line-numbers language-none"><code class="language-none">foo.impl.Catfoo.impl.Dog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">miao miaowang wang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点</strong>：<br> 使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过**Class.forName(“com.mysql.jdbc.Driver”)**，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类</p><p><strong>缺点</strong>：</p><ul><li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li></ul><p>针对以上的不足点，我们在SPI机制选择时，可以考虑使用dubbo实现的SPI机制。</p><blockquote><p>具体参考: </p><p><a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html</a></p><p>其他参考文章: </p><p><a href="http://www.spring4all.com/article/260">http://www.spring4all.com/article/260</a></p><p><a href="https://blog.csdn.net/yangguosb/article/details/78772730">https://blog.csdn.net/yangguosb/article/details/78772730</a></p><p><a href="https://www.jianshu.com/p/46b42f7f593c">https://www.jianshu.com/p/46b42f7f593c</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 扩容时是否会重新 hash</title>
      <link href="2020/04/29/HashMap%E6%89%A9%E5%AE%B9%E6%97%B6%E6%98%AF%E5%90%A6hash/"/>
      <url>2020/04/29/HashMap%E6%89%A9%E5%AE%B9%E6%97%B6%E6%98%AF%E5%90%A6hash/</url>
      
        <content type="html"><![CDATA[<p>看面试题遇到的一个问题，扩容是是否会重新 <code>hash()</code>?</p><p>第一反应是 <code>jdk7</code> 会，<code>jdk8</code> 不会，因为印象中大学的时候研究过一次，还去找了当时的记录：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/college_hashMap.png" alt="college_hashMap.png"></p><p>这里再次研究下具体原理吧!先看一些运算符，每次看到这些运算符都不记得它们的作用，尴尬!</p><p>A = 0011 1100 =&gt; 60</p><p>B = 0000 1101 =&gt; 13</p><hr><table><thead><tr><th>操作符</th><th>描述</th><th align="left">例子</th></tr></thead><tbody><tr><td>&amp; 按位与运算符</td><td>如果相对应位都是1，则结果为1，否则为0</td><td align="left">（A&amp;B），得到12，即0000 110</td></tr><tr><td>&#x7C; 按位或运算符</td><td>如果相对应位都是0，则结果为0，否则为1</td><td align="left">（AlB），得到61，即0011 1101</td></tr><tr><td>^ 异或运算符</td><td>如果相对应位值相同，则结果为0，否则为1</td><td align="left">（A^B），得到49，即0011 0001</td></tr><tr><td>~ 取反运算符</td><td>按位取反运算符，翻转操作数的每一位，即0变成1,1变成0</td><td align="left">（~A）得到-61，即11100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数                  A&lt;&lt;n 相等于A乘以2的n次幂。</td><td align="left">A&lt;&lt;2得到240，即1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数                      A&gt;&gt;n相等于A除以2的n次幂</td><td align="left">A&gt;&gt;2得到15，即1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><p>首先找到计算哈希桶位置代码，也不难找，具体如下（jdk8）:</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/hash.png" alt="hash.png"></p><p>这个是具体的 <code>hash()</code> 方法，还是很好找的，不过计算哈希桶位置的代码在 <code>jdk8</code> 中变了，但是 <code>put()</code> 方法中肯定会调用的，接着往下找就好了，</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/compute_buket.png" alt="compute_buket.png"></p><p>计算数组的位置，其实也就是哈希桶的位置了。下面针对这两个方法研究：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token string">"nekooaa"</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" hashCode值 h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//h>>>16   这里前面加上16个零，主要是为了对齐，方便我们肉眼观察</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"0000000000000000"</span><span class="token operator">+</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" h>>>16"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//h ^ h >>> 16</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" h ^ h >>> 16 这个值会赋给hash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// length-1 &amp; hash  supplement函数的作用也是为了对齐</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">supplement</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">" length-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" length-1 &amp; hash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码其实很简单，挑一个字符串的字符串，<code>HashMap</code> 的哈希桶个数我就使用默认的 16 来测试，通过计算来得到这个字符串如果放到 <code>HashMap</code> 中的具体位置。运行一下看看结果：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/result_hash.png" alt="result_hash.png"></p><p>也就是说，16 个哈希桶，使用这个字符串，将会放到第 10 个 <code>hash</code> 桶。</p><p>那我们再算算如果是 32 个哈希桶（也就是扩容到 32）的话，这个位置会是几呢？</p><p>其实想一想，不管是多少个哈希桶，这个字符串的 <code>hashCode</code> 值是不会变得，所以一直到 <code>h ^ h &gt;&gt;&gt; 16</code> 这步，运算结果都是不会变得，**唯一变得是 <code>length-1</code>**，会怎样变呢？改一下数据，15 改成 31，运行一下：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/result_hash2.png" alt="result_hash2.png"></p><p><u>2 的 n 次幂减去 1 得到的二进制，有效位一定都是 1，在进行与运算（&amp;）时就会有奇效了，而且在这种扩容是原来容量 2 倍的情况下，这边的 <code>length-1</code> 得到的二进制数会比扩容之前的 <code>length-1</code> 左边多一个 1 出来</u>，(比如上面，15 的时候二进制数为 1111，31 的时候就是 11111),所以在与 <code>h ^ h &gt;&gt;&gt; 16</code>计算的时候只要关注多出来的那个 1 对应 <code>h ^ h &gt;&gt;&gt; 16</code>的数字是 0 还是 1，如果是 0，则结果不变（就是上面 31 的例子），如果是 1 则运行结果左边会多出一个 1 出来。</p><p>按照上面的例子当扩容之后的 <code>length-1</code> 到这个位置的时候，位置就会变化：</p><p><a href="http://www.qxnekoo.cn:8888/image/MKJU"><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/hash_result3.png" alt="hash_result3.png"></a></p><p>那个位置是 127 的位置，也就是说扩容为 128 时，这个字符串对应的哈希桶的位置会发生变化，将 31 改为 127，验证一下：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/hash_result4.png" alt="hash_result4.png"></p><p>哈希桶的位置变为 74，也就是 10+64=74，这个 64 就是扩容为 128 之前的大小了，这一切就呼应上了。</p><p><strong>这就是为啥 <code>jdk8</code> 中扩容时，不需要重新计算 <code>hash</code> 值的原理了。</strong></p><p>原理有了，其实在源码中也是能找到相应的实现代码的：resize()方法</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/29/Map.png" alt="Map.png"></p><p>当然，它的具体实现方式肯定是有一套算法的了。（其实就是我没多大看懂代码具体咋实现的，而且我这边也没有讨论红黑树的情况！！）</p><p>下面列举一下 <code>jdk7</code> 与 <code>jdk8</code> 之间的差异了：</p><table><thead><tr><th>不同</th><th>JDK1.7</th><th>JDK1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：inflateTable()</td><td>直接继承到了扩容函数resize()中</td></tr><tr><td>hash值计算方式</td><td>扰动处理=9次扰动=4次位运算+5次异或运算</td><td>扰动处理=2次扰动=1次位运算+1次异或运算</td></tr><tr><td>存放数据的规则</td><td>头插法（先讲原位置的数据移到后一位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部、/红黑树）</td></tr><tr><td>扩容后存储位置的计算法方式</td><td>全部按照原来方法进行计算（即hashCode-&gt;&gt;扰动函数-&gt;&gt;(h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置or原位置+旧容量）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanDefinition</title>
      <link href="2020/04/23/BeanDefinition/"/>
      <url>2020/04/23/BeanDefinition/</url>
      
        <content type="html"><![CDATA[<p>源码中的注释，结合英文看：</p><pre class="line-numbers language-none"><code class="language-none">bean定义描述了一个bean实例，该实例具有属性值、构造函数参数值和由具体实现提供的进一步信息。这只是一个最小的接口:主要目的是允许&#123;@link BeanFactoryPostProcessor&#125;内省和修改属性值和其他bean元数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>BeanDefinition</code> 是 <code>Spring</code> 对 <code>Bean</code> 的抽象。容器中每一个 <code>bean</code> 都会有一个对应的 <code>BeanDefinition</code> 实例，该实例负责保存 <code>bean</code> 对象的所有必要信息，包括 <code>bean</code> 对象的 <code>class</code> 类型、是否抽象类、构造方法、参数、其他属性等。是用来描述 <code>Bean</code> 的。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/21/BeanDefinition.png" alt="BeanDefinition.png"></p><ul><li><p>AttributeAccessor</p><p>提供了访问属性的能力。就是定义了对对象属性的一些访问方法。</p></li><li><p>BeanMetadataElement</p><p>只有一个方法 <code>Object getSource()</code>，用来获取元数据元素的配置源对象。<code>AttributeAccessorSupport</code>是唯一抽象实现，内部基于<code>LinkedHashMap</code>实现了所有的接口，供其他子类继承使用  主要针对属性CRUD操作。这个方法在<code>@Configuration</code>中使用较多，因为它会被代理。</p></li></ul><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeanMetadataElement</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">MutablePropertyValues</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">AttributeAccessor</span><span class="token punctuation">;</span><span class="token comment">//BeanDefinition描述了一个bean实例，该实例具有属性值、构造函数参数值和由具体实现提供的进一步信息。</span><span class="token comment">//这只是一个最小的接口:主要目的是允许BeanFactoryPostProcessor内省和修改属性值和其他bean元数据。</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanDefinition</span> <span class="token keyword">extends</span> <span class="token class-name">AttributeAccessor</span><span class="token punctuation">,</span> <span class="token class-name">BeanMetadataElement</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> SCOPE_SINGLETON <span class="token operator">=</span> <span class="token string">"singleton"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> SCOPE_PROTOTYPE <span class="token operator">=</span> <span class="token string">"prototype"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ROLE_APPLICATION <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ROLE_SUPPORT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ROLE_INFRASTRUCTURE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setParentName</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getParentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span>    <span class="token keyword">void</span> <span class="token function">setBeanClassName</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取 Bean 的类名称</span>    <span class="token class-name">String</span> <span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setScope</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setLazyInit</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isLazyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setDependsOn</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDependsOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setAutowireCandidate</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isAutowireCandidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setPrimary</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isPrimary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//有些实例不是用反射生成的，而是用工厂模式生成的</span>    <span class="token keyword">void</span> <span class="token function">setFactoryBeanName</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getFactoryBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setFactoryMethodName</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getFactoryMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取构造器参数</span>    <span class="token class-name">ConstructorArgumentValues</span> <span class="token function">getConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span>    <span class="token class-name">MutablePropertyValues</span> <span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isAbstract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">getRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BeanDefinition</span> <span class="token function">getOriginatingBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>BeanDefinition</code>仅仅是一个最简单的接口，主要功能是允许<code>BeanFactoryPostProcessor</code> 例如<code>PropertyPlaceHolderConfigure</code> 能够检索并修改属性值和别的bean的元数据。</p><p>附加一张 <code>Bean</code> 的生命周期</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/23/Bean_lifeCycle.jpg" alt="Bean_lifeCycle.jpg"></p><p>第1步：调用 <code>bean</code> 的构造方法创建 <code>bean</code>；</p><p>第2步：通过反射调用 <code>setter</code> 方法进行属性的依赖注入；</p><p>第3步：如果实现 <code>BeanNameAware</code> 接口的话，会设置 <code>bean</code> 的 <code>name</code>；</p><p>第4步：如果实现了<code>BeanFactoryAware</code>，会把 <code>bean factory</code> 设置给 <code>bean</code>；</p><p>第5步：如果实现了 <code>ApplicationContextAware</code>，会给 <code>bean</code> 设置 <code>ApplictionContext</code>；</p><p>第6步：如果实现了 <code>BeanPostProcessor</code> 接口，则执行前置处理方法；</p><p>第7步：实现了 <code>InitializingBean</code> 接口的话，执行 <code>afterPropertiesSet</code> 方法；</p><p>第8步：执行自定义的 <code>init</code> 方法；</p><p>第9步：执行 <code>BeanPostProcessor</code> 接口的后置处理方法。</p><p>这时，就完成了 <code>bean</code> 的创建过程。</p><p>在使用完 <code>bean</code> 需要销毁时，会先执行 <code>DisposableBean</code> 接口的 <code>destroy</code> 方法，然后在执行自定义的 <code>destroy</code> 方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory</title>
      <link href="2020/04/23/BeanFactory/"/>
      <url>2020/04/23/BeanFactory/</url>
      
        <content type="html"><![CDATA[<p>先看源码中的注释，最好结合英文看</p><pre class="line-numbers language-none"><code class="language-none">用于访问Spring bean容器的根接口。这是bean容器的基本客户端视图;其他接口如&#123;@link ListableBeanFactory&#125;和(&#123;@link org.springframework.bean .factory.config. configurablebeanfactory&#125;)可用于特定目的。这个接口是由包含许多bean定义的对象实现的，每个bean定义都由一个字符串名惟一标识。根据bean定义，工厂将返回所包含对象的独立实例(原型设计模式)，或单个共享实例(与单例设计模式相比的更好的选择，在单例设计模式中，实例是工厂范围内的单例)。返回哪种类型的实例取决于bean工厂配置:API是相同的。从Spring 2.0开始，根据具体的应用程序上下文(例如，“请求”和“会话”在web环境中适用)。这种方式的关键点是BeanFactory是应用程序组件的中心注册表，并集中应用程序组件的配置(例如，单个对象不再需要读取属性文件)。请参阅“专家一对一的J2EE设计和开发”的第4章和第11章，以了解这种方法的好处。请注意，通常更好的方法是依靠依赖项注入(“推”配置)通过setter或构造函数来配置应用程序对象，而不是使用任何形式的“拉”配置(如BeanFactory查找)。Spring的依赖注入功能是使用这个BeanFactory接口及其子接口实现的。通常，BeanFactory将加载存储在配置源(如XML文档)中的bean定义，并使用(&#123;@code org.springframework.beans&#125;)包来配置bean。但是，实现可以简单地返回它在必要时直接在Java代码中创建的Java对象。对于如何存储这些定义没有限制:LDAP、RDBMS、XML、属性文件等。鼓励实现支持bean之间的引用(依赖项注入)。与&#123;@link ListableBeanFactory&#125;中的方法不同，此接口中的所有操作也将检查父工厂是否为&#123;@link HierarchicalBeanFactory&#125;。如果在这个工厂实例中没有找到bean，则会询问直接的父工厂。工厂实例中的bean应该覆盖任何父工厂中同名的bean。BeanFactory实现应该尽可能支持标准的bean生命周期接口。初始化方法的全套及其标准顺序为:1. BeanNameAware的&#123;@code setBeanName&#125;2. BeanClassLoaderAware的&#123;@code setBeanClassLoader&#125;3. BeanFactoryAware的&#123;@code setBeanFactory&#125;4. EnvironmentAware的&#123;@code setEnvironment&#125;5. EmbeddedValueResolverAware的&#123;@code setEmbeddedValueResolver&#125;6. ResourceLoaderAware的&#123;@code setResourceLoader&#125;(仅适用于在应用程序上下文中运行时)7. ApplicationEventPublisherAware的&#123;@code setApplicationEventPublisher(仅适用于在应用程序上下文中运行时)8. MessageSourceAware的&#123;@code setMessageSource&#125;(仅适用于在应用程序上下文中运行时)9. ApplicationContextAware的&#123;@code setApplicationContext&#125;(仅适用于在应用程序上下文中运行时)10. ServletContextAware的&#123;@code setServletContext&#125;(仅适用于在web应用程序上下文中运行时)11. beanpostprocessor的方法12. InitializingBean的&#123;@code afterPropertiesSet&#125;13. 一个自制的init-method定义14. &#123;@code后处理后初始化&#125;beanpostprocessor的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用大白话说一下：</p><p><code>BeanFactory</code> 是一个接口，<strong>提供了 <code>IOC</code> 容器最基本的形式，给具体的 <code>IOC</code> 容器实现提供了规范</strong>。在 <code>Spring</code> 中，<code>BeanFactory</code> 是 <code>IOC</code> 容器的核心接口，它的职责包括<strong>实例化、定位、配置应用程序中的对象及建立这些对象间的依赖</strong>(依赖注入)。<code>BeanFactory</code> 只是个接口，并不是 <code>IOC</code> 容器的具体实现，但是 <code>Spring</code> 容器给出了很多种实现，如 <code>DefaultListableBeanFactory</code>、<code>XmlBeanFactory</code>、<code>ApplicationContext</code> 等， 都是附加了某种功能的实现。</p><p><code>BeanFactory</code> 和 <code>ApplicationContext</code>（继承了 <code>BeanFactory</code>）就是 <code>Spring</code> 框架的两个 <code>IOC</code> 容器，现在一般使用 <code>ApplicationnContext</code>，其不但包含了 <code>BeanFactory</code> 的作用，同时还进行更多的扩展。 （也有种说法是 <code>BeanFactory</code> 是低级容器，<code>ApplicationContext</code> 是高级容器。）</p><p>其实就是用来生产和管理 <code>Bean</code> 的。通过 <code>BeanDefinitionRegistry</code> 将 <code>Bean</code> 注册到 <code>BeanFactzaiory</code> 中。</p><p><code>BeanFactory</code> 初始化流程：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/22/BeanFactory_init.jpg" alt="BeanFactory_init.jpg"></p><p>主要来看看 <code>refresh</code> 方法，该方法定义在 <code>ConfigurableApplicationContext</code> 接口中，下面是<code>AbstractApplicationContext</code> 抽象类中的一个实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalStateException</span> <span class="token punctuation">&#123;</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Prepare this context for refreshing. 为刷新准备此上下文。</span><span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Tell the subclass to refresh the internal bean factory.告诉子类刷新内部bean工厂。</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Prepare the bean factory for use in this context. 准备bean工厂以供在此上下文中使用。</span><span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">// Allows post-processing of the bean factory in context subclasses. 允许在上下文子类中对bean工厂进行后处理。</span><span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Invoke factory processors registered as beans in the context. 调用上下文中注册为bean的工厂处理器。</span><span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Register bean processors that intercept bean creation. 注册拦截bean创建的bean处理器。</span><span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Initialize message source for this context. 为此上下文初始化消息源。</span><span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Initialize event multicaster for this context. 为此上下文初始化事件多播程序。</span><span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Initialize other special beans in specific context subclasses. 初始化特定上下文子类中的其他特殊bean。</span><span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check for listener beans and register them. 检查侦听器bean并注册它们。</span><span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Instantiate all remaining (non-lazy-init) singletons. 实例化所有剩余的(非惰性初始化)单例。</span><span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Last step: publish corresponding event. 最后一步:发布相应的事件。</span><span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Exception encountered during context initialization - "</span> <span class="token operator">+</span><span class="token string">"cancelling refresh attempt: "</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Destroy already created singletons to avoid dangling resources. 销毁已经创建的单例，以避免挂起资源。</span><span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Reset 'active' flag.</span><span class="token function">cancelRefresh</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Propagate exception to caller.</span><span class="token keyword">throw</span> ex<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span><span class="token comment">// Reset common introspection caches in Spring's core, since we</span><span class="token comment">// might not ever need metadata for singleton beans anymore...</span>                <span class="token comment">//重置Spring核心中的公共自省缓存，因为我们可能再也不需要单例bean的元数据了……</span><span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>refresh</code> 方法中，操作共分13步：</strong></p><p>第1步：对刷新进行准备，包括设置开始时间、设置激活状态、初始化 <code>context</code> 环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的 <code>properties</code>；</p><p>第2步：刷新并获得内部的 <code>bean factory</code>；</p><p>第3步：对 <code>bean factory</code> 进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境 <code>bean</code>；</p><p>第4步：为 <code>context</code> 的子类提供后置处理 <code>bean factory</code> 的扩展能力。如果子类想在 <code>bean</code> 定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法；</p><p>第5步，执行 <code>context</code> 中注册的 <code>bean factory</code> 后缀处理器；</p><p>注：这里有两种后置处理器，一种是可以注册 <code>bean</code> 的后缀处理器，另一种是针对 <code>bean factory</code> 进行处理的后置处理器。执行的顺序是，先按优先级执行可注册 <code>bean</code> 的处理器，在按优先级执行针对 <code>beanfactory</code> 的处理器。</p><p>对 <code>SpringBoot</code> 来说，这一步会进行注解 <code>bean definition</code> 的解析。流程如右面小框中所示，由<code>ConfigurationClassPostProcessor</code> 触发、由 <code>ClassPathBeanDefinitionScanner</code> 解析并注册到 <code>bean factory</code>。</p><p>第6步：按优先级顺序在 <code>beanfactory</code> 中注册 <code>bean</code> 的后缀处理器，<code>bean</code> 后置处理器可以在 <code>bean</code> 初始化前、后执行处理；</p><p>第7步：初始化消息源，消息源用来支持消息的国际化；</p><p>第8步：初始化应用事件广播器。事件广播器用来向 <code>applicationListener</code> 通知各种应用产生的事件，是一个标准的观察者模式；</p><p>第9步，是留给子类的扩展步骤，用来让特定的 <code>context</code> 子类初始化其他的 <code>bean</code>；</p><p>第10步，把实现了 <code>ApplicationListener</code> 的 <code>bean</code> 注册到事件广播器，并对广播器中的早期未广播事件进行通知；</p><p>第11步，冻结所有 <code>bean</code> 描述信息的修改，实例化非延迟加载的单例 <code>bean</code>；</p><p>第12步，完成上下文的刷新工作，调用 <code>LifecycleProcessor</code> 的 <code>onFresh()</code> 方法以及发布<code>ContextRefreshedEvent</code> 事件；</p><p>第13步：在 <code>finally</code> 中，执行第十三步，重置公共的缓存，比如 <code>ReflectionUtils</code> 中的缓存、<code>AnnotationUtils</code> 中的缓存等等；</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 中的扩展</title>
      <link href="2020/04/23/Spring%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>2020/04/23/Spring%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>扩展接口：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/23/spring_extension.jpg" alt="spring_extension.jpg"></p><ul><li><p><code>BeanFactoryPostProcessor</code></p><p><code>BeanFactory</code> 后置处理器，支持在 <code>BeanFactory</code> 标准初始化完成后，对 <code>BeanFactory</code> 进行一些额外处理。这时所有的 <code>bean</code> 的描述信息已经加载完毕，但是还没有进行 <code>bean</code> 初始化。例如  <code>PropertyPlaceholderConfigurer</code>,就是在这个扩展点上对bean属性中的占位符进行替换。</p></li><li><p><code>BeanDefinitionRegistryPostProcessor</code></p><p>它扩展自 <code>BeanFactoryPostProcessor</code>，在执行 <code>BeanFactoryPostProcessor</code> 的功能前，提供了可以添加 <code>beanDefinition</code> 的能力，允许在初始化一般 <code>bean</code> 前，注册额外的 <code>bean</code>。例如可以在这里根据 <code>bean</code> 的 <code>scope</code> 创建一个新的代理 <code>bean</code>。</p></li><li><p><code>BeanPostProcessor</code></p><p>提供了在 <code>bean</code> 初始化之前和之后插入自定义逻辑的能力。与 <code>BeanFactoryPostProcessor</code> 的区别是处理的对象不同，<code>BeanFactoryPostProcessor</code> 是对 <code>beanFactory</code> 进行处理，<code>BeanPostProcessor</code> 是对 <code>bean</code> 进行处理。</p></li></ul><p>这些都是可以通过实现 <code>Ordered</code> 和 <code>PriorityOrdered</code> 接口来指定执行顺序。实现 <code>PriorityOrdered</code> 接口的 <code>processor</code> 会先于实现 <code>Ordered</code> 接口的执行。</p><ul><li><p><code>ApplicationContextAware</code></p><p>可以获取 <code>ApplicationContext</code> 及其中的 <code>bean</code>，当需要在代码中动态获取 <code>bean</code> 时，可以通过实现这个接口来实现。</p></li><li><p><code>InitializingBean</code></p><p>可以在 <code>bean</code> 初始化完成，所有属性设置完成后执行特定逻辑，例如对自动装配对属性进行验证等等。</p></li><li><p><code>DisposableBean</code></p><p>用于 <code>bean</code> 被销毁前执行特定的逻辑，例如做一些回收工作等。</p></li><li><p><code>ApplicationListener</code></p><p>用来监听 <code>Spring</code> 的标准应用事件或者自定义事件。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanPostProcessor</title>
      <link href="2020/04/21/BeanPostProcessor/"/>
      <url>2020/04/21/BeanPostProcessor/</url>
      
        <content type="html"><![CDATA[<p>先将源码中的注释贴上来，毕竟是翻译的，看的时候最好还是对照英文的来看：</p><pre class="line-numbers language-none"><code class="language-none">工厂挂钩允许自定义修改新的bean实例;例如，检查标记接口或使用代理包装bean。通常，通过标记接口或类似方法填充bean的后处理器将实现&#123;@link# postprocessbeforeinitialize&#125;，而使用代理包装bean的后处理器通常将实现&#123;@link# postprocessafterinitial&#125;。注册&#123;@code ApplicationContext&#125;可以在其bean定义中自动检测&#123;@code BeanPostProcessor&#125; bean，并将这些后处理程序应用于随后创建的任何bean。普通的&#123;@code BeanFactory&#125;允许对后处理程序进行编程式注册，将它们应用于通过bean factory创建的所有bean。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直译过来，就是对象后处理器。接口中有两个默认方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeansException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Nullable</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以先写一个实例代码来看看效果，自定义 <code>BeanPostProcessor</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">CustomPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CustomPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"CustomPostProcessor的构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Bean4BBP</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"process after init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Bean4BBP</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"process before init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建 <code>Bean4BBP</code>，并注册为 <code>Bean</code></p><pre class="line-numbers language-none"><code class="language-none">@Componentpublic class Bean4BBP &#123;    private Logger log &#x3D; LoggerFactory.getLogger(Bean4BBP.class);    public Bean4BBP () &#123;        log.warn(&quot;Bean4BBp的构造函数&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/20/BeanPostProcessor1.png" alt="BeanPostProcessor1.png"></p><p>好好理解一下：</p><blockquote><p>我们在使用 Spring 的时候，拿到的 Bean 其实就是一个对象，那么 Spring 肯定会在之前就去执行类的构造函数，来产生一个对象，那这个对象能被 Spring 直接拿过来用嘛？</p><p>Spring 会对其进行额外的操作，就是将其初始化（InitializingBean 接口）为归 Spring 管理的 Bean，BeanPostProcessor 并不是是用来做这个事情的，但是会在对象被初始化之前、之后执行相应的回调函数，差不多是一种帮助其初始化的作用吧。</p></blockquote><p>在对象创建完成之后，会去遍历 <code>BeanPostProcessor</code> 对象，然后去为普通 <code>Bean</code> 执行里面的 <code>postProcessAfterInitialization()</code> 和 <code>postProcessBeforeInitialization()</code>。</p><p>下图是Bean的初始化步骤，可以看到 <code>BeanPostProcessor </code></p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/20/Bean-Initialization-Steps.jpg" alt="Bean-Initialization-Steps.jpg"></p><p>看几个比较 <code>Spring</code> 自己的 <code>BeanPostProcessor </code>，</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>上一篇说到的 <code>applicationListener</code>，它也是一个 <code>Bean</code></p><ol><li><code>ApplicationListenerDetector.java</code></li></ol><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/20/BeanPostProcessor_applicationListener.png" alt="BeanPostProcessor_applicationListener.png"></p><ol start="2"><li><p><code>AbstractAutoProxyCreator.java</code></p><p>这个就有说道了，主要是 <code>Spring AOP</code> 和这个有关联。<code>AspectJAwareAdvisorAutoProxyCreator.java</code> 和 <code>AnnotationAwareAspectJAutoProxyCreator</code>，都是继承这个类，看名字其实知道是自动代理的创建类，而我们知道 <code>Spring AOP</code> 最主要的就是通过代理对象来调用目标方法，代理对象就是在这边生成的。</p><blockquote><p>这边也解释了我之前的一个疑问:我注入一个 Service 层的 Spring 的 Bean，然后获取这个 Bean 的类名（也就是看看它属于哪个类），得到的是 Service 实现类的类名;而在 Service 实现类上加上一个 @Transactional 注解，获取到的是一个由 <code>Spring</code> 创建的代理类的类名，下面会演示。</p></blockquote><p>也就是说在<code>AbstractAutoProxyCreator.java</code> 中的这个 <code>BeanPostProcessor</code> 调用了 <code>postProcessAfterInitialization()</code> 方法，这个里面会调用一个 <code>wrapIfNecessary</code> 方法，我们打上断点，</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/20/BeanPostProcessor_AOP1.png" alt="BeanPostProcessor_AOP1.png"></p><p>撰写一个测试类：<code>TestServiceImpl.java</code>，但是并不声明 <code>@transactional</code>,打印它的类名：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"注入对象的类名：&#123;&#125;"</span><span class="token punctuation">,</span>testService<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  运行结果，并没有进入断点，而且 <code>Spring</code> 也并没有为其创建代理对象：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/20/BeanPostProcessor_AOP2.png" alt="BeanPostProcessor_AOP2.png"></p><p>加上<code>@transactional</code>，重新运行，进入到断点，看到 <code>Spring</code> 为我们创建的代理对象，你品，你细品……：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/20/BeanPostProcessor_AOP5.png" alt="BeanPostProcessor_AOP5.png"></p><p>之后放开断点看结果：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/20/BeanPostProcessor_AOP6.png" alt="BeanPostProcessor_AOP6.png"></p><p>这就呼应上了，该对象就是 <code>Spring</code> 为其创建的对象，完事儿。    </p><p>因为 <code>@Transactional</code> 注解就是使用的 <code>Spring AOP</code>，其实你只要为这个类中的方法做个 <code>Spring AOP</code>，注入的时候产生的对象就是 <code>Spring</code> 的代理对象，这也就解释了我们平常做 <code>Spring AOP</code>的时候为什么一定要去用代理对象来调用目标方法，而不能单纯用 <code>this</code>。</p></li></ol><p>栗子就举到这儿吧，以后学习到了再来补充，感觉 <code>BeanPostProcessor</code> 还是怪好玩儿的！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 ApplicationListener</title>
      <link href="2020/04/19/%E7%90%86%E8%A7%A3ApplicationListener/"/>
      <url>2020/04/19/%E7%90%86%E8%A7%A3ApplicationListener/</url>
      
        <content type="html"><![CDATA[<p>看看源码中的注释，最好结合英文文档来看：</p><pre class="line-numbers language-none"><code class="language-none">由应用程序事件侦听器实现的接口。基于观察者设计模式的标准接口(&#123;@code java.util.EventListener&#125;)。从Spring 3.0开始，&#123;@code ApplicationListener&#125;通常可以声明它感兴趣的事件类型(泛型)。当向Spring &#123;@code ApplicationContext&#125;注册时，事件将被相应地过滤，侦听器将被调用，仅用于匹配事件对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>监听容器中发布的事件，完成事件驱动模型的开发。是<strong>观察者设计模式</strong>的实现，通过 <code>ApplicationEvent</code> 和 <code>ApplicationListener</code> 接口，可以实现 <code>ApplicationContext</code> 事件处理。</p><p>简单的来说，在容器中注册一个 <code>ApplicationListener</code> 监听器，每当 <code>ApplicationContext</code> 发布 <code>ApplicationEvent</code> 时，监听器会根据事件的类型来处理一些逻辑。</p><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>创建一个监听器只需要去实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent</code> 方法，并放到 <code>Spring</code> 容器即可。</p><p>下面是部分源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">EventListener</span><span class="token punctuation">;</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">E</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//ApplicationEvent抽象类</span><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">EventObject</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">EventObject</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7099057708183571937L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timestamp <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//EventObject</span><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span><span class="token comment">/** * &lt;p> * The root class from which all event state objects shall be derived. * &lt;p> * All Events are constructed with a reference to the object, the "source", * that is logically deemed to be the object upon which the Event in question * initially occurred upon. * * @since JDK1.1 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventObject</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">5516075349620653480L</span><span class="token punctuation">;</span>    <span class="token comment">/**     * The object on which the Event initially occurred.     */</span>    <span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token class-name">Object</span>  source<span class="token punctuation">;</span>    <span class="token comment">/**     * Constructs a prototypical Event.     *     * @param    source    The object on which the Event initially occurred.     * @exception  IllegalArgumentException  if source is null.     */</span>    <span class="token keyword">public</span> <span class="token class-name">EventObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"null source"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>source <span class="token operator">=</span> source<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * The object on which the Event initially occurred.     *     * @return   The object on which the Event initially occurred.     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> source<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * Returns a String representation of this EventObject.     *     * @return  A a String representation of this EventObject.     */</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"[source="</span> <span class="token operator">+</span> source <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//EventListener接口</span><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span><span class="token comment">/** * A tagging interface that all event listener interfaces must extend. * @since JDK1.1 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EventListener</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内置事件"><a href="#内置事件" class="headerlink" title="内置事件"></a>内置事件</h2><table><thead><tr><th>内置事件</th><th>描述</th></tr></thead><tbody><tr><td><strong><code>ContextRefreshedEvent</code></strong></td><td><code>ApplicationContext</code> 被初始化或刷新时，该事件被发布。这也可以在 <code>ConfigurableApplicationContext</code> 接口中使用 <code>refresh()</code> 方法来发生。此处的初始化是指：所有 <code>Bean</code> 被成功装在，后处理 <code>Bean</code> 被检测并激活，所有 <code>Singleton Bean</code> 被实例化，<code>ApplicationContext</code> 容器已就绪可用。</td></tr><tr><td><strong><code>ContextStartedEvent</code></strong></td><td>当使用  <code>ConfifurableApplicationContext</code>（<code>ApplicationContext</code> 子接口）接口中的 <code>start</code> 方法启动 <code>ApplicationContext</code> 时，该事件被发布。可以调查数据库，或者可以在接收到这个事件后重启任何停止的应用程序。</td></tr><tr><td><strong><code>ContextStoppedEvent</code></strong></td><td>当使用 <code>ConfifurableApplicationContext</code> 接口中的 <code>stop</code> 停止 <code>ApplicationContext</code> 时，发布这个事件，可以在接收到这个事件后作必要的清理工作。</td></tr><tr><td><strong><code>ContextClosedEvent</code></strong></td><td>当使用 <code>ConfigurableApplicationContext</code> 接口中的 <code>close()</code> 方法关闭 <code>ApplicationContext</code> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</td></tr><tr><td><strong><code>RequestHandledEvent</code></strong></td><td>这是一个 <code>web-specific</code> 事件，告诉所有 <code>bean HTTP</code> 请求已经被服务。只能应用于使用 <code>DispatcherServlet</code> 的 <code>Web</code> 应用。在使用 <code>Spring</code> 作为前端的 <code>MVC</code> 控制器时，当 <code>Spring</code> 处理用户请求结束后，系统会自动触发该事件。</td></tr></tbody></table><p>想上一节使用的例子就是 <strong><code>ContextRefreshedEvent</code></strong> 事件，然后去执行相应的逻辑。</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p><code>EmailEvent</code> 事件:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmailEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> text<span class="token punctuation">;</span>    <span class="token comment">//重写构造方法</span>    <span class="token keyword">public</span> <span class="token class-name">EmailEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> address<span class="token punctuation">,</span> <span class="token class-name">String</span> text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">EmailEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token class-name">String</span> address<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> text<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setText</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承 <code>ApplicationEvent</code> 抽象类。</p><p>定义 <code>EmailListener</code> 监听器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>、<span class="token comment">//ApplicationListener是可以给出泛型的  只监听此类事件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmailListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EmailEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">EmailListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">EmailEvent</span> emailEvent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>emailEvent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"邮件地址：&#123;&#125;"</span><span class="token punctuation">,</span> emailEvent<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"邮件内容：&#123;&#125;"</span><span class="token punctuation">,</span> emailEvent<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"source对象为:&#123;&#125;"</span><span class="token punctuation">,</span>emailEvent<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在启动类中发布该事件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringlistenerApplication</span> <span class="token keyword">implements</span> <span class="token class-name">CommandLineRunner</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringlistenerApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">EmailEvent</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EmailEvent</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"qxnekoo@163.com"</span><span class="token punctuation">,</span> <span class="token string">"ze ze ze"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//主动触发该事件  需要 ApplicationContext 对象来发布</span>        applicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment">//获取 Spring 的 applicationContext 容器</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/19/Spring.png" alt="Spring.png"></p><p>还有一种监听的方式就是不使用泛型，全都监听</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">CommonListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> applicationEvent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span>applicationEvent<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//通过不同的事件类型进行不同的逻辑处理</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>applicationEvent <span class="token keyword">instanceof</span> <span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"初始化Bean完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>applicationEvent <span class="token keyword">instanceof</span> <span class="token class-name">EmailEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"邮箱事件触发"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/19/Spring2.png" alt="Spring2.png"></p><p>两种方式按照需求选择就可以了。</p><blockquote><p>额外补充</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token comment">//key位 beanName，value为bean</span><span class="token operator">></span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AppContextInitListener</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token function">applicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span><span class="token class-name">AppContextInitListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token comment">//返回 beanName 的String 数组</span><span class="token operator">></span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token function">applicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">Interface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 中的 ApplicationListener</title>
      <link href="2020/04/18/Spring%20%E4%B8%AD%E7%9A%84%20ApplicationListener/"/>
      <url>2020/04/18/Spring%20%E4%B8%AD%E7%9A%84%20ApplicationListener/</url>
      
        <content type="html"><![CDATA[<p>写代码时遇到这样一个业务场景。</p><p>核销的时候，有多种核销，比如返利核销、预付款核销等等，要根据不同的类型进行各自的核销逻辑，模拟代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//核销入口 EntranceOfWriteOffServiceImpl 实现了AppContextInitLisenter接口</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EntranceOfWriteOffServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">EntranceOfWriteOffService</span><span class="token punctuation">,</span> <span class="token class-name">AppContextInitLisenter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">EntranceOfWriteOffServiceImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">CommonService</span><span class="token punctuation">></span></span> typeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment">//实现AppContextInitLisenter接口中的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextInitialized</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">CommonService</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span><span class="token class-name">CommonService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-></span> typeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment">//核销入口方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeOff</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//..</span>        <span class="token class-name">CommonService</span> comm <span class="token operator">=</span> typeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        comm<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//..</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//CommonService 各种核销类型去实现这个接口来写自己的核销逻辑</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CommonService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//核销逻辑</span>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取核销类型</span>    <span class="token class-name">String</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//AppContextInitLisenter</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AppContextInitLisenter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">contextInitialized</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码其实不难理解：<code>contextInitialized</code> 方法利用 <code>Spring</code> 容器将实现 <code>CommonService</code> 接口的 <code>Bean</code> 收集起来，具体核销的时候从这个 <code>typeMap</code> 里取出自己的核销实现对象来调用核销逻辑。</p><p>我比较费解的是 <code>contextInitialized</code> 什么时候调用的，类里面没有显示调用的地方，定义这个方法的接口 <code>AppContextInitLisenter</code> 也只是一个普通的接口，也没有去继承 <code>Spring</code> 中的某个接口或者使用到了什么注解，只是从名字上来看像是初始化 <code>Spring</code> 容器的监听，但仅仅是名字像这个理由是不能让我满足的。</p><p>于是找啊找，终于在 <code>applicationContext.xml</code> 中找到了一个 <code>Bean</code>，这边就不用项目中的代码了，模拟一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationListenerBean</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> applicationEvent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>applicationEvent <span class="token keyword">instanceof</span> <span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">)</span> applicationEvent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AppContextInitLisenter</span><span class="token punctuation">></span></span> beanMap <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span><span class="token class-name">AppContextInitLisenter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            beanMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-></span> v<span class="token punctuation">.</span><span class="token function">contextInitialized</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再点进去这个 <code>ApplicationListener</code> 接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//</span><span class="token comment">// Source code recreated from a .class file by IntelliJ IDEA</span><span class="token comment">// (powered by Fernflower decompiler)</span><span class="token comment">//</span><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">EventListener</span><span class="token punctuation">;</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">E</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就舒服了，这是 <code>Spring</code> 中提供的一个函数式接口，这样一切就说的通了，<code>ApplicationListenerBean</code> 这里面的代码也大概看得懂：</p><blockquote><p>将实现 <code>AppContextInitLisenter</code> 接口的 <code>Bean</code> 收集起来，然后逐个去调用实现的方法 <code>contextInitialized()</code>，这个方法就是在这边调用的。</p></blockquote><p>之后做了个简单的模拟。</p><p>创建具体核销实现类：<code>BookServiceImpl</code> 和 <code>UserServiceImpl</code>，就叫核销书本和核销用户吧~，不要问我是什么鬼，只是单纯的模拟而已。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//用户核销</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">,</span> <span class="token class-name">CommonService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> type <span class="token operator">=</span> <span class="token string">"USER"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"用户的核销逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//书本核销</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span> <span class="token punctuation">,</span> <span class="token class-name">CommonService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span>  <span class="token class-name">String</span> type <span class="token operator">=</span> <span class="token string">"BOOK"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"书本的核销逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//为了显示更加明显 ApplicationListenerBean类加入一点日志打印</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationListenerBean</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListenerBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> applicationEvent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>applicationEvent <span class="token keyword">instanceof</span> <span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">)</span> applicationEvent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AppContextInitLisenter</span><span class="token punctuation">></span></span> beanMap <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span><span class="token class-name">AppContextInitLisenter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            beanMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"==="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"调用这个方法的类是：&#123;&#125;"</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                v<span class="token punctuation">.</span><span class="token function">contextInitialized</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在启动类中调用核销入口方法，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">entranceOfWriteOffService<span class="token punctuation">.</span><span class="token function">writeOff</span><span class="token punctuation">(</span><span class="token string">"BOOK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"==================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>entranceOfWriteOffService<span class="token punctuation">.</span><span class="token function">writeOff</span><span class="token punctuation">(</span><span class="token string">"USER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行结果如下，可以看到，实际上调用这个方法的对象还是核销入口对象。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/18/53ace438b23ec3ba749dadfe29416391.png" alt="53ace438b23ec3ba749dadfe29416391.png"></p><p>总结：</p><blockquote><p>其实使用 <code>if else</code> 一样可以达到这种效果，不同的类型调用不同的逻辑，但是明显这种方式更加优雅，扩展性也更强。</p><p>这边只是简单记录一下代码的实现，原理来说的话从代码大概猜的出来是什么事件的监听之类的，下一篇会详细介绍里面的 <code>Spring</code> 原理。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JIT部分优化措施</title>
      <link href="2020/04/15/JIT%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD/"/>
      <url>2020/04/15/JIT%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD/</url>
      
        <content type="html"><![CDATA[<p>即时编译器常见优化技术：栈上分配、公共子表达式消除、无用代码消除、自动装箱消除、逃逸分析、锁消除、锁膨胀、表达式提升、内联……</p><p>首先要明确一点的是，所做的这些优化都是建立在代码的中间表示或者是机器码之上的，绝不是直接在 <code>Java</code> 源码上去做的。</p><p>选择4个具有代表性的优化技术：</p><ol><li>最重要的优化技术之一：方法内联</li><li>最前沿的优化技术之一：逃逸分析</li><li>语言无关的经典优化技术之一：公共表达式消除</li><li>语言相关的经典优化技术之一：数组边界检查消除</li></ol><h2 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h2><p>戏称为优化之母，因为除了消除方法调用的成本之外，它更重要的意义是<strong>为其他优化手段建立良好的基础</strong>。没有内联，多数其他优化都无法有效进行。</p><p>理解起来也很简单，<strong>不过是把目标方法的代码原封不动地复制到发起调用的方法之中，避免发生真实的方法调用而已</strong>。但是其过程还是非常复杂的。</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>基本原理：分析对象的动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸。甚至可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</p><p>能够对不同逃逸程度的对象采用不同程度的优化：</p><ul><li><p><strong>栈上分配</strong>：如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个不错的选择，对象所占用的内存将会随着栈帧出栈而销毁，垃圾收集子系统的压力会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</p></li><li><p><strong>标量替换</strong>：一个数据无法再分解成更小的数据来表示了，虚拟机中的基本数据类型等都不能再进一步分解了，那么这些数据就可以被称为标量。如果一个数据可以继续分解，就称为聚合量，对象就是典型的聚合量。</p><p><strong>如果把一个对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程叫做标量替换。</strong></p><p>将一个对象拆散，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器得到高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</p><p>对逃逸程度的要求更高，不允许对象逃逸出方法范围内。</p></li><li><p><strong>同步消除</strong>：如果确定一个对象不会逃逸出线程，无法被其他线程访问到，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也可以安全的消除掉。</p></li></ul><p>缺点：逃逸分析的计算成本非常高，甚至不能保证带来的性能收益高于它的消耗。如果逃逸分析后发现几乎找不到不逃逸的对象，那么这些运行期耗用的时间就白白浪费了。</p><p>大神文章：</p><p><a href="https://mp.weixin.qq.com/s/Owlhu5IFpDAyu0WYcK1EhQ">https://mp.weixin.qq.com/s/Owlhu5IFpDAyu0WYcK1EhQ</a></p><h2 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h2><p>如果一个表达式 <code>E</code>之前已经被计算过了，并且从先前的计算到现在 <code>E</code> 中所有变量的之都没有发生变化，那么 <code>E</code> 的这次出现就成为公共子表达。对于这种表达式，没有必要花时间对它重新计算，直接用前面的结果来代替就可以了。</p><p>理解起来还是很简单的：</p><p><code>int d = (c*b)*12+a+(a+b*c)</code>会变成<code>int d = E*12+a+(a+E)</code>，甚至是<code>int d = E*13+a+a</code></p><h2 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h2><p>虽然会有运行时异常 <code>ArrayIndexOutOfBoundsException</code>，但对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判断操作，这是一种性能负担。</p><p>最常见的就是在循环中，编译器只要通过数据流分析就可以判定循环变量的取值范围永远在正确的区间之内，那么在循环中就可以把整个数组的上下界检查消除掉，这就可以节省很多次的条件判断操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实优化措施还有很多，而且细讲的话也是有很多内容的，希望以后可以补充出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot 中的编译器与解释器</title>
      <link href="2020/04/14/JVM%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
      <url>2020/04/14/JVM%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>编译器在编译的过程中，读入源程序文件，输出一份等价的二进制可执行文件，就和笔译工作者一样，他们都会输出一份翻译后的文件。</li><li>解释器在解释的过程中，读入源程序文件，输出的是执行的结果，就和口译工作者一样，他们输出的是已经完成翻译的结果。</li></ul><p><strong>输出的不同是这两者最大的区别，一个会输出用于执行的文件，另一个只会输出运行的结果；</strong></p><p><strong>解释型语言启动速度快，但启动后的运行效率不高，而编译型语言启动速度慢，但启动后运行效率高，这也是两者一个极大的区别。</strong></p><p>特点：</p><ul><li>解释器：跨平台、启动速度快、开发效率高。但是执行速度慢，执行效率低。</li><li>编译器：执行速度快、执行效率高。但是平台相关性高，编译速度（启动速度）慢，开发效率低。</li></ul><p><code>Java</code> 中编译器比较多，它包含<em>一个前端编译器，一个后端编译器（<code>JIT</code>）以及一个静态预编译器（<code>AOT</code>）</em>。</p><ul><li>前端编译器的功能是从源代码生成 <code>Java</code> 字节码，也就是中间代码；</li><li>后端编译器，也叫作即时编译器（<code>JIT</code>）它是包含在了 <code>JVM</code> 中，用于在执行的过程中，将热点代码（也就是执行次数比较多的代码）转化为本地机器码，并做一些优化，以加速执行效率。</li><li>静态预编译器（<code>AOT</code>）它是直接将 <code>java</code> 源代码编译成本地机器码，也就是传统意义上的编译器，但用的不多，因为这样会使 <code>java</code> 的一些特性丢失。</li></ul><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p><code>JVM</code>中包含一个解释器和多个编译器，在目前阶段，主流的编译分为前端编译和后端编译。后端编译虽然这不是<code>JVM</code>虚拟机的规范，但是这些都是衡量一个高质量虚拟机的指标之一。</p><p>对性能的优化都是在后端编译上的。开发阶段的优化（比如说语法糖）都是在前端编译体现的。可以这样说：<strong>后端编译是运行期的优化过程，支撑了程序执行效率的不断提升；而前端编译器在编译期的优化过程，则是支撑程序员的编码效率。</strong></p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/14/18c1d2566427e48a20f998eba57daf03.png" alt="前后端编译.png"></p><p>前端编译的最终产物是<code>中间代码</code>，这个中间代码所指的就是<code>Java</code>的字节码文件。但是这个文件还是不能被处理器运行的能力，还需要一层<code>JVM</code>的加工。</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>解释器顾名思义就是解释代码用的，上面提到了前端编译的最终产物是中间代码，这时的中间代码不具有被处理器识别并执行的能力，解释器的职责就是将此时的字节码<strong>逐条解释</strong>成处理器能够识别的机器码指令。</p><p>所以从这里也可以解释，为什么高级语言执行效率会这么慢，主要就是多了这个解释的过程，像 <code>Java</code>、<code>Python</code> 等执行效率都比较慢。</p><p>所以通俗讲：解释器在 <code>Java</code> 中的作用充当了 <code>Java</code> 程序和计算机之间的“翻译官”角色，将计算机“看”不懂的语言翻译成它能够“看”懂并执行的机器语言。</p><p><code>Java</code> 中的解释器与 <code>JIT</code> (后端编译)一起打包，作为 <code>JVM</code> 中的<em>执行引擎</em>，解释器主要将字节码进行解释执行，同时配合 <code>JIT</code> 进行代码的优化操作。</p><blockquote><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动之后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，可以减少解释器的中间损耗，获得更高的执行效率。</p></blockquote><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/14/JIT.png" alt="JIT.png"></p><p>后续会大概记录一下 <code>JIT</code> 技术具体的优化策略。</p><p>参考文章：<a href="https://www.jianshu.com/p/96d65e8f4cbf">https://www.jianshu.com/p/96d65e8f4cbf</a></p><p>​                   <a href="https://zhuanlan.zhihu.com/p/107382276">https://zhuanlan.zhihu.com/p/107382276</a></p><p>​                   <a href="https://blog.csdn.net/qq_34812009/article/details/89020419">https://blog.csdn.net/qq_34812009/article/details/89020419</a></p><blockquote><p>2020/5/12 更新</p></blockquote><ul><li><p>编译器：编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码( <code>object code</code>)。这个转换的过程通常的目的是生成可执行的程序。</p><p>编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。<br>编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。</p></li><li><p>解释器</p><p>在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码预编译成机器码。一个解释器，通常会用以下的姿势来执行程序代码：</p><p>分析源代码，并且直接执行。<br>把源代码翻译成相对更加高效率的中间码，然后立即执行它。<br>执行由解释器内部的编译器预编译后保存的代码<br>可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。<br>不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 <code>Chrome V8</code> 也是这么做的）。<br>解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。</p></li></ul><h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>编译器把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。<br>解释器会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>编译器会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。</p><p>解释器会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。</p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（<code>Intermediate Code</code>）。</p><p>它是由一堆指令集组成的代码，例如在 <code>javac</code> 编译过后的 <code>java</code> 源码产生的就是字节码。</p><p>源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。</p><p>然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。</p><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><p>机器码是一组可以直接被 <code>CPU</code> 执行的指令集，每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。</p><p>所有可以直接被 <code>CPU</code> 执行的程序，都是由这么一系列的指令组成的。机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。</p><p>从熟悉的编程语言的角度来看看<br><img src="http://www.qxnekoo.cn:8888/images/2020/05/12/955b4d512a633d96cda302fdfaf5ee2d.gif" alt="流程.gif"></p><p>从左往右看，</p><p>以 <code>Java</code> 为例，我们在文本编译器写好了 <code>Java</code> 代码，交由「编译器」编译成 <code>Java Bytecode</code>。然后 <code>Bytecode</code> 交由 <code>JVM</code> 来执行，这时候 <code>JVM</code> 充当了「解释器」的角色，在解释 <code>Bytecode</code> 成 <code>Machine Code</code> 的同时执行它，返回结果。</p><p>以 <code>BASIC</code> 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。</p><p>以 C 语言为例，我们在文本编译器编写好源代码，然后运行 <code>gcc hello.c</code> 编译出 <code>hello.out</code> 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。</p><p>此次补充内容来源：<a href="https://blog.csdn.net/weixin_43059285/article/details/104650632">https://blog.csdn.net/weixin_43059285/article/details/104650632</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="2020/04/13/ConcurrentHashMap/"/>
      <url>2020/04/13/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap的问题"><a href="#HashMap的问题" class="headerlink" title="HashMap的问题"></a>HashMap的问题</h2><p>在多线程下，<code>jdk7</code>中的<code>HashMap</code>会导致回型链表，导致<code>get</code>的时候死循环，在<code>jdk8</code>中虽然解决了这个回型链表的问题，但是还是会导致数据错误的问题，所以不能在多线程下使用<code>HashMap</code>。</p><p><code>HashTable</code>虽然线程安全但是效率低下。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>容器里面有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里面不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。</p><p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。<code>Segment</code>是一种可重入锁<code>ReentrantLock</code>，在<code>ConcurrentHashMap</code>里扮演锁的角色，<code>HashEntry</code>则用于存储键值对数据。一个<code>ConcurrentHashMap</code>里包含了一个<code>Segment</code>数组，<code>Segment</code>的结构和<code>HashMap</code>类似，是一种数组和链表结构，一个<code>Segment</code>里包含了一个<code>HashEntry</code>数组，每个<code>HashEntry</code>是一个链表结构的元素，每个<code>Segment</code>守护着一个<code>HashEntry</code>数组里的元素，当对<code>HashEntry</code>数组进行修改时，必须首先获得它对应的<code>Segment</code>锁。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/14/ConcurrentHash7.png" alt="ConcurrentHash7"></p><p><code>Java8</code>的实现已经抛弃了<code>Segment</code>分段锁机制，利用<code>CAS+Synchronized来</code>保证并发更新的安全，数组结构采用：数组+链表+红黑树。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/14/ConcurrentHashMap8.jpg" alt="ConcurrentHashMap8"></p><h2 id="put函数"><a href="#put函数" class="headerlink" title="put函数"></a>put函数</h2><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/14/ConcurrentHashMap_put.jpg" alt="ConcurrentHashMap_put"></p><ul><li>根据<code>key</code> 计算出 <code>hashcode</code> 。</li><li>判断是否需要进行初始化。</li><li><code>f</code> 即为当前 key 定位出的 <code>Node</code>，如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 <code>synchronized</code> 锁写入数据。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h2 id="如何保证-table-只初始化一次"><a href="#如何保证-table-只初始化一次" class="headerlink" title="如何保证 table 只初始化一次"></a>如何保证 table 只初始化一次</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span> <span class="token class-name">K</span> fk<span class="token punctuation">;</span> <span class="token class-name">V</span> fv<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//判断table还未初始化</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化table</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment">// no lock when adding to empty bin</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//...省略一部分源码</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片，</span>        <span class="token comment">//由于sizeCtl是volatile的，保证了顺序性和可见性</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//sc保存了sizeCtl的值</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//cas操作判断并置为-1</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span><span class="token comment">//DEFAULT_CAPACITY = 16，若没有参数则大小默认为16</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP 的两个问题</title>
      <link href="2020/04/10/Spring%20AOP%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
      <url>2020/04/10/Spring%20AOP%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>先说两个结论：</p><blockquote><ol><li><code>Spring</code>事务默认只对<code>RunTimeException</code>或<code>error</code>进行捕获回滚。但是可以通过<code>rollbackFor</code>来指定。</li><li><code>AOP</code>生效的情况必须是代理对象来调用目标方法。</li></ol></blockquote><p>第一条很简单，一般都知道，但是第二条发现网上很多资料或者博客都没有提到这个。</p><p>只有是<code>Spring</code>代理的对象来调用目标方法，事务才会生效，正如上面所说，**不只是事务，只要是<code>Spring</code>做的<code>AOP</code>**，都必须是要代理对象来调用才会生效。</p><p>下面典型的错误示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>A</code>和<code>B</code>都是实现<code>Service</code>层接口中的方法。其实代码运行出来，大部分情况下效果能符合我们的预期，但是<strong>这是错误的用法，因为直接<code>B()</code>，调用B方法的不是Spring的代理对象，而是当前类的对象，<code>AOP</code>不会生效</strong>。</p><p>当有别的地方对<code>B()</code>方法做了<code>AOP</code>,比如说做了个日志记录的<code>Aspect</code>,那么在这边A方法调用<code>B</code>方法的时候，<code>Aspect</code>不会生效。</p><p>或者将<code>B</code>上的<code>@Transactional</code>，改为<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>,从详细的日志也可以看到，执行<code>B</code>方法并没有给我们重新开启一个事务。</p><p>正确的写法：</p><p>在<code>Spring Boot</code>启动类上加上<code>@EnableAspectJAutoProxy(exposeProxy=true)</code>,允许获取代理对象。调用<code>B()</code>方法时:</p><p><code>((T)AopContext.currentProxy()).B()</code></p><p>有机会会把自己之前测得代码拉上来。</p><h2 id="Transaction-rolled-back-because-it-has-been-marked-as-rollback-only"><a href="#Transaction-rolled-back-because-it-has-been-marked-as-rollback-only" class="headerlink" title="Transaction rolled back because it has been marked as rollback-only"></a>Transaction rolled back because it has been marked as rollback-only</h2><p>这个错也很常见，理解起来也不难，在事务默认的传播机制下，<strong>子方法抛出异常，将事务标记为<code>rollback-only</code>,但是父方法调用子方法时<code>try catch</code>了，父方法执行完之后想提交事务发现事务已经是<code>rollback-only</code>了，所以抛出异常。</strong></p><p>这边我仔细拿出来测试了一下，想看一下具体的场景，测试代码很简单，<code>USER</code>和<code>BOOK</code>两个表,各往其插入一条数据，主要是两个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token comment">//@Transactional(rollbackFor = Exception.class)</span><span class="token annotation punctuation">@Transactional</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">userMethod7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    userMapper<span class="token punctuation">.</span><span class="token function">insertOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//USER表插一条数据</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">userMethod8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// userMethod8();</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token comment">//@Transactional(rollbackFor = Exception.class)</span><span class="token annotation punctuation">@Transactional</span><span class="token comment">//@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">userMethod8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    bookMapper<span class="token punctuation">.</span><span class="token function">insertOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//BOOK表插一条数据</span>    <span class="token comment">//throw new Exception("抛出Exception");</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"抛出RunTimeException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个方法都是实现<code>Service</code>层的方法，7 调用 8，因为看网上有人说和<code>Exception</code>和<code>RunTimeException</code>有关，这边我分别都测一下。</p><ul><li>上面先测一下<code>RunTimeException</code>，运行结果</li></ul><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/10/rollback-only.png" alt="rollback-only.png"></p><p>抛出错误。</p><p>表中也无数据，但并不是由于回滚了，而是由于这个错。</p><ul><li>下面测试一下<code>Exception</code>,修改代码：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//@Transactional</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">userMethod7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    userMapper<span class="token punctuation">.</span><span class="token function">insertOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">userMethod8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// userMethod8();     </span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">//@Transactional</span><span class="token comment">//@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">userMethod8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    bookMapper<span class="token punctuation">.</span><span class="token function">insertOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"抛出Exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//throw new RuntimeException("抛出RunTimeException");</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/10/rollback-only.png" alt="rollback-only.png"></p><p>也会报出这个错误。</p><p>还有两种情况：</p><ul><li><p>如果在<code>rollbackFor = Exception.class</code>的情况下去抛出<code>RunTimeException</code>还是会报出这个错，说明<code>Spring</code>即使在<code>rollbackFor = Exception.class</code>下，还是能捕获到<code>RunTimeException</code>。</p></li><li><p>如果在默认情况下（<code>@Transactional</code>）下抛出<code>Exception</code>,并不会报错，程序正常执行完毕，而且发现表中都插入了数据。（其实我想写出这样代码的人应该都是想的是：<strong>如果8方法中出错，只回滚8方法，7方法不要回滚，所以7方法中try catch住</strong>）显然也不符合预期结果。</p><p>如果真的上面这个需求，使用<code>Propagation.REQUIRES_NEW</code>或者<code>Propagation.NESTED</code>,开启一个新的事务或者使用嵌套事务。<strong>使用时要注意，父方法还是要用<code>try catch</code>的，不然错误会在父方法抛出，导致父方法的事务被回滚。</strong></p></li></ul><p><code>Propagation.REQUIRES_NEW</code>不要和我以前一样，认为：<strong>两个不同的事务，子方法出错会回滚，父方法不做任何处理也没有关系，也不会回滚，因为是两个事务。</strong></p><p>上面的观念是错误的，因为父方法不处理，会接着往外抛，导致父方法回滚。</p><p>上面的代码，其实我还测了不使用代理对象来调用的情况，就是<code>userMethod8();  </code>这样调用的方式。结果和上面第四种情况一样，数据全部插进去了。所以一定要注意这些错误的写法。</p><p>总结一下这个错：大概率是在默认的传播机制下，父方法调用子方法时，想要<code>try catch</code>住子方法的错误，达到一种子方法回滚，父方法不回滚的效果。 和<code>Exception</code>和<code>RunTimeException</code>没有关系，两者都会导致这个错。</p><p>—–如果文中有错误，欢迎进行指导。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot 对象</title>
      <link href="2020/04/09/HotSpot%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/04/09/HotSpot%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>对象在<code>Java</code>堆中的分配、布局和访问。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>先进行类加载检查（没有则会执行相应的类加载过程），之后会为对象分配内存大小，<strong>对象所需的内存大小在类加载完成后便可完全确定</strong>。那么如何从<code>Java</code>堆中划分出等大的内存呢？</p><ol><li><strong>指针碰撞</strong>：假设<code>Java</code>堆中的内存是绝对规整的，所有被使用过的放在一边，未被使用过的放在另一边，中间有指针作为指示器，分配内存就是将指针向未被使用的内存空间挪动一段与对象大小相同的距离。</li><li><strong>空闲列表</strong>：如果<code>Java</code>堆中的内存不是规整的，已被使用的和未被使用的交叉在一起，没有办法进行指针碰撞，那么虚拟机就必须维护一个列表，记录哪块内存使用的，哪块内存是未被使用的，在分配的时候找到足够大的空间给对象实例，并更新列表上的记录。</li></ol><p><strong>选择哪种方式是由<code>Java</code>堆是否规整决定的，而是否规整则是由采用的垃圾收集器是否带有空间压缩整理的能力决定的。</strong><code>Serial</code>、<code>ParNew</code>等带压缩整理过程的收集器，系统采用得到算法是指针碰撞，而<code>CMS</code>基于清除算法的收集器，理论上只能使用空闲列表来分配内存了。</p><p>虚拟机创建对象是非常频繁的过程，即使是修改一个指针的位置，在并发的情况下也并不是线程安全的。有两种解决方案：</p><ol><li>对分配内存空间的动作进行同步处理，虚拟机是采用<code>CAS</code>配上失败重试的方式保证更新操作的原子性，但即使这样，也会影响到分配内存的效率。</li><li>本地线程分配缓冲（<code>Thread Local Allocation Buffer,TLAB</code>）：内存分配的动作按照线程划分在不同的空间之中，每个线程在<code>Java</code>堆中预先分配一小块内存。虚拟机是否使用<code>TLAB</code>，通过<code>-XX:+UseTLAB</code>参数来设定。</li></ol><p>内存分配完成之后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了<code>TLAB</code>,这一项工作也可以在<code>TLAB</code>分配时顺便进行。这一步保证了对象的实例字段在代码中可以不赋初始值就直接使用。</p><p>之后会对对象的对象头进行设置。在这些工作完成之后，一个新的对象就已经产生了，接着才是构造函数的执行等等。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/08/508e088fff0acbb9b824d10993991eab.png" alt="对象创建过程.png"></p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（<code>Header</code>）、实例数据（<code>Instance Data</code>）、对齐填充（<code>Padding</code>）。</strong></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>主要分为两部分：</p><ol><li><p>主要用于存储<strong>对象自身的运行时数据</strong>，如<strong>哈希码、<code>GC</code>分代年龄、锁状态标志、线程持有锁、偏向线程<code>ID</code>、偏向时间戳</strong>等。这部分数据长度为32个比特或者64个比特（32位和64位的虚拟机），成为“<code>Mark Word</code>”。为了在极小的空间内存储尽量多的数据，它被设计成一个有这个动态定义的数据结构，根据对象的状态复用自己的存储空间。</p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀（重量级锁）</td></tr><tr><td>空、不需要记录信息</td><td>11</td><td><code>GC</code>标记</td></tr><tr><td>偏向线程<code>ID</code>、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏</td></tr></tbody></table></li><li><p>另一部分是<strong>类型指针</strong>，对象指向它的类型元数据的指针，通过这个指针来确定该对象是哪个类的实例。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/25/HotSpot-.jpg" alt="HotSpot-lock.jpg"></p></li></ol><p>此外，如果对象是一个<code>Java</code>数组，那么<strong>对象头中还必须有一块用于记录数组长度的数据</strong>，因为虚拟机可以通过普通对象的元数据信息来确定普通对象的大小，但是如果数组的长度是不确定的，将无法通过元数据来推断出数组的大小。</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>是对象真正存储的有效信息，即在代码里面所定义的各种类型的字段内容，无论是从父类继承下来的还是在子类中定义的字段都必须记录起来。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>这并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。<code>HotSpot</code>虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，任何对象的大小都必须是8字节的整数倍。对象头部分已经被设计是8字节的倍数（1倍或2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p><code>Java</code>程序通过栈上的<code>reference</code>数据来操作堆上的具体对象，在虚拟机规范中只规定了他是一个指向对象的引用，并能没有定义该怎么去实现，所以对象访问方式也是由虚拟机实现而定的。主流的有两种：</p><ol><li><p>句柄访问，<code>Java</code>堆中可能会划分出一块内存作为句柄池，<code>reference</code>中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/12/818f16cb57eb8a9ef198a27c1e15f95a.png" alt="句柄访问.png"></p></li><li><p>直接指针，<code>Java</code>堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多多一次间接访问的开销。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/12/21d8a8b01f70ebfc6de39faa83645efd.png" alt="直接指针.png"></p></li></ol><blockquote><p>句柄访问的好处<code>reference</code>中存储的是稳定句柄地址，在对象被移动时只会改变句柄的实例数据地址，而<code>reference</code>本身不需要被修改。</p><p>直接指针的最大好处就是速度更快，节省一次指针定位的时间开销，由于对象访问在<code>Java</code>中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p>就<code>HotSpot</code>而言，使用的第二种方式进行对象访问（也是有例外情况的）</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2020/04/09/%E5%8F%8D%E5%B0%84/"/>
      <url>2020/04/09/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p><strong>在<em>运行状态</em>中，对于任意一个类，都能知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为<code>java</code>语言的反射机制。</strong></p><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><table><thead><tr><th>类名</th><th>用途</th></tr></thead><tbody><tr><td><code>Class</code>类</td><td>代表类的实体，在运行的<code>java</code>应用程序中表示类和接口</td></tr><tr><td><code>Field</code>类</td><td>代表类的成员变量</td></tr><tr><td><code>Method</code>类</td><td>代表类的方法</td></tr><tr><td><code>Constructor</code>类</td><td>代表类的构造方法</td></tr></tbody></table><p>获取<code>Class</code>实例的三种常见方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> clazz1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token class-name">Class</span> clazz2 <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Class</span> clazz3 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token class-name">String</span> classPath<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//类的全类名  体现反射的动态性 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>clazz.newInstance();</code>   <code>clazz</code>的类必须要有空的构造方法</p><p><code>clazz.getMethod();</code> 获取该类中所有的<strong>public</strong>方法，包括从父类中继承的。</p><p><code>clazz.getDeclaredMethod();</code>  获取该类（<strong>当前类</strong>）中所有的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn.qxnekoo.advance.reflect.User"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">User</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Method</span> show <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"show"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>show<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>show<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类相关的方法"><a href="#类相关的方法" class="headerlink" title="类相关的方法"></a>类相关的方法</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>asSubclass(Class&lt;U&gt; clazz)</code></td><td>把传递的类的对象转换成代表其子类的对象</td></tr><tr><td><code>Cast</code></td><td>把对象转换成代表类或是接口的对象</td></tr><tr><td><code>getClassLoader()</code></td><td>获得类的加载器</td></tr><tr><td><code>getClasses()</code></td><td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td></tr><tr><td><code>getDeclaredClasses()</code></td><td>返回一个数组，数组中包含该类中所有类和接口类的对象</td></tr><tr><td><code>forName(String className)</code></td><td>根据类名返回类的对象</td></tr><tr><td><code>getName()</code></td><td>获得类的完整路径名字</td></tr><tr><td><code>newInstance()</code></td><td>创建类的实例</td></tr><tr><td><code>getPackage()</code></td><td>获得类的包</td></tr><tr><td><code>getSimpleName()</code></td><td>获得类的名字</td></tr><tr><td><code>getSuperclass()</code></td><td>获得当前类继承的父类的名字</td></tr><tr><td><code>getInterfaces()</code></td><td>获得当前类实现的类或是接口</td></tr></tbody></table><h2 id="类中属性相关的方法"><a href="#类中属性相关的方法" class="headerlink" title="类中属性相关的方法"></a>类中属性相关的方法</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getField(String name)</code></td><td>获得某个公有的属性对象</td></tr><tr><td><code>getFields()</code></td><td>获得所有公有的属性对象</td></tr><tr><td><code>getDeclaredField(String name)</code></td><td>获得某个属性对象</td></tr><tr><td><code>getDeclaredFields()</code></td><td>获得所有属性对象</td></tr></tbody></table><h2 id="类中注解相关的方法"><a href="#类中注解相关的方法" class="headerlink" title="类中注解相关的方法"></a>类中注解相关的方法</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getAnnotation(Class&lt;A&gt; annotationClass)</code></td><td>返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td><code>getAnnotations()</code></td><td>返回该类所有的公有注解对象</td></tr><tr><td><code>getDeclaredAnnotation(Class&lt;A&gt; annotationClass)</code></td><td>返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td><code>getDeclaredAnnotations()</code></td><td>返回该类所有的注解对象</td></tr></tbody></table><h2 id="类中构造器相关的方法"><a href="#类中构造器相关的方法" class="headerlink" title="类中构造器相关的方法"></a>类中构造器相关的方法</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getConstructor(Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td><code>getConstructors()</code></td><td>获得该类的所有公有构造方法</td></tr><tr><td><code>getDeclaredConstructor(Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类中与参数类型匹配的构造方法</td></tr><tr><td><code>getDeclaredConstructors()</code></td><td>获得该类所有构造方法</td></tr></tbody></table><h2 id="类中方法相关的方法"><a href="#类中方法相关的方法" class="headerlink" title="类中方法相关的方法"></a>类中方法相关的方法</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getMethod(String name, Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类某个公有的方法</td></tr><tr><td><code>getMethods()</code></td><td>获得该类所有公有的方法</td></tr><tr><td><code>getDeclaredMethod(String name, Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类某个方法</td></tr><tr><td><code>getDeclaredMethods()</code></td><td>获得该类所有方法</td></tr></tbody></table><h2 id="类中其他重要方法"><a href="#类中其他重要方法" class="headerlink" title="类中其他重要方法"></a>类中其他重要方法</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>isAnnotation()</code></td><td>如果是注解类型则返回true</td></tr><tr><td><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></td><td>如果是指定类型注解类型则返回true</td></tr><tr><td><code>isAnonymousClass()</code></td><td>如果是匿名类则返回true</td></tr><tr><td><code>isArray()</code></td><td>如果是一个数组类则返回true</td></tr><tr><td><code>isEnum()</code></td><td>如果是枚举类则返回true</td></tr><tr><td><code>isInstance(Object obj)</code></td><td>如果obj是该类的实例则返回true</td></tr><tr><td><code>isInterface()</code></td><td>如果是接口类则返回true</td></tr><tr><td><code>isLocalClass()</code></td><td>如果是局部类则返回true</td></tr><tr><td><code>isMemberClass()</code></td><td>如果是内部类则返回true</td></tr></tbody></table><h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>equals(Object obj)</code></td><td>属性与obj相等则返回true</td></tr><tr><td><code>get(Object obj)</code></td><td>获得obj中对应的属性值</td></tr><tr><td><code>set(Object obj, Object value)</code></td><td>设置obj中对应属性值</td></tr></tbody></table><h2 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>invoke(Object obj, Object... args)</code></td><td>传递object对象及参数调用该对象对应的方法</td></tr></tbody></table><h2 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>newInstance(Object... initargs)</code></td><td>根据传递的参数创建类的对象</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized</title>
      <link href="2020/04/08/synchronized/"/>
      <url>2020/04/08/synchronized/</url>
      
        <content type="html"><![CDATA[<p>众所周知 <code>synchronized</code> 关键字是解决并发问题常用解决方案，属于互斥同步，有以下三种使用方式:</p><ul><li>同步普通方法，锁的是当前对象。</li><li>同步静态方法，锁的是当前 <code>Class</code> 对象。</li><li>同步块，锁的是 <code>()</code> 中的对象。</li></ul><p>实现原理：<br><code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对同步块的同步的。</p><p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p><p>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p><p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p><blockquote><p>编译器需要确保方法中调用过的每条<code>monitorenter</code>指令都要执行对应的<code>monitorexit</code> 指令。为了保证在方法异常时，<code>monitorenter</code>和<code>monitorexit</code>指令也能正常配对执行，编译器会自动产生一个异常处理器，它的目的就是用来执行 异常的<code>monitorexit</code>指令。而字节码中多出的<code>monitorexit</code>指令，就是异常结束时，被执行用来释放<code>monitor</code>的。</p></blockquote><p>对于方法，则是使用的是<code>ACC_SYNCHRONIZED</code>标识，<code>JVM</code>通过<code>ACC_SYNCHRONIZED</code>标识，就可以知道这是一个需要同步的方法，进而执行同步的过程。<strong>执行线程将先获取monitor</strong>，获取成功之后才能执行方法体，<strong>方法执行完后再释放monitor</strong>。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><h2 id="Monitor对象-需要去了解对象头"><a href="#Monitor对象-需要去了解对象头" class="headerlink" title="Monitor对象(需要去了解对象头)"></a>Monitor对象(需要去了解对象头)</h2><p>synchronized的对象锁，其指针指向的是一个monitor对象（由C++实现）的起始地址。每个对象实例都会有一个 monitor。其中monitor可以与对象一起创建、销毁；亦或者当线程试图获取对象锁时自动生成。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/20/monitor.png" alt="monitor.png"></p><ul><li><code>Owner</code>：初始时为NULL表示当前没有任何线程拥有该<code>monitor</code>，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li><li><code>EntryQ</code>：关联一个系统互斥锁（<code>semaphore</code>），阻塞所有试图锁住<code>monitor</code>失败的线程。</li><li><code>RcThis</code>：表示<code>blocked</code>或<code>waiting</code>在该<code>monitor</code>上的所有线程的个数。</li><li><code>Nest</code>：用来实现重入锁的计数。</li><li><code>HashCode</code>：保存从对象头拷贝过来的<code>HashCode</code>值（可能还包含<code>GC age</code>）。</li><li><code>Candidate</code>：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。<code>Candidate</code>只有两种可能的值：0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁。</li></ul><p>那么monitor的作用是什么呢？<strong>在 <code>java</code> 虚拟机中，线程一旦进入到被<code>synchronized</code>修饰的方法或代码块时，指定的锁对象通过某些操作将对象头中的<code>LockWord</code>指向<code>monitor</code>的起始地址与之关联，同时<code>monitor</code>中的<code>Owner</code>存放拥有该锁的线程的唯一标识，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码。</strong></p><p>Monitor对象结构：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/25/Monitor.png" alt="Monitor"></p><p>ObjectMonitor:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ObjectMonitor() &#123;    _header       &#x3D; NULL;&#x2F;&#x2F;markOop对象头    _count        &#x3D; 0;    _waiters      &#x3D; 0,&#x2F;&#x2F;等待线程数    _recursions   &#x3D; 0;&#x2F;&#x2F;重入次数    _object       &#x3D; NULL;&#x2F;&#x2F;监视器锁寄生的对象。锁不是平白出现的，而是寄托存储于对象中。    _owner        &#x3D; NULL;&#x2F;&#x2F;指向获得ObjectMonitor对象的线程或基础锁    _WaitSet      &#x3D; NULL;&#x2F;&#x2F;处于wait状态的线程，会被加入到wait set；    _WaitSetLock  &#x3D; 0 ;    _Responsible  &#x3D; NULL ;    _succ         &#x3D; NULL ;    _cxq          &#x3D; NULL ;    FreeNext      &#x3D; NULL ;    _EntryList    &#x3D; NULL ;&#x2F;&#x2F;处于等待锁block状态的线程，会被加入到entry set；    _SpinFreq     &#x3D; 0 ;    _SpinClock    &#x3D; 0 ;    OwnerIsThread &#x3D; 0 ;&#x2F;&#x2F; _owner is (Thread *) vs SP&#x2F;BasicLock    _previous_owner_tid &#x3D; 0;&#x2F;&#x2F; 监视器前一个拥有者线程的ID&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/25/ObjectMonitor.png" alt="ObjectMonitor"></p><p>这部分的内容、原理确实比较复杂，贴上大佬的文章：</p><p><a href="https://www.cnblogs.com/dennyzhangdd/p/6734638.html#_label2">https://www.cnblogs.com/dennyzhangdd/p/6734638.html#_label2</a></p><p><a href="https://mp.weixin.qq.com/s/KFgAY3g4tfuaKumVswID4A">https://mp.weixin.qq.com/s/KFgAY3g4tfuaKumVswID4A</a></p><p>md，把我给看跪了！！！！</p><h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>为了进一步的降低获取锁的代价，<code>JDK1.6</code> 之后还引入了偏向锁。</p><p>偏向锁的特征是:<strong>锁不存在多线程竞争，并且应由一个线程多次获得锁，为了让线程获得锁的代价更低而引入了偏向锁</strong>。</p><p>当线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录存储偏向的线程<code>ID</code>，，以后该线程进入和退出同步块并获取锁时就不需要进行<code>CAS</code>操作来加锁和解锁了，只需要简单地测试一下对象头的<code>Mark Word</code>里是否存贮这执行当前线程的偏向锁。如果测试成功，表示线程已经获取到了锁。如果测试失败，则需要测试一下<code>Mark Word</code>中偏向锁的表示是否设置为1（表示当前是偏向锁）；如果没有设置，则使用<code>CAS</code>竞争锁，如果设置了，则尝试使用<code>CAS</code>将对象头的偏向锁指向当前线程。</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</p><p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 <code>-XX:-userBiasedLocking=false</code> 来关闭偏向锁，并默认进入轻量锁。</p><h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>当代码进入同步块之前，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</p><p>如果更新<strong>成功</strong>，当前线程就获得了锁。</p><p>如果更新<strong>失败</strong> <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。</p><p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p><p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>轻量锁的解锁过程也是利用 <code>CAS</code> 来实现的，会尝试锁记录替换回锁对象的 <code>Mark Word</code> 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为<code>重量锁</code>)</p><p>轻量锁能提升性能的原因是：</p><p>认为大多数锁在整个同步周期都不存在竞争，所以使用 <code>CAS</code> 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 <code>CAS</code> 的开销，甚至比重量锁更慢。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><table><thead><tr><th align="center">锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">偏向锁</td><td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步块的场景</td></tr><tr><td align="center">轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了程序的响应速度</td><td align="center">如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td><td align="center">追求响应时间；同步块执行速度非常快</td></tr><tr><td align="center">重量级锁</td><td align="center">线程竞争不使用自旋，不会消耗CPU</td><td align="center">线程阻塞，响应时间缓慢</td><td align="center">追求吞吐量；同步块执行速度较长</td></tr></tbody></table><p>偏向锁比轻量锁更容易被终结，轻量锁是在有锁竞争出现时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，<strong>这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如果是线程1持有锁，且2也要争夺偏向锁，则直接到轻量级锁状态</strong></p><p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用<code>CAS</code>操作，并将对象头中的<code>ThreadID</code>改成自己的<code>ID</code>，之后再次访问这个对象时，只需要对比<code>ID</code>，不需要再使用<code>CAS</code>在进行操作。</p><p>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象是偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（<strong>偏向锁就是这个时候升级为轻量级锁的</strong>）。<strong>假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如果是线程1持有锁，且2也要争夺偏向锁，则直接到轻量级锁状态</strong></p><p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是<strong>当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止<code>CPU</code>空转。</strong></p><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成，这些操作给系统的并发性能带来了很大的压力。</p><p>如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，我们只需让线程执行一个忙循环（自旋）。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>自旋等待不能代替阻塞，且不说对处理器数量的要求，自选等待本身虽然避免了线程切换的开销，但他是要占用处理器时间的，因此，如果所被占用的时间很少，自旋等待的效果就会很好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白的消耗处理器资源了，而不会做任何有用的工作，反而会带来性能上的浪费。</p><h4 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h4><p>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:</p><blockquote><p>如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</p></blockquote><p>如果自同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而他将允许自旋等待持续相对更长的时间，比如100个循环。</p><p>如果对于某个锁，自旋很少成功过，那在以后要获取这个所示将可能省略掉自旋过程，以避免浪费处理器时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全的实现</title>
      <link href="2020/04/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/04/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<ol><li>互斥同步</li><li>非阻塞同步</li><li>无同步方案</li></ol><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p><strong>同步</strong>是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者一些，当使用信号量时）线程使用。</p><p><strong>互斥</strong>是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥方式。</p><p>互斥是方法，同步是目的。</p><p><code>java</code>最基础的互斥同步实现就是<code>synchronized</code>关键字，在执行<code>monitorenter</code>指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器增加一，而在执行<code>monitorexit</code>指令时会将锁计数器减一。一旦计数器的值为0，所就被释放了，如果获取对象锁失败了，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p><ul><li><code>synchroniezd</code>修饰的同步块是可重入的。意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>它会无条件地阻塞其他线程进入，没法强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><p>除了<code>synchronized</code>关键字外，还提供了<code>Lock</code>接口来实现互斥同步手段。<code>ReentrantLock</code>是<code>Lock</code>接口的最常见的实现。多了一些高级功能:</p><ol><li>等待可中断：正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li>公平锁：按照申请锁的时间顺序来依次获得锁；非公平锁不保证这一点。<code>synchronized</code>是非公平的，<code>ReentrantLock</code>在默认情况下也是非公平的。一旦使用公平锁，会导致性能下降，影响吞吐量。</li><li>锁绑定多个条件：一个<code>ReentrantLock</code>可以同时绑定多个<code>Condition</code>对象。<code>synchronized</code>则需要额外添加一个锁。</li></ol><p>如何选择：</p><ol><li><code>synchronized</code>是在语法层面的同步，足够清晰，也足够简单。</li><li><code>Lock</code>应该确保在<code>finally</code>释放锁，否则可能永远都不会释放持有的锁。使用<code>synchronized</code>则有虚拟机来确保即使出现异常，锁也会自动释放。</li><li>性能上其实并没有相差很远（<code>jdk5</code>之后）。虚拟机更容易对<code>synchronzed</code>进行优化。</li></ol><h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步面临的问题是<strong>进行线程阻塞和唤醒所带来的性能开销</strong>，所以也叫做阻塞同步。</p><p>需要“硬件指令集的发展”。</p><p>是一种基于冲突检测的乐观并发策略，不管风险，先进行操作，如果没有其他线程征用共享数据，那操作就直接成功了；如果共享数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施就是不断地重试，直到出现没有竞争的共享数据为止。</p><p>因为需要<strong>要求操作和冲突检测这两个步骤具备原子性</strong>（不可能使用互斥同步来保证），只能使用硬件。</p><p>最常用的就是<code>CAS</code>，使用<code>cmpxchg</code>指令完成。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁优化</title>
      <link href="2020/04/06/%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>2020/04/06/%E9%94%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="自旋锁与自适应锁"><a href="#自旋锁与自适应锁" class="headerlink" title="自旋锁与自适应锁"></a>自旋锁与自适应锁</h2><p><strong>互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态去完成。</strong></p><p>如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时执行，就可以让后面请求锁的线程稍等一会儿，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋等待本身虽然避免了线程切换的开销，但它姚占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，但是如果时间比较长，自旋只会白白消耗处理器资源，而不会做任何有价值的工作，会带来性能的浪费。所以，如果自旋尝试一定次数后还是没有获得锁，就会以传统的方式挂起线程。</p><p><code>jdk6</code>中引入了适应性锁。意味着自旋的时间不是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。</p><blockquote><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能成功，进而允许自旋等待持续相对更长的时间。</p><p>另一方面，如果对于某个锁，自旋很少成功获得过锁，在那以后要获取这个锁时将很有可能直接省略掉自旋过程，以避免浪费处理器资源。</p></blockquote><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无需在进行。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>编写代码时推荐将同步块的作用范围限制尽量小，这样是为了使得需要同步的操作数量尽可能变少，等待锁的线程也尽可能快地拿到锁。</p><p>大部分情况下是正确的。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步也会导致不必要的性能损耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM</title>
      <link href="2020/04/04/JMM/"/>
      <url>2020/04/04/JMM/</url>
      
        <content type="html"><![CDATA[<p><code>Java</code>内存模型的目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p><p>这里的变量包括了实例字段、静态字段和构成数组对象的元素，不包括局部变量与方法参数，因为就这是线程私有的，不会被共享，自然就不会存在竞争问题。</p><p>定义：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。本地内存是<code>JMM</code>的一个抽象概念，并不真实存在。线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。（<code>volatile</code>变量依然有工作内存的拷贝，但是由于他特殊的操作顺序行，所以看起来如同直接在主内存中读写一样）</p><p>再简明地说一下：</p><blockquote><p>Java 内存模型，<strong>其实是保证了 Java 程序在各种平台下对内存的访问都能够得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</strong></p><p>Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>除此之外，Java 内存模型还提供了一系列原语，封装了底层实现后，供开发者直接使用。如我们常用的一些关键字：synchronized、volatile 以及并发包等。</p></blockquote><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/19/JMM.png" alt="JMM"></p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，java 内存模型中定义了一下 8 种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外）。</p><ul><li>lock（锁定）：作用于主内存的变量，他把一个变量表示为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，他把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li><li>load（载入）：作用于主内存的变量，他把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，他把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用域工作内存的变量，他把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，他把工作内存中的一个变量的值传送到主内存中，一边随后的 write 操作使用。</li><li>write（写入）：作用于主内存的变量，他把 store 操作从工作内存中得到的变量值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。注意，java 内存模型只要求上述两个操作是可插入指令的，如对主内存中的变量 a、b 进行访问时，一种可能出现的顺序是 read a、read b、load b、load a。除此之外，java 内存模型还规定了在执行上述8种基本操作必须满足很多规则。</p><p>由于这种定义相当严谨但又十分繁琐，实践起来很麻烦，所以有一个等效判断原则————先行发生原则，用来确定在一个访问在并发环境下是否安全。</p><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>它是<code>Java</code>内存模型中定义的两项操作之间的偏序关系。是判断数据是否存在竞争，线程是否安全的手段。可以通过几条简单规则来解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><blockquote><p>如果<code>Java</code>内存模型中所有的有序性都依靠<code>volatile</code>和<code>synchronzed</code>来完成，那么很多操作都会很啰嗦，但是我们在写代码的时候并没有察觉到这个，就是因为有这个先行发生原则的存在。</p></blockquote><h3 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h3><ol><li><p>A先行发生于B操作。</p><p>在发生操作B之前，操作A产生的影响能够被B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法。</p></li></ol><p>一些“天然的先行发生关系”：</p><ul><li>程序次序规则：<strong>在一个线程内</strong>，按照<strong>控制流</strong>的顺序，书写在前面的操作先行发生于书写在后面的操作。（是控制流，因为要考虑分支、循环等结构）</li><li>管程锁定规则：一个<code>unlock</code>操作先行发生于后面（时间上的顺序）对<strong>同一个锁</strong>的<code>lock</code>操作。</li><li><code>volatile</code>变量规则：对一个<code>volatile</code>变量的写操作先行发生于后面对这个<code>volatile</code>变量的读操作。</li><li>线程启动规则：<code>Thread</code>对象的<code>start()</code>操作先行发生于此线程的每一个动作。</li><li>线程终止规则：线程中所有操作都先行发生于对此线程的终止检测。</li><li>线程中断规则：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则：一个对象的初始化完成先行发生于他的<code>finalize()</code>方法的开始。</li><li>传递性：如果A先行发生于B，B先行发生于C，那么可以得到结论：A先行发生于C。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类变量和 Class 对象存放的区域</title>
      <link href="2020/04/01/%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8CClass%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
      <url>2020/04/01/%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8CClass%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>先说结论：</p><p><code>JDK7</code>之后及其以后的版本的<code>HotSpot</code>虚拟机选择把静态变量和<code>Java</code>类的<code>Class</code>对象存放在一起，<strong>存储与<code>Java</code>堆中</strong>。换句话说，<code>JDK8</code> 中，<strong>两者都位于堆（Heap），且static 成员变量位于 Class对象内。</strong></p><p>字符串常量池也是放在堆中的。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/04/14/795e3782f39e2f9eb500e3940470a897.png" alt="图1.png"></p><p>当调用 <code>intern</code> 方法时，<strong>如果池已经包含一个等于此String对象的字符串（用 <code>equals(oject)</code> 方法确定），则返回池中的字符串。否则，将此 <code>String</code> 对象添加到池中，并返回此 <code>String</code> 对象的引用。</strong></p><p>那么<code>jdk</code>中的元空间是用来干嘛的？</p><p>元空间的出现就是为了解决突出的类和类加载器元数据过多导致的<code>OOM</code>问题，而从<code>jdk7</code>中开始永久代经过对方法区的分裂后已经几乎只存储类和类加载器的元数据(不是<code>Class</code>对象，可能是一串二进制字节流)信息了，到了<code>jdk8</code>，元空间中也是存储这些信息。</p><p>在<code>Java8</code>中，元空间(<code>Metaspace</code>)登上舞台，方法区存在于元空间(<code>Metaspace</code>)。同时，元空间不再与堆连续，而且是存在于本地内存（<code>Native memory</code>）。</p><p>本地内存（<code>Native memory</code>），也称为<code>C-Heap</code>，是供<code>JVM</code>自身进程使用的。当<code>Java Heap</code>空间不足时会触发<code>GC</code>，但<code>Native memory</code>空间不够却不会触发<code>GC</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="2020/03/29/volatile/"/>
      <url>2020/03/29/volatile/</url>
      
        <content type="html"><![CDATA[<h2 id="保证变量的可见性"><a href="#保证变量的可见性" class="headerlink" title="保证变量的可见性"></a>保证变量的可见性</h2><p><code>volatile</code>修饰的变量对所有线程都具有可见性，这边的可见性主要是说，新值对于其他线程来说是立即得知的。</p><p><em><code>volatile</code> 修饰之后并不是让线程直接从主内存中获取数据，依然需要将变量拷贝到工作内存中</em>。当一个变量被 <code>volatile</code> 修饰时，任何线程对它的<strong>写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空</strong>，必须从主内存重新读取最新数据。</p><p>当我们需要在两个线程间依据主内存通信时，通信的那个变量就必须的用 <code>volatile</code> 来修饰。</p><ol><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol><p>实际上，这些条件表明，可以被写入 <code>volatile</code> 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。需要保证操作是原子性操作（<code>volatile</code>不具有原子性），才能保证使用volatile关键字的程序在并发时能够正确执行。</p><h2 id="保证顺序性（禁止重排序）"><a href="#保证顺序性（禁止重排序）" class="headerlink" title="保证顺序性（禁止重排序）"></a>保证顺序性（禁止重排序）</h2><p>禁止指令重排序，例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> value <span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> fasle <span class="token punctuation">;</span><span class="token comment">//以下方法发生在线程 A 中 初始化 Map</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//耗时操作</span>value <span class="token operator">=</span> <span class="token function">getMapValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">//1</span>flag <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">;</span><span class="token comment">//2</span><span class="token punctuation">&#125;</span><span class="token comment">//发生在线程 B中 等到 Map 初始化成功进行其他操作</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//dosomething</span><span class="token function">doSomeThing</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就能看出问题了，当 <code>flag</code> 没有被 <code>volatile</code> 修饰时，<code>JVM</code> 对 1 和 2 进行重排，导致 <code>value</code> 都还没有被初始化就有可能被线程 B 使用了。</p><p>还有就是双重检测机制了，这里就不细说了，主要是因为会对<code>new</code>对象的汇编指令进行重排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//防止指令重排</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有<code>volatile</code>修饰的变量，赋值后多执行了一个”<code>lock add1 0x0,(%esp)</code>“操作，这个操作的作用相当于一个<strong>内存屏障</strong>，重排序时，不能把后面的指令重排序到内存屏障之前的位置。如果只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性了。</p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"flag 被修改成 true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序结束,i="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个程序的在<code>java8</code>服务端的运行情况，即程序不会停止，一直在循环。虽然知道单纯<code>flag</code>变量无法保证在线程之间的可见性，但为什么程序会一直执行下去？后台线程修改<code>flag</code>变量虽然暂时是对主线程不可见的，但难道后台线程的工作内存一直不会将值刷新到主内存吗？主线程也一直在从自己的工作内存中取值，而不是从主内存拿值？</p><p><strong>多线性并发时，如果 A 线程修改了共享变量，此时 B 线程感知不到此共享变量的变化，叫做活性失败。</strong></p><p>因为编译器对代码进行了优化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//变成了</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种优化是可以接受的，叫做提升（<code>hoisting</code>）,编译器会帮我们做一些大部分经典的优化动作：无用代码消除、循环展开、<strong>循环表达式外提</strong>、消除公共子表达式、常量传播、基本块重排序等。</p><p><strong>这个提升是<code>JIT</code>帮我们做的</strong>，循环表达式外提。</p><p>还是一样的代码，禁用了 <code>JIT </code>的优化（添加虚拟机参数：<code>-Djava.compiler=NONE</code>）。程序正常运行结束了。</p><p>综上，如何解释为什么程序不会正常结束了：</p><blockquote><p>由于变量<code>flag</code>没有被<code>volatile</code>修饰，而且子线程休眠的<code>100ms</code>中，<code>while</code>循环的<code>flag</code>一直为<code>false</code>,循环到一定的次数后，触发了<code>jvm</code>的即时编译功能，进行了循环表达式外提（Loop Expression Hoisting），导致形成死循环。而如果加了<code>volatile</code>去修饰<code>flag</code>变量，保证了<code>flag</code>的可见性，则不会进行提升。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口</title>
      <link href="2020/03/29/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>2020/03/29/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ol><li>抽象类使用<code>abstract</code>关键字修饰；接口使用<code>interface</code>修饰。</li><li>抽象类中有构造方法，但不能是实例化；接口没有构造方法。</li><li>抽象类可以有非抽象方法；接口中有抽象方法，在<code>java8</code>后接口提供了默认方法，使用<code>default</code>修饰，并且不强制实现类重写此方法。</li><li>抽象类中可以有变量；接口中只能是常量（默认修饰符为<code>final</code>）。</li><li>实现类只能继承一个抽象类；但可以实现多个接口。</li><li>继承类对抽象类的方法可以不选择重写；实现类必须重写接口中的所有方法。</li></ol><p><strong>从形态上看：</strong></p><p>抽象类可以给出一些成员的实现，接口却不包含成员的实现（<code>java8</code>中提供了<code>default</code>,可以有方法体）。</p><p>抽象类的抽象方法可被子类部分实现，接口的成员需要实现类完全实现，一个类只能继承一个实现类，却可以实现多个接口。</p><p><strong>区分：</strong></p><ol><li><p>类是对对象的抽象，抽象类是对类的抽象</p><p>接口是对行为的抽象</p></li><li><p>行为跨越不同类的对象，可使用接口</p><p>一些相似的类对象，用继承抽象类</p></li><li><p>抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类；</p><p>接口是根本不知子类的存在，方法如何实现还不确认，预先定义。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="2020/03/29/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>2020/03/29/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到虚拟机外部去实现。这个动作的代码被称为“类加载器（<code>Class Loader</code>）”</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身译器共同确立其在<code>Java</code>虚拟机的唯一性每一个类加载器，都拥有一个独立的类名称空间。</p><p>也就是说比较两个类是否“相等”，必须在同一个类加载器加载的前提下才有意义，否则即使两个类来源同一个<code>Class</code>文件，被同一个虚拟机加载，只要加载它们的类加载器不同，它们就必定不相等。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>定义：</p><p>当某个类加载器需要加载某个<code>.class</code>文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</p><p><code>JDK8</code>及之前版本来介绍三层类加载器。</p><ul><li>启动类加载器（<code>BootStrap Class Loader</code>）:负责加载存放在<code>JAVA_HOME\lib</code>目录，而且是虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载其无法被<code>Java</code>程序直接引用，因为它是用<code>C++</code>来实现的。</li><li>扩展类加载器（<code>Extension Class Loader</code>）:这个加载器是以<code>Java</code>代码实现的，负责加载<code>JAVA_HOME\lib\ext</code>目录中，是一种<code>Java</code>系统类库的扩展机制，允许用户将具有通用性的类库放置在<code>ext</code>目录以扩展<code>Java SE</code> 的功能，<code>JDK9</code>之后，这种扩展机制被模块化带来的天然的扩展能力所取代。</li><li>应用程序类加载器（<code>Application Class Loader</code>）:也是用<code>Java</code>代码实现的，它负责加载用户类路径上所有的类库，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序默认的类加载器。</li></ul><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/19/48634f49e381dacca0fd9f5836e50c17.png" alt="类加载器1"></p><p>或者看下图：</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/05/13/2.jpg" alt="类加载器2.jpg"></p><p><code>Java9</code>之前的应用都是由这三类加载器互相配合来完成加载的。自定义类加载器典型的有增加除了磁盘位置之外的<code>Class</code>文件来源，或者通过类加载器实现类的隔离、重载等功能。</p><p>类加载器的父子关系并不是继承的关系实现的，而是使用组合关系来复用父加载器的代码。</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>如果一个类加载器收到了类加载的请求，他首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己去完成加载。</p><blockquote><p>好处：<code>Java</code>中的类随着他的类加载器一起具备了一种带有优先级的层次关系。比如<code>java.lang.Object</code>，它存放在<code>rt.jar</code>中，无论哪一个类加载器要加载这个类，最终都会被委派给最顶端的启动类加载器进行加载。</p><p>可以避免类的重复加载，另外也避免了java的核心API被篡改。</p></blockquote><blockquote><p><code>Java9</code>模块化的关键目标—–可配置的封装隔离机制</p></blockquote><blockquote><p>时间 2020/5/13 更新</p></blockquote><p>在实际的应用中双亲委派解决了java 基础类统一加载的问题，但是却着实存在着一定的缺陷。<strong>jdk中的基础类作为用户典型的api被调用，但是也存在api调用用户的代码的情况</strong>，典型的如SPI代码。</p><p>所以jdk开发人员就引入了<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>，这类类加载器可以通过java.lang.Thread 类的setContextClassLoader方法进行设置。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li><p>JDBC</p><p>在JDBC4.0以后，开始支持使用spi的方式来注册这个Driver，具体做法就是在mysql的jar包中的META-INF/services/java.sql.Driver 文件中指明当前使用的Driver是哪个，然后使用的时候就直接这样就可以了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> conn<span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到这里直接获取连接，省去了Class.forName()注册过程。步骤：</p><p>第一，从META-INF/services/java.sql.Driver文件中获取具体的实现类名“com.mysql.jdbc.Driver”</p><p>第二，加载这个类，这里肯定只能用Class.forName(“com.mysql.jdbc.Driver”)来加载</p><p>好了，问题来了，Class.forName()加载用的是调用者的Classloader，这个调用者DriverManager是在rt.jar中的，ClassLoader是启动类加载器，而com.mysql.jdbc.Driver肯定不在<JAVA_HOME>/lib下，所以肯定是无法加载mysql中的这个类的。<strong>这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。</strong></JAVA_HOME></p><p>按照目前情况来分析，这个mysql的drvier只有应用类加载器能加载，那么我们只要在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。<br> <strong>线程上下文类加载器可以通过Thread.setContextClassLoaser()方法设置，如果不特殊设置会从父类继承，一般默认使用的是应用程序类加载器</strong></p><p><strong>很明显，线程上下文类加载器让父级类加载器能通过调用子级类加载器来加载类，这打破了双亲委派模型的原则</strong>。</p><p>以下的代码是DriverManager的初始化方法loadInitialDrivers，大家可以从中看到先是获取jdbc.drivers属性，得到类的路径。然后通过系统类加载器加载。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/05/13/3.jpg" alt="代码段1.jpg"></p><p>然后我们看下ServiceLoader.load()的具体实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> service<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ClassLoader</span> cl <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> service<span class="token punctuation">,</span>                                        <span class="token class-name">ClassLoader</span> loader<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到核心就是拿到线程上下文类加载器，然后构造了一个ServiceLoader,接下来，DriverManager的loadInitialDrivers()方法中有一句<strong>driversIterator.next();</strong>,它的具体实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">S</span> <span class="token function">nextService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNextService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> cn <span class="token operator">=</span> nextName<span class="token punctuation">;</span>    nextName <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//此处的cn就是产商在META-INF/services/java.sql.Driver文件中注册的Driver具体实现类的名称</span>        <span class="token comment">//此处的loader就是之前构造ServiceLoader时传进去的线程上下文类加载器</span>        c <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fail</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span>             <span class="token string">"Provider "</span> <span class="token operator">+</span> cn <span class="token operator">+</span> <span class="token string">" not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//省略部分代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们成功的做到了通过线程上下文类加载器拿到了应用程序类加载器（或者自定义的然后塞到线程上下文中的），同时我们也查找到了厂商在子级的jar包中注册的驱动具体实现类名，这样我们就可以成功的在rt.jar包中的DriverManager中成功的加载了放在第三方应用程序包中的类了。</p></li></ol><p>这个时候我们再看下整个mysql的驱动加载过程:</p><ul><li>第一，获取线程上下文类加载器，从而也就获得了应用程序类加载器（也可能是自定义的类加载器）</li><li>第二，从META-INF/services/java.sql.Driver文件中获取具体的实现类名“com.mysql.jdbc.Driver”</li><li>第三，通过线程上下文类加载器去加载这个Driver类，从而避开了双亲委派模型的弊端</li></ul><p>很明显，mysql驱动采用的这种spi服务确确实实是破坏了双亲委派模型的，毕竟做到了父级类加载器加载了子级路径中的类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC 常用并发工具类</title>
      <link href="2020/03/26/JUC%E5%B8%B8%E7%94%A8%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>2020/03/26/JUC%E5%B8%B8%E7%94%A8%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作。</p><p>定义了一个就计数器和一个阻塞队列，当计数器的值递减为0之前，阻塞队列里面的线程处于挂起状态，当计数器递减为0时会唤醒阻塞队列所有线程，在<code>CountDownLatch</code>上等待的线程就可以恢复执行接下来的任务。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//构造方法，创建一个值为count 的计数器。</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//阻塞当前线程，将当前线程加入阻塞队列。</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在timeout的时间之内阻塞当前线程,时间一过则当前线程可以执行，</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>CountDownLatch</code>是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当<code>CountDownLatch</code>使用完毕后，它不能再次被使用。</p></blockquote><p>这个的用法还是比较简单的。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code>是一个同步辅助类，它允许一组线程互相等待，直到所有线程都到达某个公共屏障点（也可以叫同步点），即互相等待的线程都完成调用<code>await</code>方法，所有被屏障拦截的线程才会继续运行<code>await</code>方法后面的程序。</p><blockquote><ol><li><code>CyclicBarrier(int parties, Runnable barrierAction)</code> 创建一个<code>CyclicBarrier</code>实例，<code>parties</code>指定参与相互等待的线程数，<code>barrierAction</code>指定当所有线程到达屏障点之后，首先执行的操作。</li><li><code>CyclicBarrier(int parties) </code>创建一个<code>CyclicBarrier</code>实例，parties指定参与相互等待的线程数。</li><li><code>getParties() </code>返回参与相互等待的线程数。</li><li><code>await()</code> 该方法被调用时表示当前线程已经到达屏障点，<strong>当前线程阻塞进入休眠状态</strong>，直到所有线程都到达屏障点，当前线程才会被唤醒。</li><li><code>await(long timeout, TimeUnit unit)</code> 该方法被调用时表示当前线程已经到达屏障点，当前线程阻塞进入休眠状态，在<code>timeout</code>指定的超时时间内，等待其他参与线程到达屏障点；如果超出指定的等待时间，则抛出<code>TimeoutException</code>异常，如果该时间小于等于零，则此方法根本不会等待。</li><li><code>isBroken()</code> 判断此屏障是否处于中断状态。如果因为构造或最后一次重置而导致中断或超时，从而使一个或多个参与者摆脱此屏障点，或者因为异常而导致某个屏障操作失败，则返回<code>true</code>；否则返回<code>false</code>。</li><li><code>reset()</code> 将屏障重置为其初始状态。</li><li><code>getNumberWaiting() </code>返回当前在屏障处等待的参与者数目，此方法主要用于调试和断言。</li></ol></blockquote><h3 id="与-CountDownLatch-的区别"><a href="#与-CountDownLatch-的区别" class="headerlink" title="与 CountDownLatch 的区别"></a>与 CountDownLatch 的区别</h3><p>最主要的是<code>CountDownLatch</code>只能使用一次，而<code>CyclicBarrier</code>计数器可以循环使用，也可以使用<code>reset()</code>方法重置。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">concurrent</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">BrokenBarrierException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CyclicBarrier</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cycle</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token class-name">CyclicBarrier</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><blockquote><p>main:2<br>Thread-0:1<br>Thread-0:3<br>main:22<br>Thread-1:11<br>Thread-1:3</p></blockquote><p>可以看虽然是设定了2的值，但是是可以循环的，回调函数在一次循环结束之后调用。</p><p><strong>使用时一定要注意下一次循环开始不要在上一个循环的回调函数之前执行。</strong></p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>叫做信号量，有两个目的，一个是多个共享资源互斥使用，第二个是并发线程数的控制。</p><p><code>Semaphore</code>用于限制可以访问某些资源（物理或逻辑的）的线程数目，他维护了一个许可证集合，有多少资源需要限制就维护多少许可证集合，假如这里有<code>N</code>个资源，那就对应于<code>N</code>个许可证，同一时刻也只能有N个线程访问。一个线程获取许可证就调用<code>acquire</code>方法，用完了释放资源就调用<code>release</code>方法。</p><p><code>Semaphore</code>的构造方法<code>Semaphore(int permits)</code>接受一个整型的数字，表示可用的许可证数量。<code>Semaphore(10)</code>表示允许10个线程获取许可证，也就是最大并发数是10。</p><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">concurrent</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Semaphore</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Semap</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THREAD_COUNT <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> es <span class="token operator">=</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Semaphore</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>THREAD_COUNT<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    s<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"save data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    s<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        es<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区域</title>
      <link href="2020/03/19/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
      <url>2020/03/19/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>虚拟机在执行<code>Java</code>程序的时候会把他所管理的内存划分为若干个不同的数据区域，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而自动建立和销毁。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/11/JVM_RUNTIME_MEMORY.png" alt="JVM_RUNTIME_MEMORY.png"></p><ul><li>程序计数器（<code>Program Counter Register</code>）</li><li>Java虚拟机栈(<code>Java Virtual Machine Stack</code>)</li><li>本地方法栈(<code>Native Method Stacks</code>)</li><li>Java堆(<code>Java Heap</code>)</li><li>方法区(<code>Method Area</code>)</li><li>运行时常量池(<code>Runtime Constant Pool</code>) [是方法区的一部分]</li><li>直接内存(<code>Direct Memory</code>)[不是规范定义的内存区域，但会被频繁使用]</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>较小的一块内存空间，可以看作是当前线程所执行的<strong>字节码的行号指示器</strong>，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是<strong>程序控制流的指示器</strong>，<em>分支、循环、跳转、异常、线程恢复</em>等基础功能都要依赖这个计数器来完成。</p><p>每条线程都需要一个独立的程序计数器，各条线程之间计数器不影响，独立存储，这类内存区域为“线程私有”的内存。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>虚拟机栈描述的是<code>Java</code>方法执行的线程内存模型：每个方法被执行的时候，<code>Java</code>虚拟机都会同步创建一个栈帧（<code>Stack Frame</code>）用于<strong>存储局部变量表</strong>、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。它也是线程私有的，生命周期与线程相同。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>其中最主要的还是局部变量表这一部分。它存放了编译期可知的各种<code>Java</code>虚拟机基本数据、对象引用和<code>returnAddress</code>类型。</p><p>这些数据类型在局部变量表中的存储空间以局部变量槽（<code>Slot</code>）来表示，其中<code>64</code>位长度的<code>long</code>和<code>double</code>类型的数据会占用两个变量槽，其余的数据类型只会占用一个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在<strong>栈帧中分配多大的局部变量空间是完全确定的</strong>，在方法运行期间不会改变局部变量表的大小（指的是局部变量槽的数量，一个<code>slot</code>占多大的空间是由虚拟机自行决定的）。</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常，比如递归。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈发挥的作用非常相似，区别：<strong>虚拟机栈为虚拟机执行<code>Java</code>方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（<code>Native</code>）方法服务。</strong></p><p><code>HotSpot</code>虚拟机将本地方法栈和虚拟机栈合二为一。</p><blockquote><p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。一个 Native Method 是这样的一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所持有，很多其他的编程语言都有这一机制，比如在 C++ 中，可以用 <code>extern C</code> 告知 C++ 编译器去调用一个 C 的函数。</p><ul><li>Java 方法是由 Java 编写的，编译成字节码，存储在 class 文件中</li><li>本地方法是由其他语言编写的，编译成和处理器相关的机器代码</li><li>本地方法保存在动态链接库中，即 .dll(windows 系统)文件中，格式是各个平台专有的</li><li>Java 方法是与平台无关的，但是本地方法不是</li></ul></blockquote><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><code>Java</code>堆</h3><p>虚拟机管理内存最大的一块，<strong>被所有线程共享的一块内存区域</strong>。虚拟机规范中表明：“所有的对象实例以及数组都应当在堆上分配”。但目前从“实现”的角度上来看，由于即时编译技术的进步，逃逸分析、栈上分配等等已经导致一些微妙的变化发生，所以说对象实例都在堆上分配也不是那么绝对。</p><p><strong>从回收内存的角度来看</strong>，它是垃圾收集器管理的内存区域，由于现代大部分垃圾收集器都是基于<strong>分代收集理论</strong>设计的，所以<code>Java</code>堆中经常会出现“新生代”、“老年代”、“Eden空间”、“From Survivor空间”、“To Survivor空间”（以后会细讲）。但其实到今天，即使是<code>HotSpot</code>里面也出现了不采用分代设计的新垃圾收集器。</p><p><strong>从分配内存的角度来看</strong>，所有线程共享的堆内存中可以划分出多个<strong>线程私有的分配缓冲区</strong>（<code>Thread Local Allocation Buffer,TLAB</code>）,以提升对象分配时的效率。</p><p>无论从哪个角度、如何划分，<code>Java</code>堆细分的目的只是为了<strong>更好地回收内存，或者更好的分配内存</strong>。</p><p><code>Java</code>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象（比如说数组对象），很可能会要求连续的内存空间。</p><p>堆无法扩展时，虚拟机会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<code>JVM</code>规范中把方法区描述为堆的一个逻辑部分。其实物理上也是一块连续的内存。</p><p>在<code>java8</code>之前,<code>HotSpot</code>虚拟机使用永久代来实现方法区，使得垃圾收集器能够像管理<code>Java</code>堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但对于其他虚拟机来说是不存在永久代的概念的。</p><p>到<code>jdk7</code>的时候，已经把放在永久代的字符串常量池、静态变量等移出，而到了<code>jdk8</code>,则完全废弃了永久代的概念，把剩余的内容（主要是类型信息）全部移到元空间中去。</p><p>相对而言，这个区域的垃圾收集行为是比较少出现的。回收目标主要是针对常量池的回收和对类型的卸载，尤其是类型的卸载，效果比较难令人满意。</p><p>如果方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分，<code>Class</code>文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池表（<code>Constatn Pool Table</code>），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>并不是虚拟机运行时数据区的一部分，也不是<code>JVM</code>规范的内存区域，但这部分内存也被频繁使用，而且也可能导致<code>OutOfMemoryError</code>异常出现。</p><p><code>NIO</code>是一种基于通道（<code>Channel</code>）与缓冲区（<code>Buffer</code>）的<code>I/O</code>方式，它可以是使用<code>Native</code>函数库直接分配堆外内存，然后通过一个存储在<code>Java</code>堆里面的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。</p><p>本机直接内存不会受到<code>Java</code>堆大小的限制，但是，肯定会受到本机总内存大小以及处理器寻址空间的限制。如果各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配与回收策略</title>
      <link href="2020/03/19/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>2020/03/19/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>最根本的目标是自动化解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。</p><h2 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h2><p>对象在新生代<code>Eden</code>区中分配。当<code>Eden</code>区没有足够空间进行分配时，虚拟机将发起一次<code>minor GC</code>。</p><p><code>-XX:+PrintGCDetails</code>告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存区域分配情况。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>避免大对象的原因是：在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而复制对象的时候，大对象就意味着高额的内存复制开销。提供了<code>-XX:PertenureSizeThreshold</code>参数，指定大于该设置值的对象直接在老年代分配，防止在<code>Eden</code>和<code>Survivor</code>来回复制，产生大量内存复制操作。</p><p>该参数只对<code>Serial</code>和<code>ParNew</code>两款新生代收集器有效，<code>parallel Scavenge</code>并不支持这个参数，可以使用<code>CMS</code>和<code>ParNew</code>的收集器组合。</p><h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>虚拟机给每个对象定义了一个对象年龄计数器，存储在<strong>对象头</strong>中，对象通常在<code>Eden</code>区诞生，如果经过第一次<code>Minor GC</code>后仍然存活，并且能够被<code>Survivor</code>容纳的话，该对象会被移动到<code>Survivor</code>中，并将其对象年龄设置成1岁。对象在<code>Survovir</code>中每熬过一次<code>Minor GC</code>，年龄就增加一岁，年龄增加到一定程度（默认15），就会被晋升到老年代中。晋升的阈值可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>虚拟机并不是要求对象的年龄必须达到<code>-XX:MaxTenuringThreshold</code>才能晋升老年代，<strong>如果在<code>Survivor</code>空间中相同年龄所有对象的大小总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到<code>-XX:MaxTenuringThreshold</code>中要求的年龄</strong>。</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在发生<code>Minor GC</code>之前，虚拟机要先检查老年代最大可用的连续空间是否大于新生代所有对象和总空间，如果这个条件成立，那这一次<code>Minor GC</code>可以确保是安全的。如果不成立，虚拟机会先查看<code>-XX:HandlePromotionFailure</code>参数设置值是否允许担保失败。</p><p>如果允许担保失败，那么就会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>GC</code>是有风险的。</p><p>如果小于或者不允许担保，那么会直接进行一次<code>Full GC</code>。</p><blockquote><p>风险是指新生代使用清除-复制算法，有可能在<code>Minor GC</code>之后还有大量对象存活，这些对象<code>Survivor</code>容不下，只能直接送入老年代。如果担保失败了，只能发起一次<code>Full GC</code>。</p></blockquote><p><code>JDK6</code>之后，<code>-XX:HandlePromotionFailure</code>参数不会影响到虚拟机的空间分配担保策略。只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行<code>Minor GC</code>，否则将进行<code>Full GC</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="2020/03/19/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>2020/03/19/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>Java</code>虚拟机把描述类的数据从<code>Class</code>文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的<code>java</code>类型，这个过程被称为虚拟机的类加载机制。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型的生命周期（加载到虚拟机内存开始，到卸载出内存为止）：<strong>加载、<em>验证、准备、解析</em>、初始化、使用和卸载</strong>七个阶段。</p><p>验证、准备、解析又叫做“连接”。</p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始。解析阶段则不一定。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/19/cbcf6c373529c90ecb292f0b8ccde5e0.jpg" alt="类加载机制.jpg"></p><p>有且只有六种情况必须立即对类进行初始化（而加载、验证、准备自然是在此前开始），需要先触发其初始化阶段。</p><ul><li><p>遇到<code>new、getstatic、putstatic或invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。典型代码场景有：</p><ul><li>使用<code>new</code>关键字实例化对象的时候。</li><li>读取或设置一个类型的静态字段（被<code>final</code>修饰、一在编译期把结果放入常量池的静态字段除外）的时候</li><li>调用一个类型的静态方法</li></ul></li><li><p>使用<code>java.lang.reflect</code>包对类型进行反射调用的时候，如果类型没有被初始化，则需要先触发其初始化。</p></li><li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</p></li><li><p>虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。</p></li><li><p>使用<code>JDK7</code>新加入的动态语言支持时，需要先触发其初始化</p></li><li><p>一个接口中定义了<code>JDK8</code>新加入的默认方法（被<code>default</code>关键字修饰的接口方法），如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>即加载、验证、准备、解析、初始化这五个阶段所执行的具体操作</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>主要完成三件事</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各个数据访问入口</li></ol><p>数组类的类型元素还是靠类加载器来完成加载。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接的第一步，目的是确保<code>Class</code>文件的字节流中包含的信息符合虚拟机规范的全部约束要求，是虚拟机自我保护的一项必要措施。</p><ol><li>文件格式验证：字节流是否符合<code>Class</code>文件格式的规范。这阶段是基于二进制字节流进行的，通过这个阶段的字节流才被允许进入<code>java</code>虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</li><li>元数据验证：是对字节码描述的信息进行<strong>语义分析</strong>，也就是对类的元数据信息阱行语义校验。比如类是否继承了不允许被继承的类等等……</li><li>字节码验证：通过对数据流分析和控制流分析，确定程序语义是否是合法的、符合逻辑的，对类的方法体进行校验分析。</li><li>符号引用验证：发生在将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生，该类i是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类中定义的变量（即静态变量，被static修饰的变量，不包括实例对象）分配内存并设置类变量初始值的阶段。应当在方法区分配，但在<code>JDK8</code>之后，类变量则会随着<code>Class</code>对象存放在<code>Java</code>堆中</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典垃圾收集器</title>
      <link href="2020/03/18/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2020/03/18/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>并行：多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在工作，用户线程默认是处于等待状态的。</li><li>并发：垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行，此时应用程序的处理的吞吐量将受到一定影响。</li></ol><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/16/8acc580aa08b3d2051dad2e3d26fdeaa.jpg" alt="垃圾收集器.jpg"></p><h2 id="Serial-收集器（新生代）"><a href="#Serial-收集器（新生代）" class="headerlink" title="Serial 收集器（新生代）"></a>Serial 收集器（新生代）</h2><p>是一个单线程工作的收集器，不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/16/Serial.jpg" alt="Serial.jpg"></p><p>对运行在客户端模式下的虚拟机来说是一个很好的选择。</p><h2 id="ParNEW-收集器（新生代）"><a href="#ParNEW-收集器（新生代）" class="headerlink" title="ParNEW 收集器（新生代）"></a>ParNEW 收集器（新生代）</h2><p>是<code>Serial</code>收集器的多线程并行版本</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/16/ParNew.jpg" alt="ParNew.jpg"></p><p>支持多线程并行收集，除了<code>Serial</code>收集器外，目前只有它能与<code>CMS</code>收集器配合工作，但从<code>JDK9</code>开始，<code>ParNew</code>和<code>CMS</code>收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。而且取消了 <code>-XX:+UseParNewGC</code>参数，意味着<code>ParNew</code>和<code>CMS</code>只能相互搭配使用，再也没有其他收集器和它们配合，可以理解为<code>ParNew</code>合并进入<code>CMS</code>，成为它专门处理新生代的组成部分。</p><h2 id="CMS-收集器（老年代）"><a href="#CMS-收集器（老年代）" class="headerlink" title="CMS 收集器（老年代）"></a>CMS 收集器（老年代）</h2><p>是一种以获取最短回收停顿时间为目标的收集器，使用的是<strong>标记-清除</strong>算法，经常适用于互联网网站和基于浏览器的<code>B/S</code>系统的服务器上，这类应用通常会关注服务的响应速度，希望系统停顿时间尽可能短。</p><p>第一款真正意义上支持并发的垃圾收集器，首次实现了让垃圾收集线程与用户线程（基本上）同时工作。分为四个步骤：</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/16/CMS.png" alt="CMS.png"></p><p><code>CMS</code> 以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需<code>STW</code> 才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有<strong>两次短暂的暂停（初始标记和重新标记）</strong>，<strong>达到了近似并发的目的</strong>。</p><p>主要优点：并发收集、低停顿</p><p>缺点：</p><ol><li>占用系统资源，降低总吞吐量</li><li>无法处理“浮动垃圾”，主要是并发标记和并发清理阶段，程序还在运行，自然伴随着新的垃圾对象产生。如果垃圾收集阶段无法给用户线程提供足够的内存空间，会触发“并发失败（<code>Current Mode Failure</code>）”。启动预备方案，临时启用<code>Serial Old</code>收集器来重新进行老年代的垃圾收集，这样停顿时间就更长了。</li><li>使用标记-清除算法，导致收集结束后有空间碎片产生，会给分配大对象带来麻烦。<code>CMS</code>提供了<code>-XX:+UseCMSCompactAtFullCollection</code>(默认是开启的，此参数从<code>JDK9</code>废弃)，用于在<code>CMS</code>收集器不得不进行<code>Full GC</code>时开启内存碎片整理合并过程，但涉及到移动对象，无法并发，空间碎片问题解决了，但是停顿时间会变长。又提供一个参数<code>-XXL:CMSFullGCsBeforeCompaction</code>(此参数从<code>JDK9</code>废弃)，表示在若干次不整理空间的<code>Full GC</code>之后，下一次进入<code>Full GC</code>前会先进行碎片整理（默认值为0，表示每次进入<code>Full GC</code>前都进行碎片整理）。</li></ol><h2 id="Parallel-Scavenge-收集器（新生代）"><a href="#Parallel-Scavenge-收集器（新生代）" class="headerlink" title="Parallel Scavenge 收集器（新生代）"></a>Parallel Scavenge 收集器（新生代）</h2><p>是一款新生代收集器，基于标记-复制算法，能够并行收集的多线程收集器。和其他收集器不同，<code>CMS</code>关注尽可能的缩短垃圾收集时用户线程的停顿时间，而<code>Parallel Scavenge</code>收集器的目标则是达到一个<strong>可控制的吞吐量（处理器用于运行用户代码的时间与处理器总消耗时间的比值）</strong>。</p><blockquote><p>停顿时间短适合需要与用户交互或者保证服务响应的质量，良好的相应速度能提升用户体验；而高吞吐量则可以高效率地利用处理器资源，尽快完成程序的运算任务，适合于在后台运算而交互不多的场景。</p></blockquote><p>控制吞吐量的两个参数<code>-XX:MaxGCPauseMillis</code>(控制最大垃圾收集停顿时间)、<code>-XX:GCTimeRatio</code>(直接设置吞吐量大小)，不要把停顿时间设的太小，主要是以牺牲吞吐量和新生代空间为代价的，会导致垃圾收集频繁。停顿时间会下降，但吞吐量也会下降。</p><p>示意图和<code>parallel Old</code>一样。</p><h3 id="自适应调节策略"><a href="#自适应调节策略" class="headerlink" title="自适应调节策略"></a>自适应调节策略</h3><p><code>-XX:+UseAdaptiveSizePolicy</code>，是一个开关，当这个参数被激活的时候，不需要人工指定新生代大小、<code>Eden</code>和<code>Survivor</code>比例、晋升老年代对象的大小等细节参数了，虚拟机会根据系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><p>它也是和<code>ParNew</code>收集器区别之一。</p><h2 id="Serial-Old-收集器（标记-整理）"><a href="#Serial-Old-收集器（标记-整理）" class="headerlink" title="Serial Old 收集器（标记-整理）"></a>Serial Old 收集器（标记-整理）</h2><p>是<code>Serial</code>收集器的老年代版本，单线程收集器，使用标记-整理算法。</p><p>在客户端模式中可以使用。</p><p>在服务端模式下，有两种用途：</p><ol><li>在<code>JDK 5</code>之前的版本中与<code>Parallel Scavenge</code>收集器搭配使用。</li><li>在<code>CMS</code>收集器失败时（“并发失败”）的后备方案。</li></ol><p>示意图和<code>Serial</code>收集器一样</p><h2 id="Parallel-Old-收集器（标记-整理）"><a href="#Parallel-Old-收集器（标记-整理）" class="headerlink" title="Parallel Old 收集器（标记-整理）"></a>Parallel Old 收集器（标记-整理）</h2><p>是<code>Parallel Scavenge</code>收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。在<code>JDK6</code>提供，至此，“吞吐量优先”收集器有了名副其实的搭配，在注重吞吐量或处理器资源不足的情况下，可以考虑使用<code>Parallel Old</code>和<code>Parallel Scavenge</code>收集器这个组合。</p><p><img src="http://www.qxnekoo.cn:8888/images/2020/03/16/Parallel-OldParallel-Scavenge.jpg" alt="Parallel-OldParallel-Scavenge.jpg"></p><h2 id="Garbage-First-收集器（重点）"><a href="#Garbage-First-收集器（重点）" class="headerlink" title="Garbage First 收集器（重点）"></a>Garbage First 收集器（重点）</h2><p>也成为<code>G1</code>收集器，<strong>开创了收集器面向局部收集的设计思路和基于<code>Region</code>的内存布局形式</strong>。之前所有的垃圾收集器包括<code>CMS</code>，垃圾收集的目标要么是整个新生代（<code>Minor GC</code>），要么是这个老年代（<code>Major GC</code>），要么就是整个堆（<code>Full GC</code>）,<code>G1</code>则跳出了这个模式。想要建立起“<strong>停顿时间模型</strong>”的垃圾收集器，也就是能够支持指定在一个长度为<code>M</code>毫米的时间片段内，消耗在垃圾收集上的时间大概率不超过<code>N</code>毫秒这样的目标。</p><p><code>G1</code>提供并发的类卸载功能的支持，是一款主要面向服务器应用的垃圾收集器，期望可以替换掉<code>CMS</code>收集器。<code>JDK9</code>中<code>G1</code>取代了<code>Parallel Scavnege</code>和<code>Parallel Old</code>组合，称为服务端模式下默认的垃圾收集器，而<code>CMS</code>则已不被推荐了。</p><p><code>G1</code>可以面向对内存的任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是<code>G1</code>收集器的<code>Mixed GC</code>模式。</p><p>其开创的基于<code>Region</code>的内存布局是实现整个目标的关键，虽然仍是遵循分代收集理论设计的，但和其他收集器有着明显的差别。</p><blockquote><p>不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 <code>Java</code> 堆划分为多个大小相等的独立区域(<code>Region</code>)，每一个<code>Region</code>都可以根据需要，扮演新生代的<code>Eden</code>空间、<code>Survivor</code>空间，或者老年代空间。收集器能够对扮演不同角色的<code>Region</code>采用不同的策略去处理。新生代、老年代都是一系列（不需要连续）的动态集合。</p></blockquote><p><code>Region</code>中还有一类特殊的<code>Humongous</code>的区域，专门用来存储大对象。只要大小超过了一个<code>Region</code>容量一半的对象即可判定为大对象。对于超过了整个<code>Region</code>容量的超级大对象，将会存放在<code>N</code>个连续的<code>Humongous Region</code>之中，<code>G1</code>的大多数行为都把<code>Humongous Region</code>作为老年代的一部分来进行看待。</p><p>之所以能够建立<strong>可预测的停顿时间模型</strong>，是因为将<code>Region</code>作为单次回收的最小单元，即每次收集到的内存空间都是<code>Region</code>大小的整数倍，有计划地避免在整个<code>Java</code>堆中进行全区域的垃圾收集。</p><p>具体的做法是让<code>G1</code>收集器去跟踪各个<code>Region</code>里面的垃圾堆积的“价值大小”，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户允许设定的收集停顿时间（默认200毫秒），优先处理回收价值收益最大的那些<code>region</code>,这就是<code>Garbage First</code>名字的由来。<strong>这种使用<code>Region</code>划分内存空间，以及具有优先级的区域回收方式，保证了<code>G1</code>收集器在有限的时间内获取尽可能高的收集效率。</strong></p><p>可以由用户指定期望的停顿时间是很强大的一个功能，但是这个期望值必须是符合实际的。如果停顿时间太短，会导致每次回收的回收集只占堆内存很小的一部分空间，收集器的速度跟不上分配器的分配速度，导致垃圾慢慢堆积，时间长了会引发<code>Full GC</code>降低性能，一般来说设置为一两百毫秒或者两三百毫秒比较合理。（参数<code>-XX:MaxGCPauseMillis</code>,默认值200）</p><p>相比<code>CMS</code>，优点有如下：</p><ol><li>指定最大停顿时间</li><li>分<code>Region</code>的内存布局</li><li>按收益动态确定回收集</li><li><code>G1</code>整体上来看是基于“标记-整理的算法”，但从局部上来看（两个<code>Region</code>之间）又是基于“标记-复制”算法实现，意味着运作期间不会产生空间内存碎片，垃圾收集完成之后能提供规整的可用内存，有利于程序的长时间运作。</li></ol><p>缺点：</p><ol><li>无论是垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比<code>CMS</code>要高。</li><li>处理跨代指针，<code>G1</code>卡表实现更为复杂。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾算法细节名词</title>
      <link href="2020/03/15/%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E5%90%8D%E8%AF%8D/"/>
      <url>2020/03/15/%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E5%90%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<ol><li><p>根节点枚举：收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此会和整理碎片一样面临”<code>stop the world</code>“的困扰。当用户进程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。<code>HotSpot</code>使用一组称为<code>OopMap</code>的数据结构来达到这个目的。</p></li><li><p>安全点：虚拟机不会为每条指令生成<code>OopMap</code>，只是在特定的位置上记录这些，这些位置称为安全点，用户线程必须执行到安全点后才能够暂停。安全点的选定不能太少让收集器等很长时间，也不能太多过分增大运行时的内存负荷。例如方法调用、循环跳转、异常跳转等都属于指令序列复用，只有具有这些功能的指令才会产生安全点。</p><p>并且采用主动中断的思想让所有的线程都跑到最近的安全点，不直接对线程操作，仅仅简单设置一个标志位，各个线程在执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志和安全点是重合的。轮询操作是频繁出现的，<code>HotSpot</code>把它精简至只有一条汇编指令的程度。</p></li><li><p>安全区域：安全点保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是当用户线程处于<code>Sleep</code>状态或者<code>Block</code>状态，这时候线程无法响应虚拟机的中断请求，不能走到安全的地方中断挂起自己。这种情况就引入了安全区域。</p><p>指能够确保在某一段代码之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的，可以是看作扩展拉伸了的安全点。</p><p>当线程运行到安全区域的代码时，回去表示自己进入到了安全区域，这段时间里虚拟机要发起垃圾收集时就不必去管那些已声明自己在安全区域内的线程了。线程离开安全区域之后，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生，继续执行；否则它就必须一直等待，知道收到可以离开安全区域的信号为止。</p></li><li><p>记忆集和卡表：为解决对象跨代引用带来的问题，垃圾收集器在新生代中建立了名为记忆集的数据结构，用以避免把整个老年代加进<code>GC Roots</code>扫描范围。卡表是记忆集的一种实现方式。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象存活和引用</title>
      <link href="2020/03/14/%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%92%8C%E5%BC%95%E7%94%A8/"/>
      <url>2020/03/14/%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%92%8C%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>哪些内存需要回收？</p></blockquote><p>在<code>Java</code>内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。当方法结束或者线程结束的时候，内存自然就跟着回收了。</p><p>而<code>Java</code>堆和方法区有着不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，才知道会创建多少个对象。这部分内存的分配和回收是动态的。</p><h2 id="对象是否已死"><a href="#对象是否已死" class="headerlink" title="对象是否已死"></a>对象是否已死</h2><ol><li>引用计数算法</li><li>可达性分析法</li></ol><ul><li><p>引用计数法</p><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效的时候，计数器值就减1；任何时刻，计数器为零的对象就是不可能在被使用的。</p><p>优点：原理简单，判定效率高。</p><p>缺点：需要配合大量额外处理才能保证正确性，因为单纯的引用计数很难解决<strong>对象之间相互引用</strong>的问题。</p><p><code>java</code>虚拟机并不是通过引用计数算法来判断对象是否存活。</p></li><li><p>可达性分析算法</p><p>通过一系列称为“<code>GC Roots</code>”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，所有过程所走过的路径称为“引用链”，如果某个对象到”<code>GC Roots</code>“间没有任何引用链相连，即不可达，则证明此对象是不可能再被使用的。</p><p>可作为<code>GC Roots</code>的对象包括：</p><ol><li>虚拟机栈中引用的对象，各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量</li><li>在方法区中类静态属性引用的对象，譬如<code>Java</code>类的引用类型静态变量</li><li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li><li>本地方法栈中<code>JNI</code>引用的对象</li><li>虚拟机内部的引用，基本数据类型对应的<code>class</code>对象，一些常驻的移仓对象，还有系统类加载器。</li><li>所有被同步锁持有的对象</li><li>反映<code>Java</code>虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地代码缓存等。</li></ol></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集中仍然非常紧张，那就可以抛弃这些对象。</p><p><code>Java</code>中的引用：强引用、软引用、弱引用、虚引用。</p><ul><li>强引用：类似<code>Object o = new Object()</code>这种关系，无论在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li>软引用：一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。(<code>SoftReference</code>)</li><li>弱引用：强度比软引用弱一些，，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，不管当前内存是否足够，都会回收掉弱引用关联的对象。(<code>WeakReference</code>)</li><li>虚引用：最弱的引用关系，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。目的是为了这个对象在被回收时能够收到一个系统通知。（<code>PhantomReference</code>）</li></ul><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>主要分为两个内容：<strong>废弃常量和不再使用的类型</strong></p><ol><li><p>废弃常量</p><p>举例：假设“<code>java</code>”字符串曾进入过字符串常量池，但是当前系统没有任何一个字符串对象的值是“<code>java</code>”,换句话说，已经没有任何字符串对象引用常量池中的“<code>java</code>”常量，且虚拟机中也没有其他地方引用这个字面量。如果这个时候发生垃圾回收，而且判断有必要的话，这个字符串就会被清除出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p></li><li><p>不再使用的类型就比较苛刻了，需要同时满足三个条件</p><ul><li>该类的所有实例已经被回收，也就是<code>java</code>堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载已被回收，这个条件除非是经过设计的可替换类加载器的场景，比如说<code>OSGI、JSP</code>的重载，否则很难达成</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li></ol><p>在大量使用反射、动态代理、<code>CGLib</code>等字节码框架，动态生成<code>JSP</code>以及<code>OSGI</code>这类频繁自定义类加载器的场景中，通常需要<code>Java</code>虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLAB 解读</title>
      <link href="2020/03/12/TLAB/"/>
      <url>2020/03/12/TLAB/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虚拟机创建对象、分配内存是很频繁的一件事，那么，在多线程运行的情况下，怎么保证虚拟机在堆中给对象划分内存时候的线程安全？</p><p>其实虚拟机有两种解决方案：</p><ol><li>对虚拟机划分内存的这个动作进行<strong>同步操作</strong>，可能通过<code>CAS</code>和失败重试机制来保证线程安全。（不管什么同步方式，太过频繁都会影响分配内存的效率）</li><li>使用<code>TLAB(Thread Local Allocation Buffer)</code>。</li></ol><p>虚拟机并不是只采用一种方案，而是在具体的情况下使用某一个，或者两者结合使用。</p><h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><blockquote><p>每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。</p></blockquote><p>这块内存就是<code>TLAB</code>，是从堆中的<code>eden</code>划分出来的一块专用区域，在<code>TLAB</code>功能启用的情况下，线程初始化时，虚拟机会为每个线程分配一块<code>TLAB</code>空间，只给当前线程使用，线程如果需要给对象分配空间，就在自己的<code>TLAB</code>上分配，减少竞争的情况，提升效率。</p><p><strong>这一块内存可以看作是线程独享的，但是只是在“分配”这个动作上独享的，至于在读取、垃圾回收等动作上都是线程共享的，而且在使用上也没什么区别。</strong>也就是说其他线程是可以访问到别的线程的<code>TLAB</code>，但是不会在上面分配自己的内存。</p><p>在<code>TLAB</code>分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过<code>TLAB</code>分配内存，存放在<code>Eden</code>区，但是还是会被垃圾回收或者被移到<code>Survivor Space</code>、<code>Old Gen</code>等。</p><p>因为<code>TLAB</code>本身并不是很大，必然存在一些大对象无法在<code>TLAB</code>直接分配，这种情况下，对象还是可能在<code>eden</code>或者老年代进行分配，但这种分配就需要同步控制了。所以说：<strong>小的对象比大的对象分配起来更加高效。</strong></p><h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><p><code>TLAB</code>并不是很大，有可能出现不够的情况，一般有两种方案：</p><ol><li>如果一个对象需要的空间大小超过<code>TLAB</code>中剩余的空间大小，则直接在堆内存中对该对象进行内存分配。</li><li>如果一个对象需要的空间大小超过<code>TLAB</code>中剩余的空间大小，则废弃当前<code>TLAB</code>，重新申请<code>TLAB</code>空间再次进行内存分配。</li></ol><p>以上两个方案各有利弊，如果采用方案1，那么就可能存在着一种极端情况，就是<code>TLAB</code>只剩下<code>1KB</code>，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。</p><p>如果采用方案2，也有可能存在频繁废弃<code>TLAB</code>，频繁申请<code>TLAB</code>的情况，但是<code>TLAB</code>内存自己从堆中划分出来的过程确实可能存在冲突的，所以，<code>TLAB</code>的分配过程其实也是需要并发控制的。而频繁的<code>TLAB</code>分配就失去了使用<code>TLAB</code>的意义。</p><p><strong>为了解决这两个方案存在的问题，虚拟机定义了一个<code>refill_waste</code>的值，这个值可以翻译为“最大浪费空间”。</strong></p><p>当请求分配的内存大于<code>refill_waste</code>的时候，会选择在堆内存中分配。若小于<code>refill_waste</code>值，则会废弃当前<code>TLAB</code>，重新创建<code>TLAB</code>进行对象内存分配。</p><blockquote><p><code>TLAB</code>总空间<code>100KB</code>，使用了<code>80KB</code>，剩余<code>20KB</code>，设置的<code>refill_waste</code>的值为<code>25KB</code>，那么如果新对象的内存大于<code>25KB</code>，则直接堆内存分配，如果小于<code>25KB</code>，则会废弃掉之前的那个<code>TLAB</code>，重新分配一个<code>TLAB</code>空间，给新对象分配内存。</p></blockquote><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><p><code>TLAB</code>功能是可以选择开启或者关闭的，可以通过设置<code>-XX:+/-UseTLAB</code>参数来指定是否开启<code>TLAB</code>分配。</p><p><code>TLAB</code>默认是<code>eden</code>区的1%，可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置<code>TLAB</code>空间所占用<code>Eden</code>空间的百分比大小。</p><p>默认情况下，<code>TLAB</code>的空间会在运行时不断调整，使系统达到最佳的运行状态。如果需要禁用自动调整<code>TLAB</code>的大小，可以使用<code>-XX:-ResizeTLAB</code>来禁用，并且使用<code>-XX：TLABSize</code>来手工指定<code>TLAB</code>的大小。</p><p><code>TLAB</code>的<code>refill_waste</code>也是可以调整的，默认值为64，即表示使用约为1/64空间大小作为<code>refill_waste</code>，使用参数：<code>-XX：TLABRefillWasteFraction</code>来调整。</p><p>如果想要观察<code>TLAB</code>的使用情况，可以使用参数<code>-XX+PringTLAB</code> 进行跟踪。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>TLAB</code>的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试<code>TLAB</code>分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再<code>eden</code>分配还是在老年代分配。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream</title>
      <link href="2020/02/18/stream/"/>
      <url>2020/02/18/stream/</url>
      
        <content type="html"><![CDATA[<ol><li>stream自己不会存储元素</li><li>stream不会改变源对象，相反，他们会返回一个持有结果的新stream</li><li>stream操作是延迟的。这意味着他们会等到需要结果的时候才执行</li></ol><p>步骤</p><ul><li><p>创建stream</p><p>一个数据源，获取一个流</p></li><li><p>中间操作</p><p>一个中间操作链，对数据源的数据进行处理</p></li><li><p>终止操作</p><p><strong>一旦执行终止操作，才执行中间操作链，并产生结果。之后，不会再被使用</strong></p></li></ul><p>中间操作</p><p>多个中间操作可以连接起来形成一个流水线，<strong>除非流水线上触发终止操作，否则中间操作不会执行任何处理</strong>！而在终止操作时一次性全部处理，称为惰性求值。</p><ol><li><p>筛选与切片</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filter(Predicate p)</td><td>接受lambda，从流中排除某些元素，返回true时保留该元素，false过滤掉</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成的hashCode()和equals()去除重复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过指定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补</td></tr></tbody></table></li><li><p>映射</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>map(Function f)</td><td>接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td></tr><tr><td>mapToDouble(ToDoubleFunction f</td><td>接受一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</td></tr><tr><td>mapToInt(ToIntFunction f)</td><td>接受一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream</td></tr><tr><td>MapToLong(ToLongFunction f)</td><td>接受一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</td></tr><tr><td>flapMap(Function f)</td><td>接受一个函数作为参数，将六种的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table></li><li><p>排序</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table></li></ol><p>终端操作</p><p>终端操作会从流的流水线上生成结果。其结果可以是任何不是流的值，例如：List、Intger，甚至是void。</p><ol><li><p>匹配与查找</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中元素总数</td></tr><tr><td>max(Comparator c)</td><td>返回流中元素最大值</td></tr><tr><td>min(Comparator c)</td><td>返回流中最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代</td></tr></tbody></table></li><li><p>归约</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden,BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回Optional/&lt;/T/&gt;</td></tr></tbody></table></li><li><p>收集</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其它形式。接受一个Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p>Collectors类中提供了很多的静态方法供我们使用。</p><p>比如<code>toList()</code>、<code>toSet()</code>、<code>toMap()</code>等。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口</title>
      <link href="2019/11/03/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>2019/11/03/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>只有一个函数的接口。</p><h1 id="四大核心函数式接口"><a href="#四大核心函数式接口" class="headerlink" title="四大核心函数式接口"></a>四大核心函数式接口</h1><table><thead><tr><th align="center">函数式接口</th><th align="center">参数类型</th><th align="center">返回类型</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">Consumer/&lt;/T/&gt;消费性接口</td><td align="center">T</td><td align="center">void</td><td align="center">对类型为T的对象应用操作，包含方法：void accept(T t)</td></tr><tr><td align="center">Supplier/&lt;/T/&gt;供给性接口</td><td align="center">无</td><td align="center">T</td><td align="center">返回类型为T的对象，包含方法：T get()</td></tr><tr><td align="center">Function&lt;T,R&gt;函数型接口</td><td align="center">T</td><td align="center">R</td><td align="center">对类型为T的对象应用操作，并返回结果，结果类型是R的对象，包含方法：R apply(T t)</td></tr><tr><td align="center">Predicate/&lt;/T/&gt;断定性接口</td><td align="center">T</td><td align="center">boolean</td><td align="center">确定类型为T的对象是否满足某约束，并返回boolean值。包含方法： boolean test(T t)</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2019/09/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2019/09/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>其属于创建型模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类对象。</p><ul><li><p>优点</p><p>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。</p><p>避免对资源的多重占用（比如写文件操作）。</p></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>如果一个类对外提供了public的构造方法，那么外界就可以任意创建该类的对象。所以，要想限制对象的产生，一个办法就是将构造函数变为私有的（至少是受保护的），使外面的类不能通过引用来产生对象。同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>简单的单例实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//创建一个Singleton对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Sileton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将构造方法设为私有的</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">//向外提供获取这个对象的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过static的静态初始化方式，在该类第一次被加载的时候，就有一个Singleton的实例被创建出来了，这样就保证在第一次使用该对象的时候后，他已经被初始化好了。</p><p>由于该<strong>实例在类被加载的</strong>时候就创建出来了，所以也避免了线程安全问题</p><blockquote><p>饿汉式单例，在类被加载的时候就会实例化。这也许会造成不必要的消耗，因为可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。解决方法：静态内部类的形式、懒汉式。</p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 静态内部类/类初始化   该方式不会出现线程安全的问题，即使发生重排序，其他线程也是无法看到的 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerClassSingleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//在静态内部类中初始化实例对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span>  <span class="token class-name">StaticInnerClassSingleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticInnerClassSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//私有的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">StaticInnerClassSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">//对外提供获取实例的静态方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StaticInnerClassSingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样利用classloder的机制来保证初始化instance时只有一个线程。</p><p>差别：饿汉式只要类被装载了，那么instance就会被实例化（没有达到lazy loading的效果）。而内部静态类的方法，在StaticInnerClassSingleton被加载的时候，INSTANCE不一定会被初始化，因为SingletonHolder没有被主动使用，因为只有显式通过调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化INSTANCE。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>在该对象真正被使用的时候才会实例化的单例模式—懒汉模式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//声明变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LazySingleton</span> lazySingleton<span class="token punctuation">;</span>    <span class="token comment">//私有的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">//对外提供获取对象的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LazySingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazySingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lazySingleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> lazySingleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>懒汉式是不会提前将对象初始化出来，只有当调用getInstance方法的时候才会去初始化对象，如果已经初始化过了，那么就返回初始化好的对象。</p><p>但是，上面的代码有一个致命的问题：</p><p>存在线程安全问题，在多线程的情况下，如果两个或者两个以上线程同时进入if语句中，并且对象也没有被初始化，那么么这些线程就会去new一个对象（这些对象都不是同一个对象）出来。</p><h3 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h3><p>给创建对象的步骤加锁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizeLazySingleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//声明变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SynchronizeLazySingleton</span> synchronizeLazySingleton<span class="token punctuation">;</span>    <span class="token comment">//私有的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">SynchronizeLazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//对外提供获取对象的方法 对该方法加锁</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">SynchronizeLazySingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>synchronizeLazySingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            synchronizeLazySingleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizeLazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> synchronizeLazySingleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是加了一个synchronized关键字，很简单，但是上面的效率很低，因为99%的情况下是不需要做同步处理的。上面的写法时该方法执行都需要同步，但是其实只有第一次创建的情况下才需要同步，其他的情况都是直接return synchronizeLazySingleton就可以了，是不需要做同步的。</p><h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><p>锁的范围既然太大了，只要缩小锁的范围就可以了:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizeLazySingletonAdvance</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//声明变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SynchronizeLazySingletonAdvance</span> synchronizeLazySingleton<span class="token punctuation">;</span>    <span class="token comment">//私有的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">SynchronizeLazySingletonAdvance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//对外提供获取对象的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">SynchronizeLazySingletonAdvance</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>synchronizeLazySingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// problem</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SynchronizeLazySingletonAdvance</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>synchronizeLazySingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    synchronizeLazySingleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizeLazySingletonAdvance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> synchronizeLazySingleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样不是新建对象的线程就不需要走synchronized块了，与上面相比，双重校验就是用来缩小synchronized块的。再准确点说就是，第一个判断是判断线程是否要走synchroniezd快，第二个判断就是判断走synchronized块的线程是否需要去创建对象。</p><p>这样看来，实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率。但还是存在隐患，主要和JMM有关。</p><p>假设A线程进入synchronized块对对象进行初始化，由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化<strong>之前</strong>，更新变量并将其指向<strong>部分初始化的对象</strong>。</p><p>线程B发现共享变量已经被初始化并返回变量，但此时变量仍没有被完全初始化。在A完成初始化之前共享变量对B可见，引起这个问题。</p><ul><li><p>问题的根源</p><p>instance = new Singleton();创建一个对象，分解为如下三步代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">memory <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//1.分配对象的内存空间</span><span class="token function">ctorInstance</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2.初始化对象</span>instance <span class="token operator">=</span> memory<span class="token punctuation">;</span>     <span class="token comment">//3.设置instance指向刚分配的内存地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在2和3中，可能会被重排序（在JIT编译器上，这种重排序是真实发生的）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">memory <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//1.分配对象的内存空间</span>instance <span class="token operator">=</span> memory<span class="token punctuation">;</span>     <span class="token comment">//3.设置instance指向刚分配的内存地址</span>                       <span class="token comment">//此时对象还没有被初始化</span><span class="token function">ctorInstance</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2.初始化对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不正确的实现双重检查锁导致异常结果可能会间歇性出现，重现异常是十分困难的。</p></li></ul><h3 id="使用volatile"><a href="#使用volatile" class="headerlink" title="使用volatile"></a>使用volatile</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * volatile */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileSingleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serilizable</span><span class="token punctuation">&#123;</span>    <span class="token comment">//声明变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">VolatileSingleton</span> synchronizeLazySingleton<span class="token punctuation">;</span>    <span class="token comment">//私有的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">VolatileSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//对外提供获取对象的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">VolatileSingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>synchronizeLazySingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">VolatileSingleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>synchronizeLazySingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    synchronizeLazySingleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolatileSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> synchronizeLazySingleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//该方法可以防止序列化对单例的破坏</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> synchronizeLazySingleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个解决了刚才提到的问题，<strong>volatile关键字禁止重排序</strong>（volatile还有其他作用，这边不详说）。</p><p>这种方式遇到序列化的时候也可能存在问题。readResolve()方法可以帮忙解决。</p><h3 id="使用final"><a href="#使用final" class="headerlink" title="使用final"></a>使用final</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FinalWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">T</span> value<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">FinalWrapper</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalSingleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">FinalWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FinalSingleton</span><span class="token punctuation">></span></span> helperWrapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">FinalSingleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">FinalWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FinalSingleton</span><span class="token punctuation">></span></span> wrapper <span class="token operator">=</span> helperWrapper<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>wrapper<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>helperWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    helperWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FinalSingleton</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FinalSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                wrapper <span class="token operator">=</span> helperWrapper<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> wrapper<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>枚举避免多线程的问题，防止反序列化重新创建对象</p><blockquote><p>补充于2020/5/7</p></blockquote><p>疑问：<code>synchronized</code> 修饰的是线程安全的，也就是说，<code>synchronzied</code> 修饰的语句是能保证可见性，有序性、原子性。那么就是为什么保证了有序性，还会发生指令重排序呢？？（为什么<code>synchronized</code> 无法禁止指令重排，却能保证有序性？）</p><p>其实这个问题涉及到的内容挺多的：</p><p><code>Java</code> 内存模型，<strong>并发编程有序性问题</strong>、指令重排、<code>synchronized</code> 锁、可重入锁、排他锁、<strong>as-if-serial语义</strong>、单线程&amp;多线程等等。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>首先看看什么是有序性：<code>Java</code> 程序中天然的有序性可以总结为一句话：<u>如果在本线程内观察、所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的</u>。</p><p>前半句是指“线程内似表现为串行的语义（<code>as-if-serial</code>）”,后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。</p><p><code>as-if-serial</code>:不管怎么重排序（编译器和处理器为了提高并行度）单线程的执行结果不能被改变。编译器、<code>runtime</code> 和处理器都必须遵守 <code>as-if-serial</code> 语义。</p><p>指令重排序：指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p><p><code>Java</code> 提供了 <code>volatile</code> 和 <code>synchronized</code> 来线程之间操作的有序性。</p><p><code>volatile</code>：主要是依靠禁止指令重排序的语义，也就是内存屏障来保证有序性。</p><p><code>synchronized</code>：具有排他锁，同一时间的一段代码只能是单个线程来执行，其他线程阻塞，符合 <code>as-if-serial</code> 语义，自然能够保证有序性。</p><p>上面就是具体的理论了，那么如果在面试中回答这个问题呢？看看大神的答案。</p><blockquote><p>为了进一步提升计算机各方面能力，在硬件层做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p><p>最好的解决有序性的问题，就是禁止处理器优化和指令重排，就像 volatile 使用内存屏障一样。但是，虽然硬件都会为了优化做一些重排，但是在 Java 中，不管怎么排序，都不能影响单线程程序的执行结果。这就是 as-if-serial 语义，所有硬件优化的前提都是必须遵守 as-if-serial 语义。</p><p>再说下 synchronized，他是 Java 提供的锁，通过它可对 Java 中的对象加锁，并且是一种排他的、可重入的锁。所以当某个线程执行到一段被 synchronized 修饰的代码之前，会先进行加锁，执行完之后在进行解锁，在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p><p>synchronized 通过排他锁的方式就保证了同一时间内，被 synchronized 修饰的代码是单线程执行的。所以呢，这就满足了 as-if-serial 语义的一个关键前提，那就是单线程，因为有 as-if-serial 语义保证，单线程的有序性就天然存在了。</p></blockquote><p>我觉得这个问题的关键还是在于理清楚<strong>有序性</strong>和<strong>指令重排</strong>的概念。</p><blockquote><p>更新与2020/5/22</p></blockquote><h2 id="如何破坏单例"><a href="#如何破坏单例" class="headerlink" title="如何破坏单例"></a>如何破坏单例</h2><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>单例模式其实对外隐藏了构造函数，保证用户无法主动创建它，但是仍然是可以有办法去破坏它。最简单的就是<strong>反射</strong>。</p><p>对于双重校验锁的单例，我们可以通过反射，简简单单就可以破坏单例了。（调用私有的构造方法）</p><p>避免方式：在构造函数中加一些判断就可以了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">VolatileSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>synchronizeLazySingleton<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Singleton constructor is called... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但个人觉得这样并没有完全解决问题，万一在反射调用构造方法之前没有调用过 <code>getInstance()</code>方法，那么就还是没有避免。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>通过先将单例对象序列化后保存到临时文件中，然后再从临时文件中反序列化出来，先序列化再反序列化的方式，可获取到一个新的单例对象，这就破坏了单例。因为在对象反序列化的过程中，序列化会通过反射调用无参数的构造方法创建一个新的对象，所以，通过反序列化也能破坏单例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//Write Obj to file</span>        <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"tempFile"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>singleton<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//Read Obj from file</span>            <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"tempFile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Singleton</span> singletonBySerialize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//判断是否是同一个对象</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"singleton : "</span> <span class="token operator">+</span> singleton<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"singletonBySerialize : "</span> <span class="token operator">+</span> singletonBySerialize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"singleton == singletonBySerialize : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> singletonBySerialize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>避免方法，上面也提到了：</p><p>只需要在Sinleton中增加readResolve方法，并在该方法中指定要返回的对象的生成策略就可以了。</p><p>因为反序列化过程中，在反序列化执行过程中会执行到ObjectInputStream#readOrdinaryObject方法，这个方法会判断对象是否包含readResolve方法，如果包含的话会直接调用这个方法获得对象实例。</p><p>没有这个方法的时候，反序列化创建对象也是通过反射，但是反序列化使用的反射构造器和我们代码中使用反射的构造器不是同一个，反序列化用到的构造器并不会调用到我们对象中的构造函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="2019/08/01/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>2019/08/01/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote><p>时间: 2019/8/1</p></blockquote><p>静态：由程序员创建代理类或特定工具自动生成源代码在对其编译。在程序运行前代理类的.class文件就已经存在了。</p><p>动态：在程序运行时运用反射机制动态创建而成。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IntefaceA</span> <span class="token punctuation">&#123;</span><span class="token keyword">void</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现类（被代理类）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterfaceAimpl</span>  <span class="token keyword">implements</span> <span class="token class-name">IntefaceA</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        number<span class="token operator">++</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"exec方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代理类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterfaceAproxy</span> <span class="token keyword">implements</span> <span class="token class-name">IntefaceA</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里的变量使用接口 这样只要是实现了接口IntefaceA的类都可以使用这个代理类</span><span class="token keyword">private</span> <span class="token class-name">IntefaceA</span> i<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">InterfaceAproxy</span><span class="token punctuation">(</span><span class="token class-name">IntefaceA</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated method stub</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">InterfaceAimpl</span> i  <span class="token operator">=</span> <span class="token keyword">new</span>  <span class="token class-name">InterfaceAimpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//被代理的对象</span><span class="token class-name">IntefaceA</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterfaceAproxy</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传入被代理的对象i</span>a<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">方法前exec方法方法后3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>代理类和被代理类都实现了同一个接口，出现了大量的代码重复。如果接口增加了一个方法，除了所有实现类需要实现这个方法外，所有的代理类也需要实现此方法，增加了代码维护的复杂度。</li><li>虽然代理类可以代理所有实现过接口IntefaceA的类，但是如果现在有一个IntefaceB的接口，那么这个代理类就很难发挥作用了，我们还需编写额外的代理类。</li><li>程序运行前代理类的.class文件就已经存在了，也就是InterfaceAproxy类。</li></ol><h2 id="java动态代理"><a href="#java动态代理" class="headerlink" title="java动态代理"></a>java动态代理</h2><p>首先要认识两个核心类：</p><ul><li><code>java.lang.reflect.Proxy</code>类</li><li><code>java.lang.reflect.InvocationHanler</code>接口</li></ul><p>Porxy类适用于创建代理对象，而InvocationHandler接口主要是来处理执行逻辑。</p><p>还以那个IntefaceA接口为例，不过我们新增一个接口B</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InterfaceB</span> <span class="token punctuation">&#123;</span><span class="token keyword">void</span> <span class="token function">execB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有他的实现类（被代理的类）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterfaceBimpl</span> <span class="token keyword">implements</span> <span class="token class-name">InterfaceB</span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这里是接口B的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑处理类ProxyHandler：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationHandler</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">&#123;</span>    <span class="token comment">//被代理的对象</span><span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>  <span class="token comment">//被代理的对象从这里传入</span><span class="token keyword">public</span> <span class="token class-name">ProxyHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>target <span class="token operator">=</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"动态代理前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//这里是反射</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"动态代理后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>log</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Proxy</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyMain</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">InterfaceAimpl</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterfaceAimpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//接口A的实现类</span><span class="token class-name">InterfaceBimpl</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterfaceBimpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//接口B的实现类</span><span class="token class-name">ProxyHandler</span> handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyHandler</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//代理A类的逻辑</span><span class="token class-name">ProxyHandler</span> handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyHandler</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//代理B类的逻辑</span><span class="token comment">//A接口代理类</span><span class="token class-name">IntefaceA</span> in <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IntefaceA</span><span class="token punctuation">)</span>    <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//B接口代理类</span><span class="token class-name">InterfaceB</span> ib <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">InterfaceB</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>in<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>ib<span class="token punctuation">.</span><span class="token function">execB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">动态代理前exec方法动态代理后3动态代理前这里是接口B的方法动态代理后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是接口A还是接口B，都是可以由Proxy来产生代理类，有InvocationHandler来处理逻辑。代理类都是动态生成的。</p><p>因为java动态代理的被代理对象都必须去实现接口，实际上生成的代理对象都是继承了Proxy类，实现了被代理对象的实现接口。</p><p>在使用中加入以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//得到父类</span><span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> clazz  <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//得到实现的接口</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span> class1 <span class="token operator">:</span> clazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>class1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到输出：</p><pre class="line-numbers language-none"><code class="language-none">class java.lang.reflect.Proxycom.nekoo.log.IntefaceA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><p>被代理对象的类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>cglib</span><span class="token punctuation">;</span><span class="token comment">//可以是一个普通类 也可以有实现接口或者继承类   但不能是final </span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonClass</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> number  <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token keyword">public</span>  <span class="token keyword">void</span> play <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"一般类"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> number<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cglib处理器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>cglib</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">Enhancer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">MethodInterceptor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">MethodProxy</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CglibProxy</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//被代理的对象</span><span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>target <span class="token operator">=</span> obj<span class="token punctuation">;</span>       <span class="token comment">//创建加强器 用来创建动态代理类</span><span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将被代理对象的类设置为父类 也就说明了为什么被代理类为什么不能被final修饰</span>enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置回调：对于代理类上所有方法的调用，都会调用callback，而callback则需要实现intercept方法进行拦截</span>enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建动态代理对象并返回</span><span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span>    <span class="token comment">//实现回调方法</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> arg0<span class="token punctuation">,</span> <span class="token class-name">Method</span> arg1<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arg2<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> arg3<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated method stub</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cglib方法前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//两种写法都可以</span><span class="token comment">//Object result = arg3.invoke(target, arg2);</span>        <span class="token class-name">Object</span> result <span class="token operator">=</span> arg3<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>arg0<span class="token punctuation">,</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cglib方法后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>nekoo<span class="token punctuation">.</span>cglib</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CglibProxy</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CglibProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//新建cglib代理器</span>    <span class="token class-name">CommonClass</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommonClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被代理的对象</span>        <span class="token class-name">CommonClass</span> cc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">CommonClass</span><span class="token punctuation">)</span> proxy<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//创建代理对象</span>        cc<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cc<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">cglib方法前一般类cglib方法后109<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方法的cc的number还是9，而被代理的对象c的number变为了10。</p><p>CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父子类中的初始化顺序</title>
      <link href="2019/05/31/%E7%88%B6%E5%AD%90%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
      <url>2019/05/31/%E7%88%B6%E5%AD%90%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>记一些特别基础的东西吧，</p><p>父类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>qxnekoo<span class="token punctuation">.</span>extend</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"father"</span><span class="token punctuation">;</span><span class="token keyword">static</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father中的静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span>  <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father的构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father中的代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>str <span class="token operator">=</span> <span class="token string">"北城槐"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>子类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>qxnekoo<span class="token punctuation">.</span>extend</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span><span class="token keyword">static</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son中的静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son中的代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son的构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>qxnekoo<span class="token punctuation">.</span>extend</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Son</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">Father中的静态代码块Son中的静态代码块Father中的代码块Father的构造函数Son中的代码块Son的构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此可见父子类中的初始化顺序了，结合资料总结：</p><pre class="line-numbers language-none"><code class="language-none">1、初始化父类的静态变量，静态代码块，初始化的顺序按照出现顺序。 2、初始化子类的静态变量，静态代码块。 3、初始化父类的成员变量和父类代码块。 4、执行父类的构造函数。 5、初始化子类的成员变量和子类代码块。 6、构造代码块创建对象时执行。 7、执行子类的构造函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实我们也可以得到一些其他的东西：</p><p>新建一个子类对象时，会调用父类的构造函数，那有没有创建父类的对象呢？</p><p>查了半天资料，答案是没有创建！</p><p>构造函数只是将这个对象（子类的对象）初始化一下而已，并没有开辟内存，new Son()才回去开辟内存这个过程只创建一个对象，父类的构造函数也是帮忙创建的。</p><p>不过确实是有内存空间来存储父类的数据的（见下文），可以用super来访问。</p><h2 id="java对象"><a href="#java对象" class="headerlink" title="java对象"></a>java对象</h2><p>每个java对象在内存中都由对象头和对象体组成。</p><p>对象头是存放对象的元信息，包括该对象所属类对象Class的引用以及hashcode和monitor的一些信息。</p><p>对象体主要存放的是java对象自身的实例域以及从<strong>父类继承过来的实例域</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal基础</title>
      <link href="2019/05/30/ThreadLocal%E5%9F%BA%E7%A1%80/"/>
      <url>2019/05/30/ThreadLocal%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h2><p>如果一个线程A执行了thread.join()，其含义是：当线程A等待thread线程终止之后才从thread.join()返回。（即线程A会从等待处继续执行）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">qxnekoo<span class="token punctuation">.</span>threadlocal</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Join</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> previous <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Nekoo</span><span class="token punctuation">(</span>previous<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>previous <span class="token operator">=</span> thread<span class="token punctuation">;</span>thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"主线程执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Nekoo</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> previous<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Nekoo</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>previous  <span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>previous<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" terminated"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等待两秒后，出现结果：</p><pre class="line-numbers language-none"><code class="language-none">主线程执行完毕1 terminated2 terminated3 terminated4 terminated5 terminated6 terminated7 terminated8 terminated9 terminated10 terminated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建十个线程，只有前驱线程执行完成后，当前线程才可以继续执行。（等待前驱线程结束，接受前驱线程结束通知）</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>介绍：</p><blockquote><p><em>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是</em>private static<em>类型的，用于关联线程和线程的上下文。</em></p></blockquote><p>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p><p>初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p><h3 id="initialValue函数"><a href="#initialValue函数" class="headerlink" title="initialValue函数"></a><strong>initialValue函数</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数在调用get函数的时候会第一次调用，但是如果一开始就调用了set函数，则该函数不会被调用。通常该函数只会被调用一次，除非手动调用了remove函数之后又调用get函数，这种情况下，get函数中还是会调用initialValue函数。该函数是protected类型的，很显然是建议在子类重载该函数的，所以通常该函数都会以匿名内部类的形式被重载，以指定初始值</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">qxnekoo<span class="token punctuation">.</span>threadlocal</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestThreadLocal</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> value<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> arrgs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span>index<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">"的初始value："</span><span class="token operator">+</span>value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>value<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">"的累加value"</span><span class="token operator">+</span>value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">线程0的初始value：1线程0的累加value46线程2的初始value：1线程1的初始value：1线程1的累加value46线程4的初始value：1线程2的累加value46线程4的累加value46线程3的初始value：1线程3的累加value46<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，各个线程的value值是相互独立的，本线程的累加操作不会影响到其他线程的值，真正达到了线程内部隔离的效果。</p><p>在这里只进行简单概念性的介绍，深入的内容之后有机会会来记录。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等待/通知机制</title>
      <link href="2019/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
      <url>2019/05/28/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object，方法和描述：</p><table><thead><tr><th align="center">方法名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">notify()</td><td align="left">通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁</td></tr><tr><td align="center">notifyAll()</td><td align="left">通知所有等待在该对象上的线程</td></tr><tr><td align="center">wait()</td><td align="left">调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁</td></tr><tr><td align="center">wait(long)</td><td align="left">超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回</td></tr><tr><td align="center">wait(long,int)</td><td align="left">对于超时时间更细粒度的控制，可以达到纳秒</td></tr></tbody></table><p>那么notify()和notifyAll()的区别是什么呢？</p><p>需要引入两个概念：锁池，等待池</p><h2 id="锁池-等待池"><a href="#锁池-等待池" class="headerlink" title="锁池 等待池"></a>锁池 等待池</h2><p><strong>锁池</strong>：假设线程A已经拥有了某个对象（不是类）的锁，而其他的线程想要调用这个对象的某个synchronized方法（或者synchronized块），由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入该对象的锁池中。</p><p><strong>等待池</strong>：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到该对象的等待池中。</p><ul><li><p>如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，<strong>等待池中的线程不会去竞争该对象的锁</strong>。</p></li><li><p>当有现成调用了对象的notifyAll()方法（唤醒所有wait进程）或notify（只随机唤醒一个wait线程），<strong>锁池中的线程会去竞争该对象锁</strong>。notify只会将等待池中的一个线程放到锁池中，而notifyAll()则会把等待池中所有的线程放到锁池。</p></li><li><p>在锁池中，竞争对象锁时，线程优先级高的线程获取锁的概率大，如果某线程没有获取到锁对象，那么<strong>就会留在锁池中</strong>，只有再次调用wait()方法，它才会重新回到等待池中。拿到锁对象的线程会执行synchronized块，执行完会释放掉该对象锁，这是锁池中的线程会继续竞争该对象锁。</p></li></ul><p>总结一下，也是就notifyAll()会将等待池中的所有线程移动到锁池，锁池里面的所有线程竞争对象锁，如果没有竞争到，那么就会留在锁池中，等待下次竞争。而notify只会将等待池中一个线程移动到锁池中。</p><p>这样就会出现一个问题，使用notify的话，可能一个线程在等待池中一直没有被移动到锁池中，那么就会导致饥饿现象，甚至是死锁。</p><p>而notifyAll()就不大可能会出现这种问题。</p><p>等待池其实是一个等待队列，锁池其实就是一个同步队列，被唤醒的线程会由等待队列进入到同步队列中去。</p><p><em>猜测：等待队列的线程是WAITING状态，同步队列里的线程是BLCOKED状态。</em></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">qxnekoo<span class="token punctuation">.</span>notify</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitNotify</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag  <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> waitThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"waitThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> notifyThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"notifyThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    waitThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notifyThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Wait</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//检测到flag为false则跳出循环</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" flag is true.wait @ "</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此线程在这里进入等待池并且会释放掉对象锁  再次获得锁时才会继续往下执行 </span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated catch block</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" flag is false.running @"</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Notify</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" hold lock.notify @"</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在这里唤醒持有该对象锁的所有线程 将它们放入到锁池中 等待竞争锁</span>    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated catch block</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//A  在这里退出同步块 所以lock对象锁会被锁池里的线程竞争</span>        <span class="token comment">//再次加锁  会与waitThread线程竞争lock对象锁</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" hold lock again.sleep @"</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated catch block</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">waitThread flag is true.wait @ 20:22:36notifyThread hold lock.notify @20:22:37notifyThread hold lock again.sleep @20:22:42waitThread flag is false.running @20:22:47<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第三行和第四行可能位置互换，这是因为notifyThread在A处退出同步块时，notifyThread会和waitThread竞争对象锁，竞争到了会继续执行。</p><p>有关synchronized相关知识点：</p><p><a href="https://github.com/nekoozero/Java-Interview/blob/master/MD/Synchronize.md">https://github.com/nekoozero/Java-Interview/blob/master/MD/Synchronize.md</a></p><h2 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h2><p>该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。</p><p>等待方（消费者）遵循如下原则：</p><ol><li>获取对象的锁</li><li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li><li>条件满足则执行对应的逻辑 。</li></ol><p>对应的伪代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>条件不满足<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      对象<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  处理逻辑，开始消费<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通知方（通知方）遵循如下原则：</p><ol><li>获取对象的锁</li><li>改变条件</li><li>通知所有等待在对象上的线程</li></ol><p>对应的伪代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    生产者开始生产    改变条件    对象<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程中断</title>
      <link href="2019/05/27/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
      <url>2019/05/27/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h2><p>中断可以理解为线程的<strong>一个标识位属性</strong>，它表示一个运行中的线程是否被其他线程进行了中断操作。其它线程通过调用该线程的interrupt()方法对其进行中断操作。</p><p><em>线程通过检查自身是否被中断来进行响应</em>，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrrupted()对<strong>当前线程的中断标志位进行复位。</strong></p><p>如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。</p><h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><p>从上面可以知道三个方法<code>interrupt()</code>、<code>isInterrupted()</code>、<code>interrrupted</code>。其中interrupted是静态方法，即该方法是属于类的，不是属于对象的。对象可以调用，但语义会发生变化。</p><p>也有个类似的方法Thread.currentThread()，获取当前线程对象，我一开始写出了这样的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> thread  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里一开始想获取thread的线程名，但结果是主线程的线程名。</p><p>因为currentThread()是Thread类的静态方法，这里的thread固然是可以调用，而且也不会报错，但是执行的时候得到的肯定是主线程的名字。</p><h2 id="有关代码"><a href="#有关代码" class="headerlink" title="有关代码"></a>有关代码</h2><p>写一点代码来验证一下（<strong>涉及到多线程，所以代码运行上可能每次结果都不一样，但足以说明结论就行</strong>）</p><p>但是要明确一点，只调用interrupted是不会是线程停止运行，线程还是会继续执行的，是需要代码来检测是否被中断从而做出响应。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">qxnekoo<span class="token punctuation">.</span>thread</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interrupt</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Thread.sleep(500);   //  A</span>t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Thread.sleep(1000);    //  B  </span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"one线程的状态："</span><span class="token operator">+</span>t<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token string">"主线程中one线程中断的标志位"</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Runner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//没有中断就i++</span>i<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//中断了就跳出循环</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i的值为："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-none"><code class="language-none">i的值为：0one线程的状态：RUNNABLE 主线程中one线程中断的标志位true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其实在这边我们就可以看出，中断之后，线程还是会继续执行后面的代码逻辑。也就是我们所说的：<strong>线程通过检查自身是否被中断来进行响应</strong>，把A处的注释去掉，即让one进程执行0.5秒再中断。</p><pre class="line-numbers language-none"><code class="language-none">i的值为：565907526one线程的状态：RUNNABLE 主线程中one线程中断的标志位true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时，将B出的注释去掉，意思是主线程沉睡1秒，让one线程执行完毕，状态为TERMINTED</p><pre class="line-numbers language-none"><code class="language-none">i的值为：568998532one线程的状态：TERMINATED 主线程中one线程中断的标志位false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到，线程结束后获得的标志位为false。</p><p>最后看一下Thread.interrrupted()这个方法,这次我们写的更具体一点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">qxnekoo<span class="token punctuation">.</span>thread</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interrupt</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//主线程连续9次输入one线程的状态  途中可能会发生状态的变化</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"次"</span><span class="token operator">+</span><span class="token string">"one线程的状态："</span><span class="token operator">+</span>t<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token string">"主线程中one线程中断的标志位"</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Runner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">Thread.currentThread()之前的标志位：true第1次one线程的状态：RUNNABLE 主线程中one线程中断的标志位trueThread.currentThread()之前的标志位：false第2次one线程的状态：RUNNABLE 主线程中one线程中断的标志位false第3次one线程的状态：TERMINATED 主线程中one线程中断的标志位false第4次one线程的状态：TERMINATED 主线程中one线程中断的标志位false第5次one线程的状态：TERMINATED 主线程中one线程中断的标志位false第6次one线程的状态：TERMINATED 主线程中one线程中断的标志位false第7次one线程的状态：TERMINATED 主线程中one线程中断的标志位false第8次one线程的状态：TERMINATED 主线程中one线程中断的标志位false第9次one线程的状态：TERMINATED 主线程中one线程中断的标志位false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能更好理解两个线程运行的过程了。</p><p>以上可以验证我们的观点：</p><ul><li>单单中断是不会让线程停止运行的，只会改变一个标志位，需要在线程中处理相关的逻辑。</li><li>如果一个线程已经变为TERMINTED，即使被中断过，调用该线程对象的isInterrupted()时依旧会返回false。</li><li>静态方法Thread.interrrupted()会对当前线程的中断标志位进行复位。</li></ul><h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法），这些方法在抛出InterruptedException之前，<strong>Java虚拟机会先将该线程的中断标识位清除</strong>，然后抛出InterruptedException，<strong>此时调用isInterrupted()方法将会返回false</strong>。</p><p>修改一下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">qxnekoo<span class="token punctuation">.</span>thread</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interrupt</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"one线程的状态："</span><span class="token operator">+</span>t<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token string">"主线程中one线程中断的标志位"</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Runner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中断的标志位："</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">sleep interruptedone线程的状态：RUNNABLE 主线程中one线程中断的标志位false中断的标志位：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到one线程现在还是Runnable，但是主线程中获得的中断标志位为false，其实在interrupte()之后我们在one线程中来获取它自己的中断标志位已经为false了。也就验证了我们的观点。</p><h2 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h2><p>suspend()、resume()、stop()方法会带来副作用，所以已经过期了，暂停和恢复操作可以用后面提到的等待/通知机制来替代，现在讲讲比较基本的终止线程。</p><p>上面提到中断状态是一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或者停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。它们都能使线程终止时有机会去清理资源。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">qxnekoo<span class="token punctuation">.</span>thread</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShutDown</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Runner</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> countThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span><span class="token string">"interruptThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countThread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runner</span> two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span> countThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>two<span class="token punctuation">,</span><span class="token string">"flagThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    two<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Runner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> i<span class="token punctuation">;</span>        <span class="token comment">//利用volatile  保证顺序性</span>        <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> on <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated method stub</span>            <span class="token comment">//如果on为true并且当前线程中断标志位为true 就i++</span><span class="token keyword">while</span><span class="token punctuation">(</span>on <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    on <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">i&#x3D;571750957i&#x3D;571421771<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里有两个线程，interruptThread线程通过中断标志位来停止线程，flagThread通过变量停止线程。</p><p>这里使用了volatile关键字，依我看来是用来保证顺序性的，因为on变量并不是用来线程通信的，是线程单独享有的变量，自然不存在可见性的问题；volatile是无法保证原子性的。（不能用volatile来修饰类似于i++这种操作的变量）</p><ul><li>volatile用来告知程序任何对该变量的访问均需从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</li><li>但是过多的使用volatile是不好的，因为它会降低程序执行的效率。</li></ul><h2 id="记录一下创建线程的方式"><a href="#记录一下创建线程的方式" class="headerlink" title="记录一下创建线程的方式"></a>记录一下创建线程的方式</h2><p>详细来说有四种</p><ol><li>继承Thread类，重写run方法。</li><li>实现Runnable接口。</li><li>使用Callable和Future创建线程。</li><li>利用线程池。</li></ol><p>1和2比较起来：</p><ul><li>实现Runnable接口避免多继承局限。</li><li>实现Runnable()可以更好的体现共享的概念。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS(Compare And Swap)</title>
      <link href="2019/05/20/CAS/"/>
      <url>2019/05/20/CAS/</url>
      
        <content type="html"><![CDATA[<p>CAS,即比较并替换，实现并发算法时常用到的一种技术，Doug lea大神在java同步器中大量使用了CAS技术，实现了多线程执行的安全性。</p><p>CAS的思想很简单：<code>三个参数，一个当前内存值V，就得预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</code></p><p>先看一段代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果这段代码在并发下执行，会发生什么？</p><p>假设线程1和线程2都过了a==1的监测，都准备对a赋值，结果就是两个线程同时修改了变量a，显然这种结果是无法符合预期的，无法确定a的最终值。</p><p>解决的方法也同样暴力，在compareAndSwapInt方法加锁同步，变成一个原子操作，同一时刻只有一个线程才能修改变量a。</p><p>除了低性能的加锁方法，我们还可以使用jdk自带的CAS方案，<strong>在CAS中，比较并替换是一组原子操作，不会被外部打断，且在性能上更占优势。</strong></p><h1 id="在java中的实现：Unsafe类"><a href="#在java中的实现：Unsafe类" class="headerlink" title="在java中的实现：Unsafe类"></a>在java中的实现：Unsafe类</h1><p>Unsafe类存在于<code>sun.misc</code>包中，其内部方法操作可以向C的指针一样直接操作内存，但从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有者类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是<strong>native</strong>修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。利用处理器提供的<code>CMPXCHG</code>指令来实现</p><h2 id="Unsafe里的CAS操作相关"><a href="#Unsafe里的CAS操作相关" class="headerlink" title="Unsafe里的CAS操作相关"></a>Unsafe里的CAS操作相关</h2><p>CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作的CAS都是基于以下三个方法实现。Atomic系列内部方法是基于下述方法的实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，</span><span class="token comment">//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token class-name">Object</span> expected<span class="token punctuation">,</span> <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">int</span> expected<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">long</span> expected<span class="token punctuation">,</span><span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="挂起与恢复"><a href="#挂起与恢复" class="headerlink" title="挂起与恢复"></a>挂起与恢复</h2><p>将一个线程进行挂起是通过park方法实现的，调用park后，线程将一直阻塞知道超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。Java对线程的挂起操作被封装在LockSupport类中，LockSupport类中有各种版本的pack方法，其底层最终还是使用Unsafe.park()方法和Unsafe.unpark()方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。  public native void park(boolean isAbsolute, long time);   &#x2F;&#x2F;终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，其底层正是使用这两个方法，  public native void unpark(Object thread); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="在java中的应用：Atomic系列"><a href="#在java中的应用：Atomic系列" class="headerlink" title="在java中的应用：Atomic系列"></a>在java中的应用：Atomic系列</h1><p>CAS在Java中的应用，即并发包中的原子操作类(Atomic系列)，从JDK 1.5开始提供了java.util.concurrent.atomic包，在该包中提供了许多基于CAS实现的原子操作类，用法方便，性能高效。</p><p>##原子更新基本类型</p><ul><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ul><p>这3个类的实现原理和使用方式几乎是一样的，这里我们以AtomicInteger为例进行分析，AtomicInteger主要是针对int类型的数据执行原子操作，它提供了原子自增方法、原子自减方法以及原子赋值方法等，鉴于AtomicInteger的源码不多，我们直接看源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6214790243416807050L</span><span class="token punctuation">;</span>     <span class="token comment">// 获取指针类Unsafe</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//下述变量value在AtomicInteger实例对象内的内存偏移量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>           <span class="token comment">//通过unsafe类的objectFieldOffset()方法，获取value变量在对象内存中的偏移</span>           <span class="token comment">//通过该偏移量valueOffset，unsafe类的内部方法可以获取到变量value对其进行取值或赋值操作</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span>objectFieldOffset                <span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//当前AtomicInteger封装的int变量value</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//获取当前最新值，</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//设置当前值，具备volatile效果，方法用final修饰是为了更进一步的保证线程安全。</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//最终会设置成newValue，使用该方法后可能导致其他线程在之后的一小段时间内可以获取到旧值，有点类似于延迟加载</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unsafe<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//设置新值并获取旧值，底层调用的是CAS操作即unsafe.compareAndSwapInt()方法</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//如果当前值为expect，则设置为update(当前值指的是value变量)   重要</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//当前值加1返回旧值，底层CAS操作</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//当前值减1，返回旧值，底层CAS操作</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//当前值增加delta，返回旧值，底层CAS操作</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//当前值加1，返回新值，底层CAS操作</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//当前值减1，返回新值，底层CAS操作</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//当前值增加delta，返回新值，底层CAS操作</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span> <span class="token operator">+</span> delta<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//省略一些不常用的方法....</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述的分析，可以发现AtomicInteger原子类的内部几乎是基于前面分析过Unsafe类中的CAS相关操作的方法实现的，这也同时证明AtomicInteger是基于无锁实现的，这里重点分析自增操作实现过程，其他方法自增实现原理一样。</p><p>我们发现AtomicInteger类中所有自增或自减的方法都间接调用Unsafe类中的getAndAddInt()方法实现了CAS操作，从而保证了线程安全，关于getAndAddInt其实前面已分析过，它是Unsafe类中1.8新增的方法，源码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Unsafe类中的getAndAddInt方法</span><span class="token comment">/**     * Atomically adds the given value to the current value.     *     * @param delta the value to add     * @return the previous value     */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        v <span class="token operator">=</span> <span class="token function">getIntVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><ol><li>CAS存在一个很明显的问题，即ABA问题。</li></ol><p>问题：如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？</p><p>如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。</p><blockquote><p>AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境。</p><p>底层实现为： 通过Pair私有内部类存储数据和时间戳, 并构造volatile修饰的私有实例。<br>接着看AtomicStampedReference类的compareAndSet（）方法的实现：</p></blockquote><blockquote><p>同时对当前数据和当前时间进行比较，只有两者都相等是才会执行casPair()方法，单从该方法的名称就可知是一个CAS方法，最终调用的还是Unsafe类中的compareAndSwapObject方法,到这我们就很清晰AtomicStampedReference的内部实现思想了，通过一个键值对Pair存储数据和时间戳，在更新时对数据和时间戳进行比较，只有两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换，也就避免了ABA的问题。</p></blockquote><ol start="2"><li>循环时间长的话开销很大。</li><li>只能保证一个共享变量的原子操作。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 中的序列化</title>
      <link href="2019/05/20/java%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>2019/05/20/java%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>什么是序列化？</p><p>为了保存在内存中的各个对象的状态，并且可以把保存的对象状态再读出来。保存对象状态的机制，就是序列化。</p><p>专业一点： </p><p>序列化就是把Java对象转换为字节序列的过程。</p><p>反序列化就是把字节序列恢复为Java对象过程。</p><ul><li>为什么序列化</li></ul><ol><li>当想要把内存中的对象保存到一个文件中或者数据库中</li><li>当用套接字在网络上传送对象</li><li>通过RMI传输对象的时候</li></ol><p>当我们保存地时候不仅仅是保存对象的实例变量的值，JVM还要保存一些销量信息，比如类的类型等以便恢复原来的对象。</p><ul><li>序列化的方式</li></ul><p>如果一个对象想要实现序列化，必须实现下面两个接口之一：</p><ol><li>Serializable接口</li><li>Externalizable接口</li></ol><p>就不分开详细讲了。</p><ul><li>使用</li></ul><p>实体类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>crossoverjie<span class="token punctuation">.</span>utils</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Serializable</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span>  <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span>  <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> username<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> password<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>crossoverjie<span class="token punctuation">.</span></span><span class="token class-name">Seriablize</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>crossoverjie<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token class-name">User</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransientTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">User</span> user  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">/</span>        user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"qxnekoo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"2222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"序列化之前："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"username:"</span> <span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"password:"</span> <span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token class-name">ObjectOutputStream</span> os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"C:/user.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            os<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>            os<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token class-name">ObjectInputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"C:/user.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> is<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"序列化之后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"username:"</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"password:"</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">序列化之前：username:qxnekoopassword:2222序列化之后username:qxnekoopassword:2222<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意事项</li></ul><ol><li>当父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li><li>并非所有对象都可以序列化</li></ol><ul><li>serialVersionUID（版本号）</li></ul><p>一个对象数据，在反序列化过程中，如果序列化串中的serialVersionUID与当前对象值不同，则反序列化失败，否则成功。</p><p>如果serialVersionUID没有显式生成，<em>系统就会自动构成一个</em>。<strong>类名、类及其属性修饰符、接口及接口顺序、属性、静态初始化、构造器</strong>，任何一项的改变都会导致serialVersionUID变化。</p><p>为了避免这个问题，因为serialVersionUID的不同而导致反序列化失败，一般系统都会要求实现Serializable接口的类显式的声明一个serialVersionUID。</p><p>如果我们保持了serialVersionUID的一致，则在反序列化时，对于新增的字段会填入默认值null（int的默认值为0），对于减少的字段则直接忽略。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>一个类的有些属性需要序列化，而其他属性不需要序列化，比如说用户的敏感信息，这些信息对应的变量就可以加上transient关键字。这个字段的声明周期仅存在与调用者的内存中而不会写到磁盘里持久化。</p><p>上面的代码中，给password加上关键字transient,得到的结果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">序列化之前：username:qxnekoopassword:2222序列化之后username:qxnekoopassword:null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意事项</li></ul><ol><li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要下实现Serializable接口。</li><li>被transient关键字修饰的变量不再被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。因为静态变量不归属于对象，属于类本身。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值传递和引用传递</title>
      <link href="2019/05/14/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>2019/05/14/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>首先，我觉得这段话非常有道理：</p><blockquote><p>不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。<br>更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。<br>这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。</p><p>作者：Intopass</p><p>链接：<a href="https://www.zhihu.com/question/31203609/answer/50992895">https://www.zhihu.com/question/31203609/answer/50992895</a></p><p>来源：知乎</p></blockquote><h2 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h2><p>对于基本类型来说，变量里面保存的就是值，对于引用类型而言，变量中保存的实际对象的地址。称这个变量为“引用”，引用指向实际的对象。</p><h2 id="的作用"><a href="#的作用" class="headerlink" title="= 的作用"></a>= 的作用</h2><p>虽然叫的最多是等于号，但是最确切的叫法是<strong>赋值运算符</strong>，那么他最简单的用法该去怎么理解呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>   <span class="token comment">//str 存的是一个引用 引用指向实际的对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于基本类型，<code>num = 20;</code> 赋值运算符会直接改变变量的值，原来的值被覆盖掉。</p><p>对于引用类型，赋值运算符会改变引用中所保存的地址，<code>str = &quot;world&quot;</code> 导致引用被改变，指向了新的对象，<strong>而原来的引用不变，原来的对象也不会被改变</strong>。</p><p>= 的详细内容还有很多，就不展开说了。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>一句话：<strong>参数传递基本上就是赋值操作。</strong></p><p>我之前在参数调用的过程中，默认将函数调用的参数等同于我们定义的变量，这是错误的想法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">'北城槐'</span><span class="token punctuation">;</span><span class="token function">someMethod</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//传入参数的时候其实做了赋值运算 n = num; s = str;</span><span class="token comment">//函数定义</span><span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//do something</span>     n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     s <span class="token operator">=</span> <span class="token string">'qxnekoo'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以函数里的操作实际上还是对参数 n 和 s 的操作,并不会真正影响到 num 和 str 的值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>u<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"nekoo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>getUsername<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//nekoo</span><span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token class-name">User</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//将变量u的引用赋值给参数u</span>    u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//参数u的引用已经改变了 </span>    u<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"qx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>u<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"nekoo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>getUsername<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//qx</span><span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token class-name">User</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//将变量u的引用赋值给参数u</span>    u<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"qx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//参数u的引用没有发生改变</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再详细一点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">第一个例子：基本类型<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// num 没有被改变</span>第二个例子：没有提供改变自身方法的引用类型<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    text <span class="token operator">=</span> <span class="token string">"windows"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// str 也没有被改变</span>第三个例子：提供了改变自身方法的引用类型<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"iphone"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sb 被改变了，变成了"iphone4"。</span>第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"iphone"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ipad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sb 没有被改变，还是 "iphone"。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得一提的是，String等immutable类型因为没有提供自身修改的函数，<strong>每次操作</strong>都是新生成一个对象，所以要特殊对待，常量池也是要注意的。</p><blockquote><p>补充于2020/5/7</p></blockquote><h2 id="求值策略"><a href="#求值策略" class="headerlink" title="求值策略"></a>求值策略</h2><p>方法调用时，需要把实际参数传递给形式参数，那么传递的过程中到底传递的是什么呢？</p><p>其实就是程序设计中的<strong>求值策略</strong>。</p><p>求值策略分为两大基本类，基于如何处理给函数的实际参数，分为严格的和非严格的。</p><p>我们一般只关注严格求值。</p><p>在严格求值中有几个关键的求值策略是我们比较关心的，那就是<strong>传值调用</strong>（Call by value）、<strong>传引用调用</strong>（Call by reference）以及<strong>传共享对象调用</strong>（Call by sharing）。</p><ul><li><p>传值调用（值传递）</p></li><li><ul><li> 在传值调用中，实际参数先被求值，然后其值通过复制，被传递给被调函数的形式参数。因为形式参数拿到的只是一个”局部拷贝”，所以如果在被调函数中改变了形式参数的值，并不会改变实际参数的值。</li></ul></li><li><p>传引用调用（应用传递）</p></li><li><ul><li>在传引用调用中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。因为传递的是引用，所以，如果在被调函数中改变了形式参数的值，改变对于调用者来说是可见的。</li></ul></li><li><p>传共享对象调用（共享对象传递）</p></li><li><ul><li>传共享对象调用中，先获取到实际参数的地址，然后将其复制，并把该地址的拷贝传递给被调函数的形式参数。因为参数的地址都指向同一个对象，所以我们称也之为”传共享对象”，所以，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。</li></ul></li></ul><p>对于这个问题，我们应该关注过程，而不是结果，<strong>因为传共享对象调用的过程和传值调用的过程是一样的，而且都有一步关键的操作，那就是”复制”，所以，通常我们认为传共享对象调用是传值调用的特例</strong>。</p><p>很多人通过代码示例的现象说明Java对象是引用传递，但其实通过官方文档：</p><blockquote><p>Reference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object’s fields can be changed in the method, if they have the proper access level.</p></blockquote><p><strong>也就是说，引用数据类型参数(如对象)也按值传递给方法。这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适当的访问级别，则可以在方法中更改这些字段的值。</strong></p><p>这一点官方文档已经很明确的指出了，Java就是值传递，只不过是把对象的引用当做值传递给方法。这其实就是共享对象传递。</p><p><strong>我们可以总结说，Java中的求值策略是共享对象传递，这是完全正确的。</strong></p><p>但是，为了让大家都能理解你说的，<strong>我们说Java中只有值传递，只不过传递的内容是对象的引用。这也是没毛病的。</strong></p><p>但是，绝对不能认为Java中有引用传递。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
